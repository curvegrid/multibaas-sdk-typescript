/* tslint:disable */
/* eslint-disable */
/**
 * MultiBaas API
 * MultiBaas\'s REST APIv0.
 *
 * The version of the OpenAPI document: 0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * An API key.
 * @export
 * @interface APIKey
 */
export interface APIKey {
  /**
   * A label.
   * @type {string}
   * @memberof APIKey
   */
  label: string;
  /**
   *
   * @type {number}
   * @memberof APIKey
   */
  id: number;
  /**
   * The time the API key was created.
   * @type {string}
   * @memberof APIKey
   */
  createdAt: string;
  /**
   * The time the API key was last used.
   * @type {string}
   * @memberof APIKey
   */
  lastUsedAt?: string;
  /**
   * The ID of the user that created the API key.
   * @type {number}
   * @memberof APIKey
   */
  createdBy: number;
  /**
   * The signature of the API key.
   * @type {string}
   * @memberof APIKey
   */
  signature: string;
}
/**
 *
 * @export
 * @interface APIKeyAllOf
 */
export interface APIKeyAllOf {
  /**
   *
   * @type {number}
   * @memberof APIKeyAllOf
   */
  id: number;
  /**
   * The time the API key was created.
   * @type {string}
   * @memberof APIKeyAllOf
   */
  createdAt: string;
  /**
   * The time the API key was last used.
   * @type {string}
   * @memberof APIKeyAllOf
   */
  lastUsedAt?: string;
  /**
   * The ID of the user that created the API key.
   * @type {number}
   * @memberof APIKeyAllOf
   */
  createdBy: number;
  /**
   * The signature of the API key.
   * @type {string}
   * @memberof APIKeyAllOf
   */
  signature: string;
}
/**
 * Add key request data.
 * @export
 * @interface AddKey
 */
export interface AddKey {
  /**
   * The Application ID that will be accessing the Key Vault.
   * @type {string}
   * @memberof AddKey
   */
  clientID: string;
  /**
   * The name of the key.
   * @type {string}
   * @memberof AddKey
   */
  keyName: string;
  /**
   * The version of the key.
   * @type {string}
   * @memberof AddKey
   */
  keyVersion: string;
  /**
   * The name given to the vault your key is stored in.
   * @type {string}
   * @memberof AddKey
   */
  vaultName: string;
}
/**
 * An address details.
 * @export
 * @interface Address
 */
export interface Address {
  /**
   * A label.
   * @type {string}
   * @memberof Address
   */
  label: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof Address
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  balance?: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  chain: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Address
   */
  modules: Array<string>;
  /**
   * The next transaction nonce for this address (obtained from the blockchain node).
   * @type {number}
   * @memberof Address
   */
  nonce?: number;
  /**
   * The next transaction nonce for this address when using the nonce management feature.
   * @type {number}
   * @memberof Address
   */
  localNonce?: number;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  codeAt?: string;
  /**
   *
   * @type {Array<ContractMetadata>}
   * @memberof Address
   */
  contracts: Array<ContractMetadata>;
}
/**
 *
 * @export
 * @interface AddressAllOf
 */
export interface AddressAllOf {
  /**
   *
   * @type {string}
   * @memberof AddressAllOf
   */
  balance?: string;
  /**
   *
   * @type {string}
   * @memberof AddressAllOf
   */
  chain: string;
  /**
   *
   * @type {Array<string>}
   * @memberof AddressAllOf
   */
  modules: Array<string>;
  /**
   * The next transaction nonce for this address (obtained from the blockchain node).
   * @type {number}
   * @memberof AddressAllOf
   */
  nonce?: number;
  /**
   * The next transaction nonce for this address when using the nonce management feature.
   * @type {number}
   * @memberof AddressAllOf
   */
  localNonce?: number;
  /**
   *
   * @type {string}
   * @memberof AddressAllOf
   */
  codeAt?: string;
  /**
   *
   * @type {Array<ContractMetadata>}
   * @memberof AddressAllOf
   */
  contracts: Array<ContractMetadata>;
}
/**
 * An address and it\'s label.
 * @export
 * @interface AddressLabel
 */
export interface AddressLabel {
  /**
   * A label.
   * @type {string}
   * @memberof AddressLabel
   */
  label: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof AddressLabel
   */
  address: string;
}
/**
 * An audit log entry.
 * @export
 * @interface AuditLog
 */
export interface AuditLog {
  /**
   * The ID of the user who performed the action.
   * @type {number}
   * @memberof AuditLog
   */
  actionByID: number;
  /**
   * The ID of the user who was acted upon.
   * @type {number}
   * @memberof AuditLog
   */
  actionOnID?: number;
  /**
   * The email of the user who performed the action.
   * @type {string}
   * @memberof AuditLog
   */
  actionByUserEmail: string;
  /**
   * The email of the user who was acted upon.
   * @type {string}
   * @memberof AuditLog
   */
  actionOnUserEmail?: string;
  /**
   * The type of action that was performed.
   * @type {string}
   * @memberof AuditLog
   */
  type: string;
  /**
   * The time the action was performed.
   * @type {string}
   * @memberof AuditLog
   */
  createdAt: string;
  /**
   * The data associated with the action.
   * @type {object}
   * @memberof AuditLog
   */
  activityData: object;
}
/**
 * An Azure account.
 * @export
 * @interface AzureAccount
 */
export interface AzureAccount {
  /**
   * A label.
   * @type {string}
   * @memberof AzureAccount
   */
  label: string;
  /**
   * The Application ID that will be accessing the Key Vault.
   * @type {string}
   * @memberof AzureAccount
   */
  clientID: string;
  /**
   * The application’s secret key that you generate when you first register the application in Azure.
   * @type {string}
   * @memberof AzureAccount
   */
  clientSecret: string;
  /**
   * Also known as Directory ID.
   * @type {string}
   * @memberof AzureAccount
   */
  tenantID: string;
  /**
   * The ID linked to your subscription to Azure services.
   * @type {string}
   * @memberof AzureAccount
   */
  subscriptionID: string;
  /**
   * The Resource Group Name for the resource being accessed.
   * @type {string}
   * @memberof AzureAccount
   */
  baseGroupName: string;
  /**
   *
   * @type {number}
   * @memberof AzureAccount
   */
  id: number;
}
/**
 *
 * @export
 * @interface AzureAccountAllOf
 */
export interface AzureAccountAllOf {
  /**
   *
   * @type {number}
   * @memberof AzureAccountAllOf
   */
  id: number;
}
/**
 * An HSM Wallet
 * @export
 * @interface AzureHardwareWallet
 */
export interface AzureHardwareWallet {
  /**
   *
   * @type {number}
   * @memberof AzureHardwareWallet
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof AzureHardwareWallet
   */
  azureAccountID: number;
  /**
   * The name given to the vault your key is stored in.
   * @type {string}
   * @memberof AzureHardwareWallet
   */
  vaultName: string;
  /**
   * The name of the key.
   * @type {string}
   * @memberof AzureHardwareWallet
   */
  keyName: string;
  /**
   * The version of the key.
   * @type {string}
   * @memberof AzureHardwareWallet
   */
  keyVersion: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof AzureHardwareWallet
   */
  publicAddress: string;
}
/**
 * An HSM Wallet returned when a new key is created
 * @export
 * @interface AzureWallet
 */
export interface AzureWallet {
  /**
   * The name of the key.
   * @type {string}
   * @memberof AzureWallet
   */
  keyName: string;
  /**
   * The version of the key.
   * @type {string}
   * @memberof AzureWallet
   */
  keyVersion: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof AzureWallet
   */
  publicAddress: string;
}
/**
 * An API key.
 * @export
 * @interface BaseAPIKey
 */
export interface BaseAPIKey {
  /**
   * A label.
   * @type {string}
   * @memberof BaseAPIKey
   */
  label: string;
}
/**
 * An Azure account.
 * @export
 * @interface BaseAzureAccount
 */
export interface BaseAzureAccount {
  /**
   * A label.
   * @type {string}
   * @memberof BaseAzureAccount
   */
  label: string;
  /**
   * The Application ID that will be accessing the Key Vault.
   * @type {string}
   * @memberof BaseAzureAccount
   */
  clientID: string;
  /**
   * The application’s secret key that you generate when you first register the application in Azure.
   * @type {string}
   * @memberof BaseAzureAccount
   */
  clientSecret: string;
  /**
   * Also known as Directory ID.
   * @type {string}
   * @memberof BaseAzureAccount
   */
  tenantID: string;
  /**
   * The ID linked to your subscription to Azure services.
   * @type {string}
   * @memberof BaseAzureAccount
   */
  subscriptionID: string;
  /**
   * The Resource Group Name for the resource being accessed.
   * @type {string}
   * @memberof BaseAzureAccount
   */
  baseGroupName: string;
}
/**
 * A contract.
 * @export
 * @interface BaseContract
 */
export interface BaseContract {
  /**
   * A label.
   * @type {string}
   * @memberof BaseContract
   */
  label: string;
  /**
   * The name of the contract.
   * @type {string}
   * @memberof BaseContract
   */
  contractName: string;
  /**
   * The contract version.
   * @type {string}
   * @memberof BaseContract
   */
  version: string;
  /**
   * The smart-contract bytecode.
   * @type {string}
   * @memberof BaseContract
   */
  bin?: string;
  /**
   * The contract raw ABI JSON string.
   * @type {string}
   * @memberof BaseContract
   */
  rawAbi: string;
  /**
   * The user documentation JSON string.
   * @type {string}
   * @memberof BaseContract
   */
  userDoc: string;
  /**
   * The developer documentation JSON string.
   * @type {string}
   * @memberof BaseContract
   */
  developerDoc: string;
  /**
   * The contract metadata JSON string.
   * @type {string}
   * @memberof BaseContract
   */
  metadata?: string;
  /**
   *
   * @type {boolean}
   * @memberof BaseContract
   */
  isFavorite?: boolean;
}
/**
 * Standard response.
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
  /**
   * The status code.
   * @type {number}
   * @memberof BaseResponse
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof BaseResponse
   */
  message: string;
}
/**
 * A transaction to be signed.
 * @export
 * @interface BaseTransactionToSign
 */
export interface BaseTransactionToSign {
  /**
   *
   * @type {BaseTransactionToSignTx}
   * @memberof BaseTransactionToSign
   */
  tx: BaseTransactionToSignTx;
}
/**
 * An Ethereum transaction.
 * @export
 * @interface BaseTransactionToSignTx
 */
export interface BaseTransactionToSignTx {
  /**
   * Sender account nonce of the transaction
   * @type {number}
   * @memberof BaseTransactionToSignTx
   */
  nonce?: number;
  /**
   * Gas price of the transaction
   * @type {string}
   * @memberof BaseTransactionToSignTx
   */
  gasPrice?: string;
  /**
   * Fee cap per gas of the transaction
   * @type {string}
   * @memberof BaseTransactionToSignTx
   */
  gasFeeCap?: string;
  /**
   * GasTipCap per gas of the transaction
   * @type {string}
   * @memberof BaseTransactionToSignTx
   */
  gasTipCap?: string;
  /**
   * Gas limit of the transaction
   * @type {number}
   * @memberof BaseTransactionToSignTx
   */
  gas: number;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof BaseTransactionToSignTx
   */
  from: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof BaseTransactionToSignTx
   */
  to?: string | null;
  /**
   * Ether amount of the transaction
   * @type {string}
   * @memberof BaseTransactionToSignTx
   */
  value: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof BaseTransactionToSignTx
   */
  data: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof BaseTransactionToSignTx
   */
  hash?: string;
  /**
   * Transaction type
   * @type {number}
   * @memberof BaseTransactionToSignTx
   */
  type: number;
}
/**
 * A user.
 * @export
 * @interface BaseUser
 */
export interface BaseUser {
  /**
   * The user\'s email address.
   * @type {string}
   * @memberof BaseUser
   */
  email: string;
  /**
   * The user\'s name.
   * @type {string}
   * @memberof BaseUser
   */
  name: string;
}
/**
 * A block in the Ethereum blockchain.
 * @export
 * @interface Block
 */
export interface Block {
  /**
   *
   * @type {string}
   * @memberof Block
   */
  blockchain: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  hash: string;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  difficulty: string;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  gasLimit: number;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  number: string;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  timestamp: number;
  /**
   *
   * @type {Array<Transaction>}
   * @memberof Block
   */
  transactions: Array<Transaction>;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  receiptsRoot: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  parentHash: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  sha3Uncles: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof Block
   */
  miner: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  stateRoot: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  transactionsRoot: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Block
   */
  logsBloom: string;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  gasUsed: number;
  /**
   * A hex string.
   * @type {string}
   * @memberof Block
   */
  nonce: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  mixHash: string;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  extraData: string;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  baseFeePerGas: string;
}
/**
 * CORS Origin
 * @export
 * @interface CORSOrigin
 */
export interface CORSOrigin {
  /**
   *
   * @type {number}
   * @memberof CORSOrigin
   */
  id?: number;
  /**
   * The CORS Origin
   * @type {string}
   * @memberof CORSOrigin
   */
  origin?: string;
}
/**
 *
 * @export
 * @interface CallContractFunction200Response
 */
export interface CallContractFunction200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CallContractFunction200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CallContractFunction200Response
   */
  message: string;
  /**
   *
   * @type {CallContractFunction200ResponseAllOfResult}
   * @memberof CallContractFunction200Response
   */
  result: CallContractFunction200ResponseAllOfResult;
}
/**
 *
 * @export
 * @interface CallContractFunction200ResponseAllOf
 */
export interface CallContractFunction200ResponseAllOf {
  /**
   *
   * @type {CallContractFunction200ResponseAllOfResult}
   * @memberof CallContractFunction200ResponseAllOf
   */
  result: CallContractFunction200ResponseAllOfResult;
}
/**
 * @type CallContractFunction200ResponseAllOfResult
 * @export
 */
export type CallContractFunction200ResponseAllOfResult =
  | ({ kind: 'MethodCallPreviewResponse' } & MethodCallPreviewResponse)
  | ({ kind: 'MethodCallResponse' } & MethodCallResponse)
  | ({ kind: 'TransactionToSignResponse' } & TransactionToSignResponse);

/**
 * A blockchain chain name.
 * @export
 * @enum {string}
 */

export const ChainName = {
  Ethereum: 'ethereum'
} as const;

export type ChainName = typeof ChainName[keyof typeof ChainName];

/**
 * The status of the Chain
 * @export
 * @interface ChainStatus
 */
export interface ChainStatus {
  /**
   *
   * @type {number}
   * @memberof ChainStatus
   */
  blockNumber: number;
  /**
   * The client version for this chain node.
   * @type {string}
   * @memberof ChainStatus
   */
  version: string;
  /**
   *
   * @type {number}
   * @memberof ChainStatus
   */
  chainID: number;
  /**
   *
   * @type {number}
   * @memberof ChainStatus
   */
  networkID: number;
  /**
   * The current base fee (only available for chains that support EIP-1559).
   * @type {string}
   * @memberof ChainStatus
   */
  baseFee?: string;
}
/**
 * A returned contract.
 * @export
 * @interface Contract
 */
export interface Contract {
  /**
   * A label.
   * @type {string}
   * @memberof Contract
   */
  label: string;
  /**
   * The name of the contract.
   * @type {string}
   * @memberof Contract
   */
  contractName: string;
  /**
   * The contract version.
   * @type {string}
   * @memberof Contract
   */
  version: string;
  /**
   * The smart-contract bytecode.
   * @type {string}
   * @memberof Contract
   */
  bin?: string;
  /**
   * The contract raw ABI JSON string.
   * @type {string}
   * @memberof Contract
   */
  rawAbi: string;
  /**
   * The user documentation JSON string.
   * @type {string}
   * @memberof Contract
   */
  userDoc: string;
  /**
   * The developer documentation JSON string.
   * @type {string}
   * @memberof Contract
   */
  developerDoc: string;
  /**
   * The contract metadata JSON string.
   * @type {string}
   * @memberof Contract
   */
  metadata?: string;
  /**
   *
   * @type {boolean}
   * @memberof Contract
   */
  isFavorite?: boolean;
  /**
   *
   * @type {ContractABI}
   * @memberof Contract
   */
  abi: ContractABI;
  /**
   * List of the contract instances.
   * @type {Array<ContractInstance>}
   * @memberof Contract
   */
  instances?: Array<ContractInstance>;
}
/**
 * The contract ABI.
 * @export
 * @interface ContractABI
 */
export interface ContractABI {
  /**
   *
   * @type {ContractABIMethod1}
   * @memberof ContractABI
   */
  constructor: ContractABIMethod1 | null;
  /**
   *
   * @type {{ [key: string]: ContractABIMethod; }}
   * @memberof ContractABI
   */
  methods: { [key: string]: ContractABIMethod };
  /**
   *
   * @type {{ [key: string]: ContractABIEvent; }}
   * @memberof ContractABI
   */
  events: { [key: string]: ContractABIEvent };
  /**
   *
   * @type {ContractABIMethod}
   * @memberof ContractABI
   */
  fallback: ContractABIMethod | null;
  /**
   *
   * @type {ContractABIMethod}
   * @memberof ContractABI
   */
  receive: ContractABIMethod | null;
}
/**
 * A contract event.
 * @export
 * @interface ContractABIEvent
 */
export interface ContractABIEvent {
  /**
   *
   * @type {string}
   * @memberof ContractABIEvent
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ContractABIEvent
   */
  signature: string;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIEvent
   */
  anonymous: boolean;
  /**
   * List of contract event\'s input arguments.
   * @type {Array<ContractABIEventArgument>}
   * @memberof ContractABIEvent
   */
  inputs: Array<ContractABIEventArgument>;
}
/**
 * A contract event argument.
 * @export
 * @interface ContractABIEventArgument
 */
export interface ContractABIEventArgument {
  /**
   *
   * @type {string}
   * @memberof ContractABIEventArgument
   */
  name: string;
  /**
   *
   * @type {ContractABIType}
   * @memberof ContractABIEventArgument
   */
  type: ContractABIType;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIEventArgument
   */
  indexed: boolean;
  /**
   *
   * @type {ContractABITypeConversion}
   * @memberof ContractABIEventArgument
   */
  typeConversion: ContractABITypeConversion | null;
}
/**
 * A contract function.
 * @export
 * @interface ContractABIMethod
 */
export interface ContractABIMethod {
  /**
   * Name of the function.
   * @type {string}
   * @memberof ContractABIMethod
   */
  name: string;
  /**
   * The function signature.
   * @type {string}
   * @memberof ContractABIMethod
   */
  signature: string;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIMethod
   */
  const: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIMethod
   */
  payable: boolean;
  /**
   * List of function arguments.
   * @type {Array<ContractABIMethodArgument>}
   * @memberof ContractABIMethod
   */
  inputs: Array<ContractABIMethodArgument>;
  /**
   * List of function outputs.
   * @type {Array<ContractABIMethodArgument>}
   * @memberof ContractABIMethod
   */
  outputs: Array<ContractABIMethodArgument>;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethod
   */
  author: string;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethod
   */
  notes: string;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethod
   */
  returns: string;
  /**
   * The function description.
   * @type {string}
   * @memberof ContractABIMethod
   */
  description: string;
}
/**
 * A contract function.
 * @export
 * @interface ContractABIMethod1
 */
export interface ContractABIMethod1 {
  /**
   * Name of the function.
   * @type {string}
   * @memberof ContractABIMethod1
   */
  name: string;
  /**
   * The function signature.
   * @type {string}
   * @memberof ContractABIMethod1
   */
  signature: string;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIMethod1
   */
  const: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIMethod1
   */
  payable: boolean;
  /**
   * List of function arguments.
   * @type {Array<ContractABIMethodArgument>}
   * @memberof ContractABIMethod1
   */
  inputs: Array<ContractABIMethodArgument>;
  /**
   * List of function outputs.
   * @type {Array<ContractABIMethodArgument>}
   * @memberof ContractABIMethod1
   */
  outputs: Array<ContractABIMethodArgument>;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethod1
   */
  author: string;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethod1
   */
  notes: string;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethod1
   */
  returns: string;
  /**
   * The function description.
   * @type {string}
   * @memberof ContractABIMethod1
   */
  description: string;
}
/**
 * A contract function argument.
 * @export
 * @interface ContractABIMethodArgument
 */
export interface ContractABIMethodArgument {
  /**
   *
   * @type {string}
   * @memberof ContractABIMethodArgument
   */
  name?: string;
  /**
   *
   * @type {ContractABIType}
   * @memberof ContractABIMethodArgument
   */
  type?: ContractABIType;
  /**
   *
   * @type {ContractABITypeConversion}
   * @memberof ContractABIMethodArgument
   */
  typeConversion: ContractABITypeConversion | null;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethodArgument
   */
  notes?: string;
}
/**
 * A contract function or event argument type.
 * @export
 * @interface ContractABIType
 */
export interface ContractABIType {
  /**
   *
   * @type {string}
   * @memberof ContractABIType
   */
  type: string;
  /**
   *
   * @type {number}
   * @memberof ContractABIType
   */
  size?: number;
  /**
   *
   * @type {Array<ContractABIType>}
   * @memberof ContractABIType
   */
  tupleElems?: Array<ContractABIType>;
  /**
   *
   * @type {Array<string>}
   * @memberof ContractABIType
   */
  tupleRawNames?: Array<string>;
  /**
   *
   * @type {ContractABIType}
   * @memberof ContractABIType
   */
  elem?: ContractABIType;
}
/**
 * Holds JSON-compatible type conversion information.
 * @export
 * @interface ContractABITypeConversion
 */
export interface ContractABITypeConversion {
  /**
   *
   * @type {string}
   * @memberof ContractABITypeConversion
   */
  mode: string;
  /**
   *
   * @type {number}
   * @memberof ContractABITypeConversion
   */
  decimalsAbsolute: number | null;
  /**
   *
   * @type {string}
   * @memberof ContractABITypeConversion
   */
  decimalsFunction: string | null;
}
/**
 *
 * @export
 * @interface ContractAllOf
 */
export interface ContractAllOf {
  /**
   *
   * @type {ContractABI}
   * @memberof ContractAllOf
   */
  abi: ContractABI;
  /**
   * List of the contract instances.
   * @type {Array<ContractInstance>}
   * @memberof ContractAllOf
   */
  instances?: Array<ContractInstance>;
}
/**
 * Type conversion options for an event.
 * @export
 * @interface ContractEventOptions
 */
export interface ContractEventOptions {
  /**
   *
   * @type {string}
   * @memberof ContractEventOptions
   */
  signature?: string;
  /**
   *
   * @type {Array<ContractParameter>}
   * @memberof ContractEventOptions
   */
  inputs: Array<ContractParameter>;
}
/**
 * The contract information within the event or transaction.
 * @export
 * @interface ContractInformation
 */
export interface ContractInformation {
  /**
   * An ethereum address.
   * @type {string}
   * @memberof ContractInformation
   */
  address: string;
  /**
   * A label.
   * @type {string}
   * @memberof ContractInformation
   */
  addressLabel: string;
  /**
   * The name of the contract.
   * @type {string}
   * @memberof ContractInformation
   */
  name: string;
  /**
   * A label.
   * @type {string}
   * @memberof ContractInformation
   */
  label: string;
}
/**
 * A contract instance
 * @export
 * @interface ContractInstance
 */
export interface ContractInstance {
  /**
   *
   * @type {string}
   * @memberof ContractInstance
   */
  label: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof ContractInstance
   */
  address: string;
}
/**
 *
 * @export
 * @interface ContractMetadata
 */
export interface ContractMetadata {
  /**
   * A label.
   * @type {string}
   * @memberof ContractMetadata
   */
  label: string;
  /**
   * The name of the contract.
   * @type {string}
   * @memberof ContractMetadata
   */
  name: string;
  /**
   * The contract version.
   * @type {string}
   * @memberof ContractMetadata
   */
  version: string;
  /**
   *
   * @type {boolean}
   * @memberof ContractMetadata
   */
  conflict: boolean;
}
/**
 * The contract method\'s information returned within the event or transaction.
 * @export
 * @interface ContractMethodInformation
 */
export interface ContractMethodInformation {
  /**
   * The name of the method.
   * @type {string}
   * @memberof ContractMethodInformation
   */
  name: string;
  /**
   * The method signature.
   * @type {string}
   * @memberof ContractMethodInformation
   */
  signature: string;
  /**
   *
   * @type {Array<MethodArg>}
   * @memberof ContractMethodInformation
   */
  inputs: Array<MethodArg>;
}
/**
 * Type conversion options for a function.
 * @export
 * @interface ContractMethodOptions
 */
export interface ContractMethodOptions {
  /**
   * The function signature.
   * @type {string}
   * @memberof ContractMethodOptions
   */
  signature?: string;
  /**
   * List of function input parameters.
   * @type {Array<ContractParameter>}
   * @memberof ContractMethodOptions
   */
  inputs: Array<ContractParameter>;
  /**
   * List of function output parameters.
   * @type {Array<ContractParameter>}
   * @memberof ContractMethodOptions
   */
  outputs?: Array<ContractParameter>;
}
/**
 * A contract overview.
 * @export
 * @interface ContractOverview
 */
export interface ContractOverview {
  /**
   * A label.
   * @type {string}
   * @memberof ContractOverview
   */
  label: string;
  /**
   * The name of the contract.
   * @type {string}
   * @memberof ContractOverview
   */
  contractName: string;
  /**
   * The contract version.
   * @type {string}
   * @memberof ContractOverview
   */
  version: string;
  /**
   *
   * @type {boolean}
   * @memberof ContractOverview
   */
  isFavorite?: boolean;
  /**
   * List of contract instances.
   * @type {Array<ContractInstance>}
   * @memberof ContractOverview
   */
  instances: Array<ContractInstance>;
}
/**
 * Type conversion options for an input or an output of a function or an event.
 * @export
 * @interface ContractParameter
 */
export interface ContractParameter {
  /**
   *
   * @type {ContractABITypeConversion}
   * @memberof ContractParameter
   */
  typeConversion: ContractABITypeConversion | null;
}
/**
 *
 * @export
 * @interface CountEventQueryRecords200Response
 */
export interface CountEventQueryRecords200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CountEventQueryRecords200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CountEventQueryRecords200Response
   */
  message: string;
  /**
   * The record count.
   * @type {number}
   * @memberof CountEventQueryRecords200Response
   */
  result: number;
}
/**
 *
 * @export
 * @interface CountEventQueryRecords200ResponseAllOf
 */
export interface CountEventQueryRecords200ResponseAllOf {
  /**
   * The record count.
   * @type {number}
   * @memberof CountEventQueryRecords200ResponseAllOf
   */
  result: number;
}
/**
 *
 * @export
 * @interface CountWalletTransactions200Response
 */
export interface CountWalletTransactions200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CountWalletTransactions200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CountWalletTransactions200Response
   */
  message: string;
  /**
   * The transaction count.
   * @type {number}
   * @memberof CountWalletTransactions200Response
   */
  result: number;
}
/**
 *
 * @export
 * @interface CountWalletTransactions200ResponseAllOf
 */
export interface CountWalletTransactions200ResponseAllOf {
  /**
   * The transaction count.
   * @type {number}
   * @memberof CountWalletTransactions200ResponseAllOf
   */
  result: number;
}
/**
 *
 * @export
 * @interface CreateApiKey200Response
 */
export interface CreateApiKey200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CreateApiKey200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CreateApiKey200Response
   */
  message: string;
  /**
   *
   * @type {APIKey}
   * @memberof CreateApiKey200Response
   */
  result: APIKey;
}
/**
 *
 * @export
 * @interface CreateApiKey200ResponseAllOf
 */
export interface CreateApiKey200ResponseAllOf {
  /**
   *
   * @type {APIKey}
   * @memberof CreateApiKey200ResponseAllOf
   */
  result: APIKey;
}
/**
 *
 * @export
 * @interface CreateApiKeyRequest
 */
export interface CreateApiKeyRequest {
  /**
   * A label.
   * @type {string}
   * @memberof CreateApiKeyRequest
   */
  label: string;
  /**
   *
   * @type {Array<number>}
   * @memberof CreateApiKeyRequest
   */
  groupIDs?: Array<number>;
}
/**
 *
 * @export
 * @interface CreateApiKeyRequestAllOf
 */
export interface CreateApiKeyRequestAllOf {
  /**
   *
   * @type {Array<number>}
   * @memberof CreateApiKeyRequestAllOf
   */
  groupIDs?: Array<number>;
}
/**
 *
 * @export
 * @interface CreateHsmKey200Response
 */
export interface CreateHsmKey200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CreateHsmKey200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CreateHsmKey200Response
   */
  message: string;
  /**
   *
   * @type {AzureWallet}
   * @memberof CreateHsmKey200Response
   */
  result: AzureWallet;
}
/**
 *
 * @export
 * @interface CreateHsmKey200ResponseAllOf
 */
export interface CreateHsmKey200ResponseAllOf {
  /**
   *
   * @type {AzureWallet}
   * @memberof CreateHsmKey200ResponseAllOf
   */
  result: AzureWallet;
}
/**
 * Create Key request data.
 * @export
 * @interface CreateKey
 */
export interface CreateKey {
  /**
   * The Application ID that will be accessing the Key Vault.
   * @type {string}
   * @memberof CreateKey
   */
  clientID: string;
  /**
   * The name of the key.
   * @type {string}
   * @memberof CreateKey
   */
  keyName: string;
  /**
   * The name given to the vault your key is stored in.
   * @type {string}
   * @memberof CreateKey
   */
  vaultName: string;
  /**
   *
   * @type {boolean}
   * @memberof CreateKey
   */
  useHardwareModule: boolean;
}
/**
 *
 * @export
 * @interface DeployContract200Response
 */
export interface DeployContract200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof DeployContract200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof DeployContract200Response
   */
  message: string;
  /**
   *
   * @type {DeployContractTransaction}
   * @memberof DeployContract200Response
   */
  result: DeployContractTransaction;
}
/**
 *
 * @export
 * @interface DeployContract200ResponseAllOf
 */
export interface DeployContract200ResponseAllOf {
  /**
   *
   * @type {DeployContractTransaction}
   * @memberof DeployContract200ResponseAllOf
   */
  result: DeployContractTransaction;
}
/**
 * The transaction returned when you deploy a contracts.
 * @export
 * @interface DeployContractTransaction
 */
export interface DeployContractTransaction {
  /**
   *
   * @type {BaseTransactionToSignTx}
   * @memberof DeployContractTransaction
   */
  tx: BaseTransactionToSignTx;
  /**
   *
   * @type {boolean}
   * @memberof DeployContractTransaction
   */
  submitted: boolean;
  /**
   *
   * @type {string}
   * @memberof DeployContractTransaction
   */
  deployAt?: string;
  /**
   * A label.
   * @type {string}
   * @memberof DeployContractTransaction
   */
  label?: string;
}
/**
 *
 * @export
 * @interface DeployContractTransactionAllOf
 */
export interface DeployContractTransactionAllOf {
  /**
   *
   * @type {string}
   * @memberof DeployContractTransactionAllOf
   */
  deployAt?: string;
  /**
   * A label.
   * @type {string}
   * @memberof DeployContractTransactionAllOf
   */
  label?: string;
}
/**
 * An event returned by the API call.
 * @export
 * @interface Event
 */
export interface Event {
  /**
   * The time at which the event was triggered.
   * @type {string}
   * @memberof Event
   */
  triggeredAt: string;
  /**
   *
   * @type {EventInformation}
   * @memberof Event
   */
  event: EventInformation;
  /**
   *
   * @type {TransactionInformation}
   * @memberof Event
   */
  transaction: TransactionInformation;
}
/**
 * Holds a field in the event\'s data.
 * @export
 * @interface EventField
 */
export interface EventField {
  /**
   * The input name.
   * @type {string}
   * @memberof EventField
   */
  name: string;
  /**
   * The input value.
   * @type {any}
   * @memberof EventField
   */
  value: any;
  /**
   * Has the value been hashed into a keccak256 string?
   * @type {boolean}
   * @memberof EventField
   */
  hashed: boolean;
  /**
   * The type of the argument.
   * @type {string}
   * @memberof EventField
   */
  type: string;
}
/**
 * The event information returned as part of an event.
 * @export
 * @interface EventInformation
 */
export interface EventInformation {
  /**
   * The name of the event.
   * @type {string}
   * @memberof EventInformation
   */
  name: string;
  /**
   * The event signature.
   * @type {string}
   * @memberof EventInformation
   */
  signature: string;
  /**
   * The list of input arguments for the event.
   * @type {Array<EventField>}
   * @memberof EventInformation
   */
  inputs: Array<EventField>;
  /**
   * The raw output from an event. Omitted when returned as part of a transaction receipt.
   * @type {string}
   * @memberof EventInformation
   */
  rawFields?: string;
  /**
   *
   * @type {ContractInformation}
   * @memberof EventInformation
   */
  contract: ContractInformation;
  /**
   * The event\'s index in the log.
   * @type {number}
   * @memberof EventInformation
   */
  indexInLog: number;
}
/**
 * Status of an Event Monitor
 * @export
 * @interface EventMonitorStatus
 */
export interface EventMonitorStatus {
  /**
   *
   * @type {number}
   * @memberof EventMonitorStatus
   */
  contractId?: number;
  /**
   *
   * @type {number}
   * @memberof EventMonitorStatus
   */
  addressId?: number;
  /**
   *
   * @type {boolean}
   * @memberof EventMonitorStatus
   */
  isProcessingPastLogs: boolean;
  /**
   *
   * @type {number}
   * @memberof EventMonitorStatus
   */
  idealBlockRange?: number;
  /**
   *
   * @type {number}
   * @memberof EventMonitorStatus
   */
  latestBlockNumber: number;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof EventMonitorStatus
   */
  latestBlockHash: string;
  /**
   *
   * @type {number}
   * @memberof EventMonitorStatus
   */
  startBlockNumber: number;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof EventMonitorStatus
   */
  startBlockHash: string;
  /**
   *
   * @type {string}
   * @memberof EventMonitorStatus
   */
  updatedAt: string;
}
/**
 * An event query.
 * @export
 * @interface EventQuery
 */
export interface EventQuery {
  /**
   *
   * @type {Array<EventQueryEvent>}
   * @memberof EventQuery
   */
  events: Array<EventQueryEvent>;
  /**
   * The results will be grouped according to this field. An aggregator for non Group By fields must be specified if groupBy is specified.
   * @type {string}
   * @memberof EventQuery
   */
  groupBy?: string;
  /**
   * The results will be ordered according to this field.
   * @type {string}
   * @memberof EventQuery
   */
  orderBy?: string;
  /**
   * Specify ascending or descending order, the default is \"ASC\".
   * @type {string}
   * @memberof EventQuery
   */
  order?: EventQueryOrderEnum;
}

export const EventQueryOrderEnum = {
  Asc: 'ASC',
  Desc: 'DESC'
} as const;

export type EventQueryOrderEnum = typeof EventQueryOrderEnum[keyof typeof EventQueryOrderEnum];

/**
 * A query on a single event.
 * @export
 * @interface EventQueryEvent
 */
export interface EventQueryEvent {
  /**
   * The name of an event.
   * @type {string}
   * @memberof EventQueryEvent
   */
  eventName: string;
  /**
   * The query information about all the fields to select from an event.
   * @type {Array<EventQueryField>}
   * @memberof EventQueryEvent
   */
  select: Array<EventQueryField>;
  /**
   *
   * @type {EventQueryFilter}
   * @memberof EventQueryEvent
   */
  filter?: EventQueryFilter;
}
/**
 * A single event field\'s query information.
 * @export
 * @interface EventQueryField
 */
export interface EventQueryField {
  /**
   *
   * @type {FieldType}
   * @memberof EventQueryField
   */
  type: FieldType;
  /**
   * The field name. Either `name` or `inputIndex` is required if `fieldType == \"input\"`.
   * @type {string}
   * @memberof EventQueryField
   */
  name?: string;
  /**
   * The field\'s index, can be used in place of `name`.
   * @type {number}
   * @memberof EventQueryField
   */
  inputIndex?: number | null;
  /**
   * The name that will be used to return the field.
   * @type {string}
   * @memberof EventQueryField
   */
  alias?: string;
  /**
   * The type of aggregation to perform on the field.
   * @type {string}
   * @memberof EventQueryField
   */
  aggregator?: EventQueryFieldAggregatorEnum;
}

export const EventQueryFieldAggregatorEnum = {
  Add: 'add',
  Subtract: 'subtract',
  Last: 'last',
  First: 'first',
  Min: 'min',
  Max: 'max',
  Null: 'null'
} as const;

export type EventQueryFieldAggregatorEnum =
  typeof EventQueryFieldAggregatorEnum[keyof typeof EventQueryFieldAggregatorEnum];

/**
 * A event query filter.
 * @export
 * @interface EventQueryFilter
 */
export interface EventQueryFilter {
  /**
   * The rule type, can be omitted if this is the last filter to be applied.
   * @type {string}
   * @memberof EventQueryFilter
   */
  rule?: EventQueryFilterRuleEnum;
  /**
   *
   * @type {FieldType}
   * @memberof EventQueryFilter
   */
  fieldType?: FieldType;
  /**
   * The field\'s index, can be used in place of `name`.
   * @type {number}
   * @memberof EventQueryFilter
   */
  inputIndex?: number | null;
  /**
   * The operator on the filter.
   * @type {string}
   * @memberof EventQueryFilter
   */
  operator?: EventQueryFilterOperatorEnum;
  /**
   * The value to be compared with.
   * @type {string}
   * @memberof EventQueryFilter
   */
  value?: string;
  /**
   * Other filters to be applied in succession with the rule specified.
   * @type {Array<EventQueryFilter>}
   * @memberof EventQueryFilter
   */
  children?: Array<EventQueryFilter>;
}

export const EventQueryFilterRuleEnum = {
  And: 'and',
  Or: 'or'
} as const;

export type EventQueryFilterRuleEnum = typeof EventQueryFilterRuleEnum[keyof typeof EventQueryFilterRuleEnum];
export const EventQueryFilterOperatorEnum = {
  Equal: 'equal',
  Notequal: 'notequal',
  Lessthan: 'lessthan',
  Greaterthan: 'greaterthan',
  Lessthanorequal: 'lessthanorequal',
  Greaterthanorequal: 'greaterthanorequal'
} as const;

export type EventQueryFilterOperatorEnum =
  typeof EventQueryFilterOperatorEnum[keyof typeof EventQueryFilterOperatorEnum];

/**
 * Results of an executed event query.
 * @export
 * @interface EventQueryResults
 */
export interface EventQueryResults {
  /**
   *
   * @type {Array<{ [key: string]: any; }>}
   * @memberof EventQueryResults
   */
  rows: Array<{ [key: string]: any }>;
}
/**
 * Type conversion options for each of the inputs of an event.
 * @export
 * @interface EventTypeConversionOptions
 */
export interface EventTypeConversionOptions {
  /**
   * List of event\'s input parameters.
   * @type {Array<TypeConversionOptions>}
   * @memberof EventTypeConversionOptions
   */
  inputs: Array<TypeConversionOptions>;
}
/**
 *
 * @export
 * @interface ExecuteArbitraryEventQuery200Response
 */
export interface ExecuteArbitraryEventQuery200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ExecuteArbitraryEventQuery200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ExecuteArbitraryEventQuery200Response
   */
  message: string;
  /**
   *
   * @type {EventQueryResults}
   * @memberof ExecuteArbitraryEventQuery200Response
   */
  result: EventQueryResults;
}
/**
 *
 * @export
 * @interface ExecuteArbitraryEventQuery200ResponseAllOf
 */
export interface ExecuteArbitraryEventQuery200ResponseAllOf {
  /**
   *
   * @type {EventQueryResults}
   * @memberof ExecuteArbitraryEventQuery200ResponseAllOf
   */
  result: EventQueryResults;
}
/**
 * The field type in a select or filter.
 * @export
 * @enum {string}
 */

export const FieldType = {
  Input: 'input',
  ContractLabel: 'contract_label',
  ContractName: 'contract_name',
  ContractAddress: 'contract_address',
  ContractAddressLabel: 'contract_address_label',
  BlockNumber: 'block_number',
  TriggeredAt: 'triggered_at',
  EventSignature: 'event_signature',
  BlockHash: 'block_hash',
  TxHash: 'tx_hash',
  TxFrom: 'tx_from'
} as const;

export type FieldType = typeof FieldType[keyof typeof FieldType];

/**
 * Specify custom gas parameters
 * @export
 * @interface GasParams
 */
export interface GasParams {
  /**
   * Gas price to use for the cancel/resubmit.
   * @type {string}
   * @memberof GasParams
   */
  gasPrice?: string;
  /**
   * Gas fee cap to use for the EIP-1559 cancel/resubmit.
   * @type {string}
   * @memberof GasParams
   */
  gasFeeCap?: string;
  /**
   * Gas priority fee cap to use for the EIP-1559 cancel/resubmit.
   * @type {string}
   * @memberof GasParams
   */
  gasTipCap?: string;
  /**
   * Gas limit to set for the cancel/resubmit.
   * @type {number}
   * @memberof GasParams
   */
  gas?: number;
}
/**
 *
 * @export
 * @interface GetAllEvents200Response
 */
export interface GetAllEvents200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetAllEvents200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetAllEvents200Response
   */
  message: string;
  /**
   *
   * @type {Array<Event>}
   * @memberof GetAllEvents200Response
   */
  result: Array<Event>;
}
/**
 *
 * @export
 * @interface GetAllEvents200ResponseAllOf
 */
export interface GetAllEvents200ResponseAllOf {
  /**
   *
   * @type {Array<Event>}
   * @memberof GetAllEvents200ResponseAllOf
   */
  result: Array<Event>;
}
/**
 *
 * @export
 * @interface GetBlock200Response
 */
export interface GetBlock200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetBlock200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetBlock200Response
   */
  message: string;
  /**
   *
   * @type {Block}
   * @memberof GetBlock200Response
   */
  result: Block;
}
/**
 *
 * @export
 * @interface GetBlock200ResponseAllOf
 */
export interface GetBlock200ResponseAllOf {
  /**
   *
   * @type {Block}
   * @memberof GetBlock200ResponseAllOf
   */
  result: Block;
}
/**
 *
 * @export
 * @interface GetChainStatus200Response
 */
export interface GetChainStatus200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetChainStatus200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetChainStatus200Response
   */
  message: string;
  /**
   *
   * @type {ChainStatus}
   * @memberof GetChainStatus200Response
   */
  result: ChainStatus;
}
/**
 *
 * @export
 * @interface GetChainStatus200ResponseAllOf
 */
export interface GetChainStatus200ResponseAllOf {
  /**
   *
   * @type {ChainStatus}
   * @memberof GetChainStatus200ResponseAllOf
   */
  result: ChainStatus;
}
/**
 *
 * @export
 * @interface GetContract200Response
 */
export interface GetContract200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetContract200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetContract200Response
   */
  message: string;
  /**
   *
   * @type {Contract}
   * @memberof GetContract200Response
   */
  result: Contract;
}
/**
 *
 * @export
 * @interface GetContract200ResponseAllOf
 */
export interface GetContract200ResponseAllOf {
  /**
   *
   * @type {Contract}
   * @memberof GetContract200ResponseAllOf
   */
  result: Contract;
}
/**
 *
 * @export
 * @interface GetContractVersions200Response
 */
export interface GetContractVersions200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetContractVersions200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetContractVersions200Response
   */
  message: string;
  /**
   *
   * @type {Array<Contract>}
   * @memberof GetContractVersions200Response
   */
  result: Array<Contract>;
}
/**
 *
 * @export
 * @interface GetContractVersions200ResponseAllOf
 */
export interface GetContractVersions200ResponseAllOf {
  /**
   *
   * @type {Array<Contract>}
   * @memberof GetContractVersions200ResponseAllOf
   */
  result: Array<Contract>;
}
/**
 *
 * @export
 * @interface GetEventCount200Response
 */
export interface GetEventCount200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetEventCount200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetEventCount200Response
   */
  message: string;
  /**
   * The number of events.
   * @type {number}
   * @memberof GetEventCount200Response
   */
  result: number;
}
/**
 *
 * @export
 * @interface GetEventCount200ResponseAllOf
 */
export interface GetEventCount200ResponseAllOf {
  /**
   * The number of events.
   * @type {number}
   * @memberof GetEventCount200ResponseAllOf
   */
  result: number;
}
/**
 *
 * @export
 * @interface GetEventMonitorStatus200Response
 */
export interface GetEventMonitorStatus200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetEventMonitorStatus200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetEventMonitorStatus200Response
   */
  message: string;
  /**
   *
   * @type {EventMonitorStatus}
   * @memberof GetEventMonitorStatus200Response
   */
  result: EventMonitorStatus;
}
/**
 *
 * @export
 * @interface GetEventMonitorStatus200ResponseAllOf
 */
export interface GetEventMonitorStatus200ResponseAllOf {
  /**
   *
   * @type {EventMonitorStatus}
   * @memberof GetEventMonitorStatus200ResponseAllOf
   */
  result: EventMonitorStatus;
}
/**
 *
 * @export
 * @interface GetEventQuery200Response
 */
export interface GetEventQuery200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetEventQuery200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetEventQuery200Response
   */
  message: string;
  /**
   *
   * @type {EventQuery}
   * @memberof GetEventQuery200Response
   */
  result: EventQuery;
}
/**
 *
 * @export
 * @interface GetEventQuery200ResponseAllOf
 */
export interface GetEventQuery200ResponseAllOf {
  /**
   *
   * @type {EventQuery}
   * @memberof GetEventQuery200ResponseAllOf
   */
  result: EventQuery;
}
/**
 *
 * @export
 * @interface GetEventTypeConversions200Response
 */
export interface GetEventTypeConversions200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetEventTypeConversions200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetEventTypeConversions200Response
   */
  message: string;
  /**
   *
   * @type {EventTypeConversionOptions}
   * @memberof GetEventTypeConversions200Response
   */
  result: EventTypeConversionOptions;
}
/**
 *
 * @export
 * @interface GetEventTypeConversions200ResponseAllOf
 */
export interface GetEventTypeConversions200ResponseAllOf {
  /**
   *
   * @type {EventTypeConversionOptions}
   * @memberof GetEventTypeConversions200ResponseAllOf
   */
  result: EventTypeConversionOptions;
}
/**
 *
 * @export
 * @interface GetFunctionTypeConversions200Response
 */
export interface GetFunctionTypeConversions200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetFunctionTypeConversions200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetFunctionTypeConversions200Response
   */
  message: string;
  /**
   *
   * @type {MethodTypeConversionOptions}
   * @memberof GetFunctionTypeConversions200Response
   */
  result: MethodTypeConversionOptions;
}
/**
 *
 * @export
 * @interface GetFunctionTypeConversions200ResponseAllOf
 */
export interface GetFunctionTypeConversions200ResponseAllOf {
  /**
   *
   * @type {MethodTypeConversionOptions}
   * @memberof GetFunctionTypeConversions200ResponseAllOf
   */
  result: MethodTypeConversionOptions;
}
/**
 *
 * @export
 * @interface GetTransaction200Response
 */
export interface GetTransaction200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetTransaction200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetTransaction200Response
   */
  message: string;
  /**
   *
   * @type {TransactionData}
   * @memberof GetTransaction200Response
   */
  result: TransactionData;
}
/**
 *
 * @export
 * @interface GetTransaction200ResponseAllOf
 */
export interface GetTransaction200ResponseAllOf {
  /**
   *
   * @type {TransactionData}
   * @memberof GetTransaction200ResponseAllOf
   */
  result: TransactionData;
}
/**
 *
 * @export
 * @interface GetTransactionReceipt200Response
 */
export interface GetTransactionReceipt200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetTransactionReceipt200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetTransactionReceipt200Response
   */
  message: string;
  /**
   *
   * @type {TransactionReceipt}
   * @memberof GetTransactionReceipt200Response
   */
  result: TransactionReceipt;
}
/**
 *
 * @export
 * @interface GetTransactionReceipt200ResponseAllOf
 */
export interface GetTransactionReceipt200ResponseAllOf {
  /**
   *
   * @type {TransactionReceipt}
   * @memberof GetTransactionReceipt200ResponseAllOf
   */
  result: TransactionReceipt;
}
/**
 * A group.
 * @export
 * @interface Group
 */
export interface Group {
  /**
   * The group ID.
   * @type {number}
   * @memberof Group
   */
  id: number;
  /**
   * The group name.
   * @type {string}
   * @memberof Group
   */
  name: string;
  /**
   * The group short name.
   * @type {string}
   * @memberof Group
   */
  shortName: string;
  /**
   * The group description.
   * @type {string}
   * @memberof Group
   */
  description: string;
  /**
   * The group roles.
   * @type {Array<Role>}
   * @memberof Group
   */
  roles: Array<Role>;
}
/**
 * Response body for returning HSM Data.
 * @export
 * @interface HSMData
 */
export interface HSMData {
  /**
   *
   * @type {AzureAccount}
   * @memberof HSMData
   */
  configuration: AzureAccount;
  /**
   * An array of Azure Hardware Wallets.
   * @type {Array<AzureHardwareWallet>}
   * @memberof HSMData
   */
  wallets: Array<AzureHardwareWallet>;
}
/**
 * Request body representing a sign-data request.
 * @export
 * @interface HSMSignRequest
 */
export interface HSMSignRequest {
  /**
   * An ethereum address.
   * @type {string}
   * @memberof HSMSignRequest
   */
  address: string;
  /**
   * Is the data field an encapsulated EIP-712 typed message?
   * @type {boolean}
   * @memberof HSMSignRequest
   */
  isTyped?: boolean;
  /**
   * Data to sign
   * @type {string}
   * @memberof HSMSignRequest
   */
  data: string;
  /**
   *
   * @type {HSMSignRequestChainId}
   * @memberof HSMSignRequest
   */
  chainId?: HSMSignRequestChainId;
}
/**
 * @type HSMSignRequestChainId
 * @export
 */
export type HSMSignRequestChainId = number | string;

/**
 * Response body representing a sign-data response.
 * @export
 * @interface HSMSignResponse
 */
export interface HSMSignResponse {
  /**
   *
   * @type {string}
   * @memberof HSMSignResponse
   */
  publicKey: string;
  /**
   *
   * @type {string}
   * @memberof HSMSignResponse
   */
  signature: string;
}
/**
 *
 * @export
 * @interface LinkAddressContractRequest
 */
export interface LinkAddressContractRequest {
  /**
   * A label.
   * @type {string}
   * @memberof LinkAddressContractRequest
   */
  label: string;
  /**
   * The contract version.
   * @type {string}
   * @memberof LinkAddressContractRequest
   */
  version?: string;
  /**
   * The block number from which to start syncing events. The value can be `latest` for the latest block number, an absolute block number (e.g. `123` for the block number 123), or a relative block number (e.g. `-100` for 100 blocks before the latest block). If absent, the event monitor will be disabled for this contract and events won\'t be synced.
   * @type {string}
   * @memberof LinkAddressContractRequest
   */
  startingBlock?: string;
}
/**
 *
 * @export
 * @interface ListAddresses200Response
 */
export interface ListAddresses200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListAddresses200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListAddresses200Response
   */
  message: string;
  /**
   *
   * @type {Array<AddressLabel>}
   * @memberof ListAddresses200Response
   */
  result: Array<AddressLabel>;
}
/**
 *
 * @export
 * @interface ListAddresses200ResponseAllOf
 */
export interface ListAddresses200ResponseAllOf {
  /**
   *
   * @type {Array<AddressLabel>}
   * @memberof ListAddresses200ResponseAllOf
   */
  result: Array<AddressLabel>;
}
/**
 *
 * @export
 * @interface ListApiKeys200Response
 */
export interface ListApiKeys200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListApiKeys200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListApiKeys200Response
   */
  message: string;
  /**
   *
   * @type {Array<APIKey>}
   * @memberof ListApiKeys200Response
   */
  result: Array<APIKey>;
}
/**
 *
 * @export
 * @interface ListApiKeys200ResponseAllOf
 */
export interface ListApiKeys200ResponseAllOf {
  /**
   *
   * @type {Array<APIKey>}
   * @memberof ListApiKeys200ResponseAllOf
   */
  result: Array<APIKey>;
}
/**
 *
 * @export
 * @interface ListAuditLogs200Response
 */
export interface ListAuditLogs200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListAuditLogs200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListAuditLogs200Response
   */
  message: string;
  /**
   *
   * @type {Array<AuditLog>}
   * @memberof ListAuditLogs200Response
   */
  result: Array<AuditLog>;
}
/**
 *
 * @export
 * @interface ListAuditLogs200ResponseAllOf
 */
export interface ListAuditLogs200ResponseAllOf {
  /**
   *
   * @type {Array<AuditLog>}
   * @memberof ListAuditLogs200ResponseAllOf
   */
  result: Array<AuditLog>;
}
/**
 *
 * @export
 * @interface ListContractVersions200Response
 */
export interface ListContractVersions200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListContractVersions200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListContractVersions200Response
   */
  message: string;
  /**
   *
   * @type {ListContractVersions200ResponseAllOfResult}
   * @memberof ListContractVersions200Response
   */
  result: ListContractVersions200ResponseAllOfResult;
}
/**
 *
 * @export
 * @interface ListContractVersions200ResponseAllOf
 */
export interface ListContractVersions200ResponseAllOf {
  /**
   *
   * @type {ListContractVersions200ResponseAllOfResult}
   * @memberof ListContractVersions200ResponseAllOf
   */
  result: ListContractVersions200ResponseAllOfResult;
}
/**
 *
 * @export
 * @interface ListContractVersions200ResponseAllOfResult
 */
export interface ListContractVersions200ResponseAllOfResult {
  /**
   * A label.
   * @type {string}
   * @memberof ListContractVersions200ResponseAllOfResult
   */
  label: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ListContractVersions200ResponseAllOfResult
   */
  versions: Array<string>;
}
/**
 *
 * @export
 * @interface ListContracts200Response
 */
export interface ListContracts200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListContracts200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListContracts200Response
   */
  message: string;
  /**
   *
   * @type {Array<ContractOverview>}
   * @memberof ListContracts200Response
   */
  result: Array<ContractOverview>;
}
/**
 *
 * @export
 * @interface ListContracts200ResponseAllOf
 */
export interface ListContracts200ResponseAllOf {
  /**
   *
   * @type {Array<ContractOverview>}
   * @memberof ListContracts200ResponseAllOf
   */
  result: Array<ContractOverview>;
}
/**
 *
 * @export
 * @interface ListCorsOrigins200Response
 */
export interface ListCorsOrigins200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListCorsOrigins200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListCorsOrigins200Response
   */
  message: string;
  /**
   *
   * @type {Array<CORSOrigin>}
   * @memberof ListCorsOrigins200Response
   */
  result: Array<CORSOrigin>;
}
/**
 *
 * @export
 * @interface ListCorsOrigins200ResponseAllOf
 */
export interface ListCorsOrigins200ResponseAllOf {
  /**
   *
   * @type {Array<CORSOrigin>}
   * @memberof ListCorsOrigins200ResponseAllOf
   */
  result: Array<CORSOrigin>;
}
/**
 *
 * @export
 * @interface ListEventQueries200Response
 */
export interface ListEventQueries200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListEventQueries200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListEventQueries200Response
   */
  message: string;
  /**
   *
   * @type {Array<SavedEventQuery>}
   * @memberof ListEventQueries200Response
   */
  result: Array<SavedEventQuery>;
}
/**
 *
 * @export
 * @interface ListEventQueries200ResponseAllOf
 */
export interface ListEventQueries200ResponseAllOf {
  /**
   *
   * @type {Array<SavedEventQuery>}
   * @memberof ListEventQueries200ResponseAllOf
   */
  result: Array<SavedEventQuery>;
}
/**
 *
 * @export
 * @interface ListGroups200Response
 */
export interface ListGroups200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListGroups200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListGroups200Response
   */
  message: string;
  /**
   *
   * @type {Array<Group>}
   * @memberof ListGroups200Response
   */
  result: Array<Group>;
}
/**
 *
 * @export
 * @interface ListGroups200ResponseAllOf
 */
export interface ListGroups200ResponseAllOf {
  /**
   *
   * @type {Array<Group>}
   * @memberof ListGroups200ResponseAllOf
   */
  result: Array<Group>;
}
/**
 *
 * @export
 * @interface ListHsm200Response
 */
export interface ListHsm200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListHsm200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListHsm200Response
   */
  message: string;
  /**
   *
   * @type {Array<HSMData>}
   * @memberof ListHsm200Response
   */
  result: Array<HSMData>;
}
/**
 *
 * @export
 * @interface ListHsm200ResponseAllOf
 */
export interface ListHsm200ResponseAllOf {
  /**
   *
   * @type {Array<HSMData>}
   * @memberof ListHsm200ResponseAllOf
   */
  result: Array<HSMData>;
}
/**
 *
 * @export
 * @interface ListHsmWallets200Response
 */
export interface ListHsmWallets200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListHsmWallets200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListHsmWallets200Response
   */
  message: string;
  /**
   *
   * @type {Array<StandaloneWallet>}
   * @memberof ListHsmWallets200Response
   */
  result: Array<StandaloneWallet>;
}
/**
 *
 * @export
 * @interface ListHsmWallets200ResponseAllOf
 */
export interface ListHsmWallets200ResponseAllOf {
  /**
   *
   * @type {Array<StandaloneWallet>}
   * @memberof ListHsmWallets200ResponseAllOf
   */
  result: Array<StandaloneWallet>;
}
/**
 *
 * @export
 * @interface ListUsers200Response
 */
export interface ListUsers200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListUsers200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListUsers200Response
   */
  message: string;
  /**
   *
   * @type {Array<User>}
   * @memberof ListUsers200Response
   */
  result: Array<User>;
}
/**
 *
 * @export
 * @interface ListUsers200ResponseAllOf
 */
export interface ListUsers200ResponseAllOf {
  /**
   *
   * @type {Array<User>}
   * @memberof ListUsers200ResponseAllOf
   */
  result: Array<User>;
}
/**
 *
 * @export
 * @interface ListWalletTransactions200Response
 */
export interface ListWalletTransactions200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListWalletTransactions200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListWalletTransactions200Response
   */
  message: string;
  /**
   *
   * @type {Array<WalletTransaction>}
   * @memberof ListWalletTransactions200Response
   */
  result: Array<WalletTransaction>;
}
/**
 *
 * @export
 * @interface ListWalletTransactions200ResponseAllOf
 */
export interface ListWalletTransactions200ResponseAllOf {
  /**
   *
   * @type {Array<WalletTransaction>}
   * @memberof ListWalletTransactions200ResponseAllOf
   */
  result: Array<WalletTransaction>;
}
/**
 * A contract log event.
 * @export
 * @interface Log
 */
export interface Log {
  /**
   * An ethereum address.
   * @type {string}
   * @memberof Log
   */
  address: string;
  /**
   * A list of topics provided by the contract.
   * @type {Array<string>}
   * @memberof Log
   */
  topics: Array<string>;
  /**
   * A hex string.
   * @type {string}
   * @memberof Log
   */
  data: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Log
   */
  blockNumber: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Log
   */
  transactionHash: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Log
   */
  transactionIndex: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Log
   */
  blockHash: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Log
   */
  logIndex: string;
  /**
   * True if this log was reverted due to a chain reorganization.
   * @type {boolean}
   * @memberof Log
   */
  removed: boolean;
}
/**
 * An argument passed to a method call.
 * @export
 * @interface MethodArg
 */
export interface MethodArg {
  /**
   * The input name.
   * @type {string}
   * @memberof MethodArg
   */
  name: string;
  /**
   * The input value.
   * @type {any}
   * @memberof MethodArg
   */
  value: any;
  /**
   * The type of the argument.
   * @type {string}
   * @memberof MethodArg
   */
  type: string;
}
/**
 * The result of a preview function arguments call.
 * @export
 * @interface MethodCallPreviewResponse
 */
export interface MethodCallPreviewResponse extends PostMethodResponse {
  /**
   * The function call inputs.
   * @type {Array<any>}
   * @memberof MethodCallPreviewResponse
   */
  input: Array<any>;
  /**
   * The function call output.
   * @type {any}
   * @memberof MethodCallPreviewResponse
   */
  output: any;
}
/**
 *
 * @export
 * @interface MethodCallPreviewResponseAllOf
 */
export interface MethodCallPreviewResponseAllOf {
  /**
   * The function call inputs.
   * @type {Array<any>}
   * @memberof MethodCallPreviewResponseAllOf
   */
  input: Array<any>;
  /**
   * The function call output.
   * @type {any}
   * @memberof MethodCallPreviewResponseAllOf
   */
  output: any;
}
/**
 * The result of a function call.
 * @export
 * @interface MethodCallResponse
 */
export interface MethodCallResponse extends PostMethodResponse {
  /**
   * The function call output.
   * @type {any}
   * @memberof MethodCallResponse
   */
  output: any;
}
/**
 *
 * @export
 * @interface MethodCallResponseAllOf
 */
export interface MethodCallResponseAllOf {
  /**
   * The function call output.
   * @type {any}
   * @memberof MethodCallResponseAllOf
   */
  output: any;
}
/**
 * Type conversion options for each of the inputs and outputs of a function.
 * @export
 * @interface MethodTypeConversionOptions
 */
export interface MethodTypeConversionOptions {
  /**
   *
   * @type {Array<TypeConversionOptions>}
   * @memberof MethodTypeConversionOptions
   */
  inputs: Array<TypeConversionOptions>;
  /**
   *
   * @type {Array<TypeConversionOptions>}
   * @memberof MethodTypeConversionOptions
   */
  outputs: Array<TypeConversionOptions>;
}
/**
 * An error response.
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * The unique error code.
   * @type {number}
   * @memberof ModelError
   */
  status: number;
  /**
   * The human-readable error message.
   * @type {string}
   * @memberof ModelError
   */
  message: string;
}
/**
 * Arguments to be passed into a contract function.
 * @export
 * @interface PostMethodArgs
 */
export interface PostMethodArgs {
  /**
   *
   * @type {string}
   * @memberof PostMethodArgs
   */
  signature?: string;
  /**
   * List of the function arguments.
   * @type {Array<any>}
   * @memberof PostMethodArgs
   */
  args?: Array<any>;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof PostMethodArgs
   */
  from?: string;
  /**
   * Nonce to use for the transaction execution.
   * @type {number}
   * @memberof PostMethodArgs
   */
  nonce?: number;
  /**
   * Gas price to use for the transaction execution.
   * @type {number}
   * @memberof PostMethodArgs
   */
  gasPrice?: number;
  /**
   * Gas fee cap to use for the 1559 transaction execution.
   * @type {number}
   * @memberof PostMethodArgs
   */
  gasFeeCap?: number;
  /**
   * Gas priority fee cap to use for the 1559 transaction execution.
   * @type {number}
   * @memberof PostMethodArgs
   */
  gasTipCap?: number;
  /**
   * Gas limit to set for the transaction execution.
   * @type {number}
   * @memberof PostMethodArgs
   */
  gas?: number;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof PostMethodArgs
   */
  to?: string;
  /**
   *
   * @type {number}
   * @memberof PostMethodArgs
   */
  value?: number;
  /**
   * If the `from` address is an HSM address and this flag is set to `true`, the transaction will be automatically signed and submitted to the blockchain.
   * @type {boolean}
   * @memberof PostMethodArgs
   */
  signAndSubmit?: boolean;
  /**
   * If the `from` address is an HSM address and this flag is set to `true`, MultiBaas will keep track of the nonce and set it accordingly. This is particularly useful when submitting multiple transactions concurrently or in a very short period of time. If this flag is set to `true` and a `nonce` is provided, it will reset the nonce tracker to the given nonce (useful if the nonce tracker is out of sync).
   * @type {boolean}
   * @memberof PostMethodArgs
   */
  nonceManagement?: boolean;
  /**
   * If set to `true`, forces a legacy type transaction. Otherwise an EIP-1559 transaction will created if the network supports it.
   * @type {boolean}
   * @memberof PostMethodArgs
   */
  preEIP1559?: boolean;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof PostMethodArgs
   */
  signer?: string;
  /**
   * Mode to format integer outputs in the function call\'s responses. There are 3 possible modes:   - `auto` (the default option), where number format is decided by its type:     - If the type has size at most 32 bits, then the number is returned verbatim.     - If the type has size larger than 32 bits, then the number is returned as a string.   - `as-numbers`, where all numbers are returned as strings.   - `as-strings`, where all numbers are returned verbatim.
   * @type {string}
   * @memberof PostMethodArgs
   */
  formatInts?: string;
  /**
   * Call the function at a specific timestamp. Only available for read functions calls and if the `historical_blocks_feature` is enabled (see the plan endpoint). Mutually exclusive with the `blockNumber` parameter.
   * @type {string}
   * @memberof PostMethodArgs
   */
  timestamp?: string;
  /**
   * Call the function at a specific block. Only available for read functions calls and if the `historical_blocks_feature` is enabled (see the plan endpoint). Mutually exclusive with the `timestamp` parameter.
   * @type {string}
   * @memberof PostMethodArgs
   */
  blockNumber?: string;
  /**
   * If set to true the given address and contract don\'t need to be linked for the function to be called.
   * @type {boolean}
   * @memberof PostMethodArgs
   */
  contractOverride?: boolean;
  /**
   *
   * @type {PreviewArgs}
   * @memberof PostMethodArgs
   */
  preview?: PreviewArgs;
}
/**
 *
 * @export
 * @interface PostMethodResponse
 */
export interface PostMethodResponse {
  /**
   * The response object type (discriminator).
   * @type {string}
   * @memberof PostMethodResponse
   */
  kind: string;
}
/**
 * Ephemeral configuration for previewing the effect of a Type Conversion on a contract function call.
 * @export
 * @interface PreviewArgs
 */
export interface PreviewArgs {
  /**
   * Only preview the effect of a Type Conversion on the inputs. Only applicable for write function calls, where the output is an unsigned transaction.
   * @type {boolean}
   * @memberof PreviewArgs
   */
  inputsOnly: boolean;
  /**
   * Type Conversion information for the function inputs. The number of inputs must match that of the actual function inputs. The parameter is a contract function argument where only the type conversion information is used.
   * @type {Array<ContractABIMethodArgument>}
   * @memberof PreviewArgs
   */
  inputs: Array<ContractABIMethodArgument>;
  /**
   * Type Conversion information for the function outputs. The number of outputs must match that of the actual function outputs. The parameter is a contract function argument where only the type conversion information is used.
   * @type {Array<ContractABIMethodArgument>}
   * @memberof PreviewArgs
   */
  outputs: Array<ContractABIMethodArgument>;
}
/**
 * A role.
 * @export
 * @interface Role
 */
export interface Role {
  /**
   * The role ID.
   * @type {number}
   * @memberof Role
   */
  id: number;
  /**
   * The role name.
   * @type {string}
   * @memberof Role
   */
  name: string;
  /**
   * The role short name.
   * @type {string}
   * @memberof Role
   */
  shortName: string;
  /**
   * The role description.
   * @type {string}
   * @memberof Role
   */
  description: string;
}
/**
 * A saved event query.
 * @export
 * @interface SavedEventQuery
 */
export interface SavedEventQuery {
  /**
   *
   * @type {number}
   * @memberof SavedEventQuery
   */
  id: number;
  /**
   * An event query label.
   * @type {string}
   * @memberof SavedEventQuery
   */
  label: string;
  /**
   *
   * @type {EventQuery}
   * @memberof SavedEventQuery
   */
  query: EventQuery;
  /**
   * Specifies if this a system-generated query which is not modifiable by the user.
   * @type {boolean}
   * @memberof SavedEventQuery
   */
  isSystem: boolean;
}
/**
 *
 * @export
 * @interface SetAddress201Response
 */
export interface SetAddress201Response {
  /**
   * The status code.
   * @type {number}
   * @memberof SetAddress201Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof SetAddress201Response
   */
  message: string;
  /**
   *
   * @type {Address}
   * @memberof SetAddress201Response
   */
  result: Address;
}
/**
 *
 * @export
 * @interface SetAddress201ResponseAllOf
 */
export interface SetAddress201ResponseAllOf {
  /**
   *
   * @type {Address}
   * @memberof SetAddress201ResponseAllOf
   */
  result: Address;
}
/**
 * Request body representing a set local nonce request.
 * @export
 * @interface SetNonceRequest
 */
export interface SetNonceRequest {
  /**
   * If nonce is specified the provided value is set, otherwise the value is read from the blockchain.
   * @type {number}
   * @memberof SetNonceRequest
   */
  nonce?: number;
}
/**
 *
 * @export
 * @interface SignData200Response
 */
export interface SignData200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof SignData200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof SignData200Response
   */
  message: string;
  /**
   *
   * @type {HSMSignResponse}
   * @memberof SignData200Response
   */
  result: HSMSignResponse;
}
/**
 *
 * @export
 * @interface SignData200ResponseAllOf
 */
export interface SignData200ResponseAllOf {
  /**
   *
   * @type {HSMSignResponse}
   * @memberof SignData200ResponseAllOf
   */
  result: HSMSignResponse;
}
/**
 * The object used to receive a pre-signed raw transaction.
 * @export
 * @interface SignedTransactionSubmission
 */
export interface SignedTransactionSubmission {
  /**
   * The pre-signed raw transaction.
   * @type {string}
   * @memberof SignedTransactionSubmission
   */
  signedTx: string;
}
/**
 * An object containing an HSM wallet\'s details.
 * @export
 * @interface StandaloneWallet
 */
export interface StandaloneWallet {
  /**
   * The Application ID that accesses the Key Vault.
   * @type {string}
   * @memberof StandaloneWallet
   */
  clientID?: string;
  /**
   * The Resource Group Name for the resource being accessed.
   * @type {string}
   * @memberof StandaloneWallet
   */
  baseGroupName: string;
  /**
   * The name given to the vault your key is stored in.
   * @type {string}
   * @memberof StandaloneWallet
   */
  vaultName?: string;
  /**
   * The name of the key.
   * @type {string}
   * @memberof StandaloneWallet
   */
  keyName: string;
  /**
   * The version of the key.
   * @type {string}
   * @memberof StandaloneWallet
   */
  keyVersion?: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof StandaloneWallet
   */
  publicAddress: string;
}
/**
 *
 * @export
 * @interface SubmitSignedTransaction200Response
 */
export interface SubmitSignedTransaction200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof SubmitSignedTransaction200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof SubmitSignedTransaction200Response
   */
  message: string;
}
/**
 * A transaction from the Ethereum Blockchain.
 * @export
 * @interface Transaction
 */
export interface Transaction {
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  type: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  nonce: string;
  /**
   * A hex string or null.
   * @type {string}
   * @memberof Transaction
   */
  gasPrice?: string | null;
  /**
   * A hex string or null.
   * @type {string}
   * @memberof Transaction
   */
  maxFeePerGas?: string | null;
  /**
   * A hex string or null.
   * @type {string}
   * @memberof Transaction
   */
  maxPriorityFeePerGas?: string | null;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  gas: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof Transaction
   */
  to: string | null;
  /**
   * A hex string or null.
   * @type {string}
   * @memberof Transaction
   */
  value: string | null;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  input: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  v: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  r: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  s: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  chainId?: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Transaction
   */
  hash: string;
}
/**
 * The transaction data returned from a call to get transaction by hash.
 * @export
 * @interface TransactionData
 */
export interface TransactionData {
  /**
   *
   * @type {Transaction}
   * @memberof TransactionData
   */
  data: Transaction;
  /**
   * Whether the transaction has been mined yet.
   * @type {boolean}
   * @memberof TransactionData
   */
  isPending: boolean;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof TransactionData
   */
  from: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof TransactionData
   */
  blockHash?: string;
  /**
   * The transaction block number.
   * @type {string}
   * @memberof TransactionData
   */
  blockNumber?: string;
  /**
   *
   * @type {ContractInformation}
   * @memberof TransactionData
   */
  contract?: ContractInformation;
  /**
   *
   * @type {ContractMethodInformation}
   * @memberof TransactionData
   */
  method?: ContractMethodInformation;
}
/**
 * The transaction information returned as part of an event.
 * @export
 * @interface TransactionInformation
 */
export interface TransactionInformation {
  /**
   * An ethereum address.
   * @type {string}
   * @memberof TransactionInformation
   */
  from: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionInformation
   */
  txData: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof TransactionInformation
   */
  txHash: string;
  /**
   * The location of the transaction in the block.
   * @type {number}
   * @memberof TransactionInformation
   */
  txIndexInBlock: number;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof TransactionInformation
   */
  blockHash: string;
  /**
   * The transaction block number.
   * @type {number}
   * @memberof TransactionInformation
   */
  blockNumber: number;
  /**
   *
   * @type {ContractInformation}
   * @memberof TransactionInformation
   */
  contract: ContractInformation;
  /**
   *
   * @type {ContractMethodInformation}
   * @memberof TransactionInformation
   */
  method: ContractMethodInformation;
}
/**
 * Record of the transaction\'s outcome.
 * @export
 * @interface TransactionReceipt
 */
export interface TransactionReceipt {
  /**
   *
   * @type {TransactionReceiptData}
   * @memberof TransactionReceipt
   */
  data: TransactionReceiptData;
  /**
   *
   * @type {Array<EventInformation>}
   * @memberof TransactionReceipt
   */
  events?: Array<EventInformation>;
}
/**
 *
 * @export
 * @interface TransactionReceiptData
 */
export interface TransactionReceiptData {
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  type?: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  root: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  status: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  cumulativeGasUsed: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  logsBloom: string;
  /**
   *
   * @type {Array<Log>}
   * @memberof TransactionReceiptData
   */
  logs: Array<Log>;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  transactionHash: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  contractAddress: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  gasUsed: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  effectiveGasPrice: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  blockNumber: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  transactionIndex: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  blockHash: string;
}
/**
 * The status of a TXM transaction.
 * @export
 * @enum {string}
 */

export const TransactionStatus = {
  Pending: 'pending',
  Included: 'included',
  Replaced: 'replaced',
  Cancelled: 'cancelled',
  Rejected: 'rejected',
  ExceededRetryLimit: 'exceeded retry limit'
} as const;

export type TransactionStatus = typeof TransactionStatus[keyof typeof TransactionStatus];

/**
 * A transaction to be signed.
 * @export
 * @interface TransactionToSign
 */
export interface TransactionToSign {
  /**
   *
   * @type {BaseTransactionToSignTx}
   * @memberof TransactionToSign
   */
  tx: BaseTransactionToSignTx;
  /**
   *
   * @type {boolean}
   * @memberof TransactionToSign
   */
  submitted: boolean;
}
/**
 *
 * @export
 * @interface TransactionToSignAllOf
 */
export interface TransactionToSignAllOf {
  /**
   *
   * @type {boolean}
   * @memberof TransactionToSignAllOf
   */
  submitted: boolean;
}
/**
 *
 * @export
 * @interface TransactionToSignResponse
 */
export interface TransactionToSignResponse extends PostMethodResponse {
  /**
   *
   * @type {BaseTransactionToSignTx}
   * @memberof TransactionToSignResponse
   */
  tx: BaseTransactionToSignTx;
  /**
   *
   * @type {boolean}
   * @memberof TransactionToSignResponse
   */
  submitted: boolean;
}
/**
 *
 * @export
 * @interface TransferEth200Response
 */
export interface TransferEth200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof TransferEth200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof TransferEth200Response
   */
  message: string;
  /**
   *
   * @type {TransactionToSign}
   * @memberof TransferEth200Response
   */
  result: TransactionToSign;
}
/**
 *
 * @export
 * @interface TransferEth200ResponseAllOf
 */
export interface TransferEth200ResponseAllOf {
  /**
   *
   * @type {TransactionToSign}
   * @memberof TransferEth200ResponseAllOf
   */
  result: TransactionToSign;
}
/**
 * Represents the set of type conversions allowed for a particular input or output of a function (how it may be \"cast\").
 * @export
 * @interface TypeConversionOptions
 */
export interface TypeConversionOptions {
  /**
   *
   * @type {Array<string>}
   * @memberof TypeConversionOptions
   */
  types?: Array<string> | null;
}
/**
 * A user.
 * @export
 * @interface User
 */
export interface User {
  /**
   * The user\'s email address.
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   * The user\'s name.
   * @type {string}
   * @memberof User
   */
  name: string;
  /**
   * The user ID.
   * @type {number}
   * @memberof User
   */
  id: number;
}
/**
 *
 * @export
 * @interface UserAllOf
 */
export interface UserAllOf {
  /**
   * The user ID.
   * @type {number}
   * @memberof UserAllOf
   */
  id: number;
}
/**
 *
 * @export
 * @interface WalletTransaction
 */
export interface WalletTransaction {
  /**
   *
   * @type {Transaction}
   * @memberof WalletTransaction
   */
  tx: Transaction;
  /**
   *
   * @type {TransactionStatus}
   * @memberof WalletTransaction
   */
  status: TransactionStatus;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof WalletTransaction
   */
  from: string;
  /**
   * The total number of resubmission attempts.
   * @type {number}
   * @memberof WalletTransaction
   */
  resubmissionAttempts: number;
  /**
   * The total number of successful resubmission (added into the transaction pool).
   * @type {number}
   * @memberof WalletTransaction
   */
  successfulResubmissions: number;
  /**
   * The time the transaction was created.
   * @type {string}
   * @memberof WalletTransaction
   */
  createdAt: string;
  /**
   * The time the transaction was last updated.
   * @type {string}
   * @memberof WalletTransaction
   */
  updatedAt: string;
  /**
   * Whether the transaction failed when it was included in a block.
   * @type {boolean}
   * @memberof WalletTransaction
   */
  failed?: boolean;
  /**
   * The block number that the transaction was included in.
   * @type {number}
   * @memberof WalletTransaction
   */
  blockNumber?: number;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof WalletTransaction
   */
  blockHash?: string;
}

/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Deletes an address label.
     * @summary Delete address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAddress: async (
      chain: ChainName,
      addressOrLabel: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('deleteAddress', 'chain', chain);
      // verify required parameter 'addressOrLabel' is not null or undefined
      assertParamExists('deleteAddress', 'addressOrLabel', addressOrLabel);
      const localVarPath = `/chains/{chain}/addresses/{address-or-label}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-label'}}`, encodeURIComponent(String(addressOrLabel)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns details about an address.
     * @summary Get address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {Array<'balance' | 'code' | 'nonce'>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress: async (
      chain: ChainName,
      addressOrLabel: string,
      include?: Array<'balance' | 'code' | 'nonce'>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getAddress', 'chain', chain);
      // verify required parameter 'addressOrLabel' is not null or undefined
      assertParamExists('getAddress', 'addressOrLabel', addressOrLabel);
      const localVarPath = `/chains/{chain}/addresses/{address-or-label}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-label'}}`, encodeURIComponent(String(addressOrLabel)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (include) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the labeled addresses.
     * @summary List addresses
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses: async (chain: ChainName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('listAddresses', 'chain', chain);
      const localVarPath = `/chains/{chain}/addresses`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Associates an address with a label.
     * @summary Create or update address
     * @param {ChainName} chain The blockchain chain label.
     * @param {AddressLabel} [addressLabel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAddress: async (
      chain: ChainName,
      addressLabel?: AddressLabel,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('setAddress', 'chain', chain);
      const localVarPath = `/chains/{chain}/addresses`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(addressLabel, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration);
  return {
    /**
     * Deletes an address label.
     * @summary Delete address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAddress(
      chain: ChainName,
      addressOrLabel: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAddress(chain, addressOrLabel, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns details about an address.
     * @summary Get address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {Array<'balance' | 'code' | 'nonce'>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAddress(
      chain: ChainName,
      addressOrLabel: string,
      include?: Array<'balance' | 'code' | 'nonce'>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetAddress201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(chain, addressOrLabel, include, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns all the labeled addresses.
     * @summary List addresses
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAddresses(
      chain: ChainName,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAddresses200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(chain, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Associates an address with a label.
     * @summary Create or update address
     * @param {ChainName} chain The blockchain chain label.
     * @param {AddressLabel} [addressLabel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setAddress(
      chain: ChainName,
      addressLabel?: AddressLabel,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetAddress201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setAddress(chain, addressLabel, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AddressesApiFp(configuration);
  return {
    /**
     * Deletes an address label.
     * @summary Delete address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAddress(
      chain: ChainName,
      addressOrLabel: string,
      options?: any
    ): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp.deleteAddress(chain, addressOrLabel, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns details about an address.
     * @summary Get address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {Array<'balance' | 'code' | 'nonce'>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress(
      chain: ChainName,
      addressOrLabel: string,
      include?: Array<'balance' | 'code' | 'nonce'>,
      options?: any
    ): AxiosPromise<SetAddress201Response> {
      return localVarFp.getAddress(chain, addressOrLabel, include, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the labeled addresses.
     * @summary List addresses
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses(chain: ChainName, options?: any): AxiosPromise<ListAddresses200Response> {
      return localVarFp.listAddresses(chain, options).then((request) => request(axios, basePath));
    },
    /**
     * Associates an address with a label.
     * @summary Create or update address
     * @param {ChainName} chain The blockchain chain label.
     * @param {AddressLabel} [addressLabel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAddress(chain: ChainName, addressLabel?: AddressLabel, options?: any): AxiosPromise<SetAddress201Response> {
      return localVarFp.setAddress(chain, addressLabel, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * AddressesApi - interface
 * @export
 * @interface AddressesApi
 */
export interface AddressesApiInterface {
  /**
   * Deletes an address label.
   * @summary Delete address
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrLabel An address or the label of an address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApiInterface
   */
  deleteAddress(
    chain: ChainName,
    addressOrLabel: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Returns details about an address.
   * @summary Get address
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrLabel An address or the label of an address.
   * @param {Array<'balance' | 'code' | 'nonce'>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApiInterface
   */
  getAddress(
    chain: ChainName,
    addressOrLabel: string,
    include?: Array<'balance' | 'code' | 'nonce'>,
    options?: AxiosRequestConfig
  ): AxiosPromise<SetAddress201Response>;

  /**
   * Returns all the labeled addresses.
   * @summary List addresses
   * @param {ChainName} chain The blockchain chain label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApiInterface
   */
  listAddresses(chain: ChainName, options?: AxiosRequestConfig): AxiosPromise<ListAddresses200Response>;

  /**
   * Associates an address with a label.
   * @summary Create or update address
   * @param {ChainName} chain The blockchain chain label.
   * @param {AddressLabel} [addressLabel]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApiInterface
   */
  setAddress(
    chain: ChainName,
    addressLabel?: AddressLabel,
    options?: AxiosRequestConfig
  ): AxiosPromise<SetAddress201Response>;
}

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI implements AddressesApiInterface {
  /**
   * Deletes an address label.
   * @summary Delete address
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrLabel An address or the label of an address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public deleteAddress(chain: ChainName, addressOrLabel: string, options?: AxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .deleteAddress(chain, addressOrLabel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns details about an address.
   * @summary Get address
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrLabel An address or the label of an address.
   * @param {Array<'balance' | 'code' | 'nonce'>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public getAddress(
    chain: ChainName,
    addressOrLabel: string,
    include?: Array<'balance' | 'code' | 'nonce'>,
    options?: AxiosRequestConfig
  ) {
    return AddressesApiFp(this.configuration)
      .getAddress(chain, addressOrLabel, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the labeled addresses.
   * @summary List addresses
   * @param {ChainName} chain The blockchain chain label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public listAddresses(chain: ChainName, options?: AxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .listAddresses(chain, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Associates an address with a label.
   * @summary Create or update address
   * @param {ChainName} chain The blockchain chain label.
   * @param {AddressLabel} [addressLabel]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public setAddress(chain: ChainName, addressLabel?: AddressLabel, options?: AxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .setAddress(chain, addressLabel, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Adds a CORS origin.
     * @summary Add CORS origin
     * @param {CORSOrigin} [cORSOrigin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCorsOrigin: async (cORSOrigin?: CORSOrigin, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/cors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cORSOrigin, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds an API key to a group.
     * @summary Add API key to group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupApikey: async (
      groupID: number,
      apiKeyID: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('addGroupApikey', 'groupID', groupID);
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('addGroupApikey', 'apiKeyID', apiKeyID);
      const localVarPath = `/groups/{groupID}/api_keys/{apiKeyID}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds a role to a group.
     * @summary Add role to group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupRole: async (
      groupID: number,
      roleShortName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('addGroupRole', 'groupID', groupID);
      // verify required parameter 'roleShortName' is not null or undefined
      assertParamExists('addGroupRole', 'roleShortName', roleShortName);
      const localVarPath = `/groups/{groupID}/roles/{roleShortName}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'roleShortName'}}`, encodeURIComponent(String(roleShortName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds a user to a group.
     * @summary Add user to group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupUser: async (groupID: number, userID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('addGroupUser', 'groupID', groupID);
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('addGroupUser', 'userID', userID);
      const localVarPath = `/groups/{groupID}/users/{userID}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates an API key and adds it to group IDs.
     * @summary Create API key
     * @param {CreateApiKeyRequest} [createApiKeyRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey: async (
      createApiKeyRequest?: CreateApiKeyRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api_keys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createApiKeyRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an API key.
     * @summary Delete API key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey: async (apiKeyID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('deleteApiKey', 'apiKeyID', apiKeyID);
      const localVarPath = `/api_keys/{apiKeyID}`.replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a user.
     * @summary Delete user
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (userID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('deleteUser', 'userID', userID);
      const localVarPath = `/users/{userID}`.replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns an API key.
     * @summary Get API Key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey: async (apiKeyID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('getApiKey', 'apiKeyID', apiKeyID);
      const localVarPath = `/api_keys/{apiKeyID}`.replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the API keys.
     * @summary List API keys
     * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys: async (all?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api_keys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (all !== undefined) {
        localVarQueryParameter['all'] = all;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the audit logs.
     * @summary List audit logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAuditLogs: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/systemactivities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of CORS origins.
     * @summary List CORS origins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCorsOrigins: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/cors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the groups.
     * @summary List groups
     * @param {number} [userID]
     * @param {number} [apiKeyID]
     * @param {boolean} [assignable]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroups: async (
      userID?: number,
      apiKeyID?: number,
      assignable?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/groups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (userID !== undefined) {
        localVarQueryParameter['userID'] = userID;
      }

      if (apiKeyID !== undefined) {
        localVarQueryParameter['apiKeyID'] = apiKeyID;
      }

      if (assignable !== undefined) {
        localVarQueryParameter['assignable'] = assignable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the users.
     * @summary List users
     * @param {number} [groupID]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers: async (groupID?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (groupID !== undefined) {
        localVarQueryParameter['groupID'] = groupID;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a CORS origin.
     * @summary Remove CORS Origin
     * @param {number} originID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCorsOrigin: async (originID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'originID' is not null or undefined
      assertParamExists('removeCorsOrigin', 'originID', originID);
      const localVarPath = `/cors/{originID}`.replace(`{${'originID'}}`, encodeURIComponent(String(originID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes an API key from a group.
     * @summary Remove API key from group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupApikey: async (
      groupID: number,
      apiKeyID: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('removeGroupApikey', 'groupID', groupID);
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('removeGroupApikey', 'apiKeyID', apiKeyID);
      const localVarPath = `/groups/{groupID}/api_keys/{apiKeyID}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a role from a group.
     * @summary Remove role from group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupRole: async (
      groupID: number,
      roleShortName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('removeGroupRole', 'groupID', groupID);
      // verify required parameter 'roleShortName' is not null or undefined
      assertParamExists('removeGroupRole', 'roleShortName', roleShortName);
      const localVarPath = `/groups/{groupID}/roles/{roleShortName}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'roleShortName'}}`, encodeURIComponent(String(roleShortName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a user from a group.
     * @summary Remove user from group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupUser: async (
      groupID: number,
      userID: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('removeGroupUser', 'groupID', groupID);
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('removeGroupUser', 'userID', userID);
      const localVarPath = `/groups/{groupID}/users/{userID}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates an API key.
     * @summary Update API key
     * @param {number} apiKeyID
     * @param {BaseAPIKey} [baseAPIKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApiKey: async (
      apiKeyID: number,
      baseAPIKey?: BaseAPIKey,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('updateApiKey', 'apiKeyID', apiKeyID);
      const localVarPath = `/api_keys/{apiKeyID}`.replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseAPIKey, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration);
  return {
    /**
     * Adds a CORS origin.
     * @summary Add CORS origin
     * @param {CORSOrigin} [cORSOrigin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addCorsOrigin(
      cORSOrigin?: CORSOrigin,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addCorsOrigin(cORSOrigin, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Adds an API key to a group.
     * @summary Add API key to group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGroupApikey(
      groupID: number,
      apiKeyID: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupApikey(groupID, apiKeyID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Adds a role to a group.
     * @summary Add role to group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGroupRole(
      groupID: number,
      roleShortName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupRole(groupID, roleShortName, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Adds a user to a group.
     * @summary Add user to group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGroupUser(
      groupID: number,
      userID: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupUser(groupID, userID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Creates an API key and adds it to group IDs.
     * @summary Create API key
     * @param {CreateApiKeyRequest} [createApiKeyRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApiKey(
      createApiKeyRequest?: CreateApiKeyRequest,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateApiKey200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(createApiKeyRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Deletes an API key.
     * @summary Delete API key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApiKey(
      apiKeyID: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(apiKeyID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Deletes a user.
     * @summary Delete user
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userID: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns an API key.
     * @summary Get API Key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKey(
      apiKeyID: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateApiKey200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKey(apiKeyID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns all the API keys.
     * @summary List API keys
     * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listApiKeys(
      all?: boolean,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApiKeys200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeys(all, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns the audit logs.
     * @summary List audit logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAuditLogs(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAuditLogs200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAuditLogs(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns a list of CORS origins.
     * @summary List CORS origins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCorsOrigins(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCorsOrigins200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listCorsOrigins(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns all the groups.
     * @summary List groups
     * @param {number} [userID]
     * @param {number} [apiKeyID]
     * @param {boolean} [assignable]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGroups(
      userID?: number,
      apiKeyID?: number,
      assignable?: boolean,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListGroups200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(userID, apiKeyID, assignable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns all the users.
     * @summary List users
     * @param {number} [groupID]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUsers(
      groupID?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsers200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(groupID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Removes a CORS origin.
     * @summary Remove CORS Origin
     * @param {number} originID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeCorsOrigin(
      originID: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeCorsOrigin(originID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Removes an API key from a group.
     * @summary Remove API key from group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeGroupApikey(
      groupID: number,
      apiKeyID: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeGroupApikey(groupID, apiKeyID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Removes a role from a group.
     * @summary Remove role from group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeGroupRole(
      groupID: number,
      roleShortName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeGroupRole(groupID, roleShortName, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Removes a user from a group.
     * @summary Remove user from group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeGroupUser(
      groupID: number,
      userID: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeGroupUser(groupID, userID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Updates an API key.
     * @summary Update API key
     * @param {number} apiKeyID
     * @param {BaseAPIKey} [baseAPIKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateApiKey(
      apiKeyID: number,
      baseAPIKey?: BaseAPIKey,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateApiKey(apiKeyID, baseAPIKey, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AdminApiFp(configuration);
  return {
    /**
     * Adds a CORS origin.
     * @summary Add CORS origin
     * @param {CORSOrigin} [cORSOrigin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCorsOrigin(cORSOrigin?: CORSOrigin, options?: any): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp.addCorsOrigin(cORSOrigin, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds an API key to a group.
     * @summary Add API key to group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupApikey(groupID: number, apiKeyID: number, options?: any): AxiosPromise<BaseResponse> {
      return localVarFp.addGroupApikey(groupID, apiKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds a role to a group.
     * @summary Add role to group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupRole(groupID: number, roleShortName: string, options?: any): AxiosPromise<BaseResponse> {
      return localVarFp.addGroupRole(groupID, roleShortName, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds a user to a group.
     * @summary Add user to group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupUser(groupID: number, userID: number, options?: any): AxiosPromise<BaseResponse> {
      return localVarFp.addGroupUser(groupID, userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates an API key and adds it to group IDs.
     * @summary Create API key
     * @param {CreateApiKeyRequest} [createApiKeyRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(createApiKeyRequest?: CreateApiKeyRequest, options?: any): AxiosPromise<CreateApiKey200Response> {
      return localVarFp.createApiKey(createApiKeyRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes an API key.
     * @summary Delete API key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey(apiKeyID: number, options?: any): AxiosPromise<BaseResponse> {
      return localVarFp.deleteApiKey(apiKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a user.
     * @summary Delete user
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userID: number, options?: any): AxiosPromise<BaseResponse> {
      return localVarFp.deleteUser(userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns an API key.
     * @summary Get API Key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey(apiKeyID: number, options?: any): AxiosPromise<CreateApiKey200Response> {
      return localVarFp.getApiKey(apiKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the API keys.
     * @summary List API keys
     * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys(all?: boolean, options?: any): AxiosPromise<ListApiKeys200Response> {
      return localVarFp.listApiKeys(all, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the audit logs.
     * @summary List audit logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAuditLogs(options?: any): AxiosPromise<ListAuditLogs200Response> {
      return localVarFp.listAuditLogs(options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of CORS origins.
     * @summary List CORS origins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCorsOrigins(options?: any): AxiosPromise<ListCorsOrigins200Response> {
      return localVarFp.listCorsOrigins(options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the groups.
     * @summary List groups
     * @param {number} [userID]
     * @param {number} [apiKeyID]
     * @param {boolean} [assignable]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroups(
      userID?: number,
      apiKeyID?: number,
      assignable?: boolean,
      options?: any
    ): AxiosPromise<ListGroups200Response> {
      return localVarFp.listGroups(userID, apiKeyID, assignable, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the users.
     * @summary List users
     * @param {number} [groupID]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(groupID?: number, options?: any): AxiosPromise<ListUsers200Response> {
      return localVarFp.listUsers(groupID, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes a CORS origin.
     * @summary Remove CORS Origin
     * @param {number} originID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCorsOrigin(originID: number, options?: any): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp.removeCorsOrigin(originID, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes an API key from a group.
     * @summary Remove API key from group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupApikey(groupID: number, apiKeyID: number, options?: any): AxiosPromise<BaseResponse> {
      return localVarFp.removeGroupApikey(groupID, apiKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes a role from a group.
     * @summary Remove role from group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupRole(groupID: number, roleShortName: string, options?: any): AxiosPromise<BaseResponse> {
      return localVarFp.removeGroupRole(groupID, roleShortName, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes a user from a group.
     * @summary Remove user from group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupUser(groupID: number, userID: number, options?: any): AxiosPromise<BaseResponse> {
      return localVarFp.removeGroupUser(groupID, userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Updates an API key.
     * @summary Update API key
     * @param {number} apiKeyID
     * @param {BaseAPIKey} [baseAPIKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApiKey(apiKeyID: number, baseAPIKey?: BaseAPIKey, options?: any): AxiosPromise<BaseResponse> {
      return localVarFp.updateApiKey(apiKeyID, baseAPIKey, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * AdminApi - interface
 * @export
 * @interface AdminApi
 */
export interface AdminApiInterface {
  /**
   * Adds a CORS origin.
   * @summary Add CORS origin
   * @param {CORSOrigin} [cORSOrigin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  addCorsOrigin(
    cORSOrigin?: CORSOrigin,
    options?: AxiosRequestConfig
  ): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Adds an API key to a group.
   * @summary Add API key to group
   * @param {number} groupID
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  addGroupApikey(groupID: number, apiKeyID: number, options?: AxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Adds a role to a group.
   * @summary Add role to group
   * @param {number} groupID
   * @param {string} roleShortName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  addGroupRole(groupID: number, roleShortName: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Adds a user to a group.
   * @summary Add user to group
   * @param {number} groupID
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  addGroupUser(groupID: number, userID: number, options?: AxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Creates an API key and adds it to group IDs.
   * @summary Create API key
   * @param {CreateApiKeyRequest} [createApiKeyRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  createApiKey(
    createApiKeyRequest?: CreateApiKeyRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<CreateApiKey200Response>;

  /**
   * Deletes an API key.
   * @summary Delete API key
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  deleteApiKey(apiKeyID: number, options?: AxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Deletes a user.
   * @summary Delete user
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  deleteUser(userID: number, options?: AxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Returns an API key.
   * @summary Get API Key
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  getApiKey(apiKeyID: number, options?: AxiosRequestConfig): AxiosPromise<CreateApiKey200Response>;

  /**
   * Returns all the API keys.
   * @summary List API keys
   * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  listApiKeys(all?: boolean, options?: AxiosRequestConfig): AxiosPromise<ListApiKeys200Response>;

  /**
   * Returns the audit logs.
   * @summary List audit logs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  listAuditLogs(options?: AxiosRequestConfig): AxiosPromise<ListAuditLogs200Response>;

  /**
   * Returns a list of CORS origins.
   * @summary List CORS origins
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  listCorsOrigins(options?: AxiosRequestConfig): AxiosPromise<ListCorsOrigins200Response>;

  /**
   * Returns all the groups.
   * @summary List groups
   * @param {number} [userID]
   * @param {number} [apiKeyID]
   * @param {boolean} [assignable]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  listGroups(
    userID?: number,
    apiKeyID?: number,
    assignable?: boolean,
    options?: AxiosRequestConfig
  ): AxiosPromise<ListGroups200Response>;

  /**
   * Returns all the users.
   * @summary List users
   * @param {number} [groupID]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  listUsers(groupID?: number, options?: AxiosRequestConfig): AxiosPromise<ListUsers200Response>;

  /**
   * Removes a CORS origin.
   * @summary Remove CORS Origin
   * @param {number} originID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  removeCorsOrigin(originID: number, options?: AxiosRequestConfig): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Removes an API key from a group.
   * @summary Remove API key from group
   * @param {number} groupID
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  removeGroupApikey(groupID: number, apiKeyID: number, options?: AxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Removes a role from a group.
   * @summary Remove role from group
   * @param {number} groupID
   * @param {string} roleShortName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  removeGroupRole(groupID: number, roleShortName: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Removes a user from a group.
   * @summary Remove user from group
   * @param {number} groupID
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  removeGroupUser(groupID: number, userID: number, options?: AxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Updates an API key.
   * @summary Update API key
   * @param {number} apiKeyID
   * @param {BaseAPIKey} [baseAPIKey]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  updateApiKey(apiKeyID: number, baseAPIKey?: BaseAPIKey, options?: AxiosRequestConfig): AxiosPromise<BaseResponse>;
}

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI implements AdminApiInterface {
  /**
   * Adds a CORS origin.
   * @summary Add CORS origin
   * @param {CORSOrigin} [cORSOrigin]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addCorsOrigin(cORSOrigin?: CORSOrigin, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .addCorsOrigin(cORSOrigin, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an API key to a group.
   * @summary Add API key to group
   * @param {number} groupID
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addGroupApikey(groupID: number, apiKeyID: number, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .addGroupApikey(groupID, apiKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a role to a group.
   * @summary Add role to group
   * @param {number} groupID
   * @param {string} roleShortName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addGroupRole(groupID: number, roleShortName: string, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .addGroupRole(groupID, roleShortName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a user to a group.
   * @summary Add user to group
   * @param {number} groupID
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addGroupUser(groupID: number, userID: number, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .addGroupUser(groupID, userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates an API key and adds it to group IDs.
   * @summary Create API key
   * @param {CreateApiKeyRequest} [createApiKeyRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public createApiKey(createApiKeyRequest?: CreateApiKeyRequest, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .createApiKey(createApiKeyRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes an API key.
   * @summary Delete API key
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteApiKey(apiKeyID: number, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .deleteApiKey(apiKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a user.
   * @summary Delete user
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteUser(userID: number, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .deleteUser(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns an API key.
   * @summary Get API Key
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getApiKey(apiKeyID: number, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .getApiKey(apiKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the API keys.
   * @summary List API keys
   * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public listApiKeys(all?: boolean, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listApiKeys(all, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the audit logs.
   * @summary List audit logs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public listAuditLogs(options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listAuditLogs(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of CORS origins.
   * @summary List CORS origins
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public listCorsOrigins(options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listCorsOrigins(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the groups.
   * @summary List groups
   * @param {number} [userID]
   * @param {number} [apiKeyID]
   * @param {boolean} [assignable]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public listGroups(userID?: number, apiKeyID?: number, assignable?: boolean, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listGroups(userID, apiKeyID, assignable, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the users.
   * @summary List users
   * @param {number} [groupID]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public listUsers(groupID?: number, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listUsers(groupID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a CORS origin.
   * @summary Remove CORS Origin
   * @param {number} originID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeCorsOrigin(originID: number, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeCorsOrigin(originID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes an API key from a group.
   * @summary Remove API key from group
   * @param {number} groupID
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeGroupApikey(groupID: number, apiKeyID: number, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeGroupApikey(groupID, apiKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a role from a group.
   * @summary Remove role from group
   * @param {number} groupID
   * @param {string} roleShortName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeGroupRole(groupID: number, roleShortName: string, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeGroupRole(groupID, roleShortName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a user from a group.
   * @summary Remove user from group
   * @param {number} groupID
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeGroupUser(groupID: number, userID: number, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeGroupUser(groupID, userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates an API key.
   * @summary Update API key
   * @param {number} apiKeyID
   * @param {BaseAPIKey} [baseAPIKey]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public updateApiKey(apiKeyID: number, baseAPIKey?: BaseAPIKey, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .updateApiKey(apiKeyID, baseAPIKey, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ChainsApi - axios parameter creator
 * @export
 */
export const ChainsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns a block.
     * @summary Get a block
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlock: async (chain: ChainName, block: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getBlock', 'chain', chain);
      // verify required parameter 'block' is not null or undefined
      assertParamExists('getBlock', 'block', block);
      const localVarPath = `/chains/{chain}/blocks/{block}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'block'}}`, encodeURIComponent(String(block)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the chain status.
     * @summary Get chain status
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChainStatus: async (chain: ChainName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getChainStatus', 'chain', chain);
      const localVarPath = `/chains/{chain}/status`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a transaction.
     * @summary Get transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash Transaction hash.
     * @param {'contract'} [include] Include contract and method call details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction: async (
      chain: ChainName,
      hash: string,
      include?: 'contract',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getTransaction', 'chain', chain);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('getTransaction', 'hash', hash);
      const localVarPath = `/chains/{chain}/transactions/{hash}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'hash'}}`, encodeURIComponent(String(hash)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
     * @summary Get transaction receipt
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash Transaction hash.
     * @param {'contract'} [include] Include contract and event details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionReceipt: async (
      chain: ChainName,
      hash: string,
      include?: 'contract',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getTransactionReceipt', 'chain', chain);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('getTransactionReceipt', 'hash', hash);
      const localVarPath = `/chains/{chain}/transactions/receipt/{hash}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'hash'}}`, encodeURIComponent(String(hash)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Receives a pre-signed raw transaction and submits it to the blockchain.
     * @summary Submit signed transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {SignedTransactionSubmission} [signedTransactionSubmission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitSignedTransaction: async (
      chain: ChainName,
      signedTransactionSubmission?: SignedTransactionSubmission,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('submitSignedTransaction', 'chain', chain);
      const localVarPath = `/chains/{chain}/transactions/submit`.replace(
        `{${'chain'}}`,
        encodeURIComponent(String(chain))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signedTransactionSubmission,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a transaction for sending the native token between addresses.
     * @summary Transfer ETH
     * @param {ChainName} chain The blockchain chain label.
     * @param {PostMethodArgs} [postMethodArgs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferEth: async (
      chain: ChainName,
      postMethodArgs?: PostMethodArgs,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('transferEth', 'chain', chain);
      const localVarPath = `/chains/{chain}/transfers`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMethodArgs, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ChainsApi - functional programming interface
 * @export
 */
export const ChainsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ChainsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a block.
     * @summary Get a block
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlock(
      chain: ChainName,
      block: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBlock200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBlock(chain, block, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns the chain status.
     * @summary Get chain status
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChainStatus(
      chain: ChainName,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChainStatus200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChainStatus(chain, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns a transaction.
     * @summary Get transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash Transaction hash.
     * @param {'contract'} [include] Include contract and method call details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransaction(
      chain: ChainName,
      hash: string,
      include?: 'contract',
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(chain, hash, include, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
     * @summary Get transaction receipt
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash Transaction hash.
     * @param {'contract'} [include] Include contract and event details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionReceipt(
      chain: ChainName,
      hash: string,
      include?: 'contract',
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionReceipt200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionReceipt(chain, hash, include, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Receives a pre-signed raw transaction and submits it to the blockchain.
     * @summary Submit signed transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {SignedTransactionSubmission} [signedTransactionSubmission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitSignedTransaction(
      chain: ChainName,
      signedTransactionSubmission?: SignedTransactionSubmission,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.submitSignedTransaction(
        chain,
        signedTransactionSubmission,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns a transaction for sending the native token between addresses.
     * @summary Transfer ETH
     * @param {ChainName} chain The blockchain chain label.
     * @param {PostMethodArgs} [postMethodArgs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transferEth(
      chain: ChainName,
      postMethodArgs?: PostMethodArgs,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferEth200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.transferEth(chain, postMethodArgs, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * ChainsApi - factory interface
 * @export
 */
export const ChainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ChainsApiFp(configuration);
  return {
    /**
     * Returns a block.
     * @summary Get a block
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlock(chain: ChainName, block: string, options?: any): AxiosPromise<GetBlock200Response> {
      return localVarFp.getBlock(chain, block, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the chain status.
     * @summary Get chain status
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChainStatus(chain: ChainName, options?: any): AxiosPromise<GetChainStatus200Response> {
      return localVarFp.getChainStatus(chain, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a transaction.
     * @summary Get transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash Transaction hash.
     * @param {'contract'} [include] Include contract and method call details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(
      chain: ChainName,
      hash: string,
      include?: 'contract',
      options?: any
    ): AxiosPromise<GetTransaction200Response> {
      return localVarFp.getTransaction(chain, hash, include, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
     * @summary Get transaction receipt
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash Transaction hash.
     * @param {'contract'} [include] Include contract and event details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionReceipt(
      chain: ChainName,
      hash: string,
      include?: 'contract',
      options?: any
    ): AxiosPromise<GetTransactionReceipt200Response> {
      return localVarFp
        .getTransactionReceipt(chain, hash, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Receives a pre-signed raw transaction and submits it to the blockchain.
     * @summary Submit signed transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {SignedTransactionSubmission} [signedTransactionSubmission]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitSignedTransaction(
      chain: ChainName,
      signedTransactionSubmission?: SignedTransactionSubmission,
      options?: any
    ): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp
        .submitSignedTransaction(chain, signedTransactionSubmission, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a transaction for sending the native token between addresses.
     * @summary Transfer ETH
     * @param {ChainName} chain The blockchain chain label.
     * @param {PostMethodArgs} [postMethodArgs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferEth(
      chain: ChainName,
      postMethodArgs?: PostMethodArgs,
      options?: any
    ): AxiosPromise<TransferEth200Response> {
      return localVarFp.transferEth(chain, postMethodArgs, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * ChainsApi - interface
 * @export
 * @interface ChainsApi
 */
export interface ChainsApiInterface {
  /**
   * Returns a block.
   * @summary Get a block
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApiInterface
   */
  getBlock(chain: ChainName, block: string, options?: AxiosRequestConfig): AxiosPromise<GetBlock200Response>;

  /**
   * Returns the chain status.
   * @summary Get chain status
   * @param {ChainName} chain The blockchain chain label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApiInterface
   */
  getChainStatus(chain: ChainName, options?: AxiosRequestConfig): AxiosPromise<GetChainStatus200Response>;

  /**
   * Returns a transaction.
   * @summary Get transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} hash Transaction hash.
   * @param {'contract'} [include] Include contract and method call details, if available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApiInterface
   */
  getTransaction(
    chain: ChainName,
    hash: string,
    include?: 'contract',
    options?: AxiosRequestConfig
  ): AxiosPromise<GetTransaction200Response>;

  /**
   * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
   * @summary Get transaction receipt
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} hash Transaction hash.
   * @param {'contract'} [include] Include contract and event details, if available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApiInterface
   */
  getTransactionReceipt(
    chain: ChainName,
    hash: string,
    include?: 'contract',
    options?: AxiosRequestConfig
  ): AxiosPromise<GetTransactionReceipt200Response>;

  /**
   * Receives a pre-signed raw transaction and submits it to the blockchain.
   * @summary Submit signed transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {SignedTransactionSubmission} [signedTransactionSubmission]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApiInterface
   */
  submitSignedTransaction(
    chain: ChainName,
    signedTransactionSubmission?: SignedTransactionSubmission,
    options?: AxiosRequestConfig
  ): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Returns a transaction for sending the native token between addresses.
   * @summary Transfer ETH
   * @param {ChainName} chain The blockchain chain label.
   * @param {PostMethodArgs} [postMethodArgs]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApiInterface
   */
  transferEth(
    chain: ChainName,
    postMethodArgs?: PostMethodArgs,
    options?: AxiosRequestConfig
  ): AxiosPromise<TransferEth200Response>;
}

/**
 * ChainsApi - object-oriented interface
 * @export
 * @class ChainsApi
 * @extends {BaseAPI}
 */
export class ChainsApi extends BaseAPI implements ChainsApiInterface {
  /**
   * Returns a block.
   * @summary Get a block
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApi
   */
  public getBlock(chain: ChainName, block: string, options?: AxiosRequestConfig) {
    return ChainsApiFp(this.configuration)
      .getBlock(chain, block, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the chain status.
   * @summary Get chain status
   * @param {ChainName} chain The blockchain chain label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApi
   */
  public getChainStatus(chain: ChainName, options?: AxiosRequestConfig) {
    return ChainsApiFp(this.configuration)
      .getChainStatus(chain, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transaction.
   * @summary Get transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} hash Transaction hash.
   * @param {'contract'} [include] Include contract and method call details, if available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApi
   */
  public getTransaction(chain: ChainName, hash: string, include?: 'contract', options?: AxiosRequestConfig) {
    return ChainsApiFp(this.configuration)
      .getTransaction(chain, hash, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
   * @summary Get transaction receipt
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} hash Transaction hash.
   * @param {'contract'} [include] Include contract and event details, if available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApi
   */
  public getTransactionReceipt(chain: ChainName, hash: string, include?: 'contract', options?: AxiosRequestConfig) {
    return ChainsApiFp(this.configuration)
      .getTransactionReceipt(chain, hash, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Receives a pre-signed raw transaction and submits it to the blockchain.
   * @summary Submit signed transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {SignedTransactionSubmission} [signedTransactionSubmission]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApi
   */
  public submitSignedTransaction(
    chain: ChainName,
    signedTransactionSubmission?: SignedTransactionSubmission,
    options?: AxiosRequestConfig
  ) {
    return ChainsApiFp(this.configuration)
      .submitSignedTransaction(chain, signedTransactionSubmission, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transaction for sending the native token between addresses.
   * @summary Transfer ETH
   * @param {ChainName} chain The blockchain chain label.
   * @param {PostMethodArgs} [postMethodArgs]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApi
   */
  public transferEth(chain: ChainName, postMethodArgs?: PostMethodArgs, options?: AxiosRequestConfig) {
    return ChainsApiFp(this.configuration)
      .transferEth(chain, postMethodArgs, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
     * @summary Call a contract function
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {string} contract
     * @param {string} method Contract function.
     * @param {PostMethodArgs} [postMethodArgs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callContractFunction: async (
      chain: ChainName,
      addressOrLabel: string,
      contract: string,
      method: string,
      postMethodArgs?: PostMethodArgs,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('callContractFunction', 'chain', chain);
      // verify required parameter 'addressOrLabel' is not null or undefined
      assertParamExists('callContractFunction', 'addressOrLabel', addressOrLabel);
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('callContractFunction', 'contract', contract);
      // verify required parameter 'method' is not null or undefined
      assertParamExists('callContractFunction', 'method', method);
      const localVarPath = `/chains/{chain}/addresses/{address-or-label}/contracts/{contract}/methods/{method}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-label'}}`, encodeURIComponent(String(addressOrLabel)))
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'method'}}`, encodeURIComponent(String(method)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMethodArgs, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds a contract.
     * @summary Create a contract
     * @param {string} contract
     * @param {BaseContract} [baseContract]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContract: async (
      contract: string,
      baseContract?: BaseContract,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('createContract', 'contract', contract);
      const localVarPath = `/contracts/{contract}`.replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseContract, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds multiple contracts.
     * @summary Create multiple contracts
     * @param {Array<BaseContract>} [baseContract]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContracts: async (
      baseContract?: Array<BaseContract>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/contracts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseContract, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a contract and all its versions.
     * @summary Delete a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContract: async (contract: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('deleteContract', 'contract', contract);
      const localVarPath = `/contracts/{contract}`.replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a specific contract version.
     * @summary Delete a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContractVersion: async (
      contract: string,
      version: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('deleteContractVersion', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('deleteContractVersion', 'version', version);
      const localVarPath = `/contracts/{contract}/{version}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a transaction to deploy the given contract to the blockchain.
     * @summary Deploy a contract
     * @param {string} contract
     * @param {PostMethodArgs} [postMethodArgs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployContract: async (
      contract: string,
      postMethodArgs?: PostMethodArgs,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('deployContract', 'contract', contract);
      const localVarPath = `/contracts/{contract}/deploy`.replace(
        `{${'contract'}}`,
        encodeURIComponent(String(contract))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMethodArgs, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a transaction to deploy the given contract version to the blockchain.
     * @summary Deploy a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {PostMethodArgs} [postMethodArgs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployContractVersion: async (
      contract: string,
      version: string,
      postMethodArgs?: PostMethodArgs,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('deployContractVersion', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('deployContractVersion', 'version', version);
      const localVarPath = `/contracts/{contract}/{version}/deploy`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMethodArgs, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the given contract.
     * @summary Get a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContract: async (contract: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getContract', 'contract', contract);
      const localVarPath = `/contracts/{contract}`.replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a specific contract version.
     * @summary Get a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractVersion: async (
      contract: string,
      version: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getContractVersion', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('getContractVersion', 'version', version);
      const localVarPath = `/contracts/{contract}/{version}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the versions of a contract.
     * @summary Get all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractVersions: async (contract: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getContractVersions', 'contract', contract);
      const localVarPath = `/contracts/{contract}/all`.replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the event monitor status for a given address and contract.
     * @summary Get event monitor status
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventMonitorStatus: async (
      chain: ChainName,
      addressOrLabel: string,
      contract: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getEventMonitorStatus', 'chain', chain);
      // verify required parameter 'addressOrLabel' is not null or undefined
      assertParamExists('getEventMonitorStatus', 'addressOrLabel', addressOrLabel);
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getEventMonitorStatus', 'contract', contract);
      const localVarPath = `/chains/{chain}/addresses/{address-or-label}/contracts/{contract}/status`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-label'}}`, encodeURIComponent(String(addressOrLabel)))
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the type conversion options for a given contract and event signature.
     * @summary Get event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventTypeConversions: async (
      contract: string,
      version: string,
      event: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getEventTypeConversions', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('getEventTypeConversions', 'version', version);
      // verify required parameter 'event' is not null or undefined
      assertParamExists('getEventTypeConversions', 'event', event);
      const localVarPath = `/contracts/{contract}/{version}/events/{event}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'event'}}`, encodeURIComponent(String(event)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the type conversion options for a given contract and function signature.
     * @summary Get function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctionTypeConversions: async (
      contract: string,
      version: string,
      method: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getFunctionTypeConversions', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('getFunctionTypeConversions', 'version', version);
      // verify required parameter 'method' is not null or undefined
      assertParamExists('getFunctionTypeConversions', 'method', method);
      const localVarPath = `/contracts/{contract}/{version}/methods/{method}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'method'}}`, encodeURIComponent(String(method)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Links an address to a contract.
     * @summary Link address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {LinkAddressContractRequest} [linkAddressContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAddressContract: async (
      chain: ChainName,
      addressOrLabel: string,
      linkAddressContractRequest?: LinkAddressContractRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('linkAddressContract', 'chain', chain);
      // verify required parameter 'addressOrLabel' is not null or undefined
      assertParamExists('linkAddressContract', 'addressOrLabel', addressOrLabel);
      const localVarPath = `/chains/{chain}/addresses/{address-or-label}/contracts`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-label'}}`, encodeURIComponent(String(addressOrLabel)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        linkAddressContractRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of the versions of a contract.
     * @summary List all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContractVersions: async (contract: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('listContractVersions', 'contract', contract);
      const localVarPath = `/contracts/{contract}/versions`.replace(
        `{${'contract'}}`,
        encodeURIComponent(String(contract))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of contracts.
     * @summary List contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContracts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/contracts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sets the type conversion options for a given contract and event signature.
     * @summary Set event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {ContractEventOptions} [contractEventOptions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEventTypeConversions: async (
      contract: string,
      version: string,
      event: string,
      contractEventOptions?: ContractEventOptions,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('setEventTypeConversions', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('setEventTypeConversions', 'version', version);
      // verify required parameter 'event' is not null or undefined
      assertParamExists('setEventTypeConversions', 'event', event);
      const localVarPath = `/contracts/{contract}/{version}/events/{event}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'event'}}`, encodeURIComponent(String(event)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(contractEventOptions, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sets the type conversion options for a given contract and function signature.
     * @summary Set function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {ContractMethodOptions} [contractMethodOptions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFunctionTypeConversions: async (
      contract: string,
      version: string,
      method: string,
      contractMethodOptions?: ContractMethodOptions,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('setFunctionTypeConversions', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('setFunctionTypeConversions', 'version', version);
      // verify required parameter 'method' is not null or undefined
      assertParamExists('setFunctionTypeConversions', 'method', method);
      const localVarPath = `/contracts/{contract}/{version}/methods/{method}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'method'}}`, encodeURIComponent(String(method)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(contractMethodOptions, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unlinks an address from a contract.
     * @summary Unlink address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkAddressContract: async (
      chain: ChainName,
      addressOrLabel: string,
      contract: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('unlinkAddressContract', 'chain', chain);
      // verify required parameter 'addressOrLabel' is not null or undefined
      assertParamExists('unlinkAddressContract', 'addressOrLabel', addressOrLabel);
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('unlinkAddressContract', 'contract', contract);
      const localVarPath = `/chains/{chain}/addresses/{address-or-label}/contracts/{contract}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-label'}}`, encodeURIComponent(String(addressOrLabel)))
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration);
  return {
    /**
     * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
     * @summary Call a contract function
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {string} contract
     * @param {string} method Contract function.
     * @param {PostMethodArgs} [postMethodArgs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callContractFunction(
      chain: ChainName,
      addressOrLabel: string,
      contract: string,
      method: string,
      postMethodArgs?: PostMethodArgs,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CallContractFunction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.callContractFunction(
        chain,
        addressOrLabel,
        contract,
        method,
        postMethodArgs,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Adds a contract.
     * @summary Create a contract
     * @param {string} contract
     * @param {BaseContract} [baseContract]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createContract(
      contract: string,
      baseContract?: BaseContract,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createContract(contract, baseContract, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Adds multiple contracts.
     * @summary Create multiple contracts
     * @param {Array<BaseContract>} [baseContract]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createContracts(
      baseContract?: Array<BaseContract>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createContracts(baseContract, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Deletes a contract and all its versions.
     * @summary Delete a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteContract(
      contract: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContract(contract, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Deletes a specific contract version.
     * @summary Delete a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteContractVersion(
      contract: string,
      version: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContractVersion(contract, version, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns a transaction to deploy the given contract to the blockchain.
     * @summary Deploy a contract
     * @param {string} contract
     * @param {PostMethodArgs} [postMethodArgs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deployContract(
      contract: string,
      postMethodArgs?: PostMethodArgs,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deployContract(contract, postMethodArgs, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns a transaction to deploy the given contract version to the blockchain.
     * @summary Deploy a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {PostMethodArgs} [postMethodArgs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deployContractVersion(
      contract: string,
      version: string,
      postMethodArgs?: PostMethodArgs,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deployContractVersion(
        contract,
        version,
        postMethodArgs,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns the given contract.
     * @summary Get a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContract(
      contract: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContract(contract, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns a specific contract version.
     * @summary Get a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContractVersion(
      contract: string,
      version: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContractVersion(contract, version, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns all the versions of a contract.
     * @summary Get all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContractVersions(
      contract: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContractVersions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContractVersions(contract, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns the event monitor status for a given address and contract.
     * @summary Get event monitor status
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventMonitorStatus(
      chain: ChainName,
      addressOrLabel: string,
      contract: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventMonitorStatus200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventMonitorStatus(
        chain,
        addressOrLabel,
        contract,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns the type conversion options for a given contract and event signature.
     * @summary Get event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventTypeConversions(
      contract: string,
      version: string,
      event: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventTypeConversions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventTypeConversions(
        contract,
        version,
        event,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns the type conversion options for a given contract and function signature.
     * @summary Get function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFunctionTypeConversions(
      contract: string,
      version: string,
      method: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFunctionTypeConversions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFunctionTypeConversions(
        contract,
        version,
        method,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Links an address to a contract.
     * @summary Link address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {LinkAddressContractRequest} [linkAddressContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async linkAddressContract(
      chain: ChainName,
      addressOrLabel: string,
      linkAddressContractRequest?: LinkAddressContractRequest,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetAddress201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.linkAddressContract(
        chain,
        addressOrLabel,
        linkAddressContractRequest,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns a list of the versions of a contract.
     * @summary List all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listContractVersions(
      contract: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContractVersions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listContractVersions(contract, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns a list of contracts.
     * @summary List contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listContracts(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContracts200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listContracts(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Sets the type conversion options for a given contract and event signature.
     * @summary Set event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {ContractEventOptions} [contractEventOptions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setEventTypeConversions(
      contract: string,
      version: string,
      event: string,
      contractEventOptions?: ContractEventOptions,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setEventTypeConversions(
        contract,
        version,
        event,
        contractEventOptions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Sets the type conversion options for a given contract and function signature.
     * @summary Set function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {ContractMethodOptions} [contractMethodOptions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setFunctionTypeConversions(
      contract: string,
      version: string,
      method: string,
      contractMethodOptions?: ContractMethodOptions,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setFunctionTypeConversions(
        contract,
        version,
        method,
        contractMethodOptions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Unlinks an address from a contract.
     * @summary Unlink address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unlinkAddressContract(
      chain: ChainName,
      addressOrLabel: string,
      contract: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetAddress201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkAddressContract(
        chain,
        addressOrLabel,
        contract,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ContractsApiFp(configuration);
  return {
    /**
     * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
     * @summary Call a contract function
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {string} contract
     * @param {string} method Contract function.
     * @param {PostMethodArgs} [postMethodArgs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callContractFunction(
      chain: ChainName,
      addressOrLabel: string,
      contract: string,
      method: string,
      postMethodArgs?: PostMethodArgs,
      options?: any
    ): AxiosPromise<CallContractFunction200Response> {
      return localVarFp
        .callContractFunction(chain, addressOrLabel, contract, method, postMethodArgs, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds a contract.
     * @summary Create a contract
     * @param {string} contract
     * @param {BaseContract} [baseContract]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContract(contract: string, baseContract?: BaseContract, options?: any): AxiosPromise<GetContract200Response> {
      return localVarFp.createContract(contract, baseContract, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds multiple contracts.
     * @summary Create multiple contracts
     * @param {Array<BaseContract>} [baseContract]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContracts(
      baseContract?: Array<BaseContract>,
      options?: any
    ): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp.createContracts(baseContract, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a contract and all its versions.
     * @summary Delete a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContract(contract: string, options?: any): AxiosPromise<BaseResponse> {
      return localVarFp.deleteContract(contract, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a specific contract version.
     * @summary Delete a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContractVersion(contract: string, version: string, options?: any): AxiosPromise<BaseResponse> {
      return localVarFp.deleteContractVersion(contract, version, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a transaction to deploy the given contract to the blockchain.
     * @summary Deploy a contract
     * @param {string} contract
     * @param {PostMethodArgs} [postMethodArgs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployContract(
      contract: string,
      postMethodArgs?: PostMethodArgs,
      options?: any
    ): AxiosPromise<DeployContract200Response> {
      return localVarFp.deployContract(contract, postMethodArgs, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a transaction to deploy the given contract version to the blockchain.
     * @summary Deploy a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {PostMethodArgs} [postMethodArgs]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployContractVersion(
      contract: string,
      version: string,
      postMethodArgs?: PostMethodArgs,
      options?: any
    ): AxiosPromise<DeployContract200Response> {
      return localVarFp
        .deployContractVersion(contract, version, postMethodArgs, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the given contract.
     * @summary Get a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContract(contract: string, options?: any): AxiosPromise<GetContract200Response> {
      return localVarFp.getContract(contract, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a specific contract version.
     * @summary Get a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractVersion(contract: string, version: string, options?: any): AxiosPromise<GetContract200Response> {
      return localVarFp.getContractVersion(contract, version, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the versions of a contract.
     * @summary Get all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractVersions(contract: string, options?: any): AxiosPromise<GetContractVersions200Response> {
      return localVarFp.getContractVersions(contract, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the event monitor status for a given address and contract.
     * @summary Get event monitor status
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventMonitorStatus(
      chain: ChainName,
      addressOrLabel: string,
      contract: string,
      options?: any
    ): AxiosPromise<GetEventMonitorStatus200Response> {
      return localVarFp
        .getEventMonitorStatus(chain, addressOrLabel, contract, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the type conversion options for a given contract and event signature.
     * @summary Get event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventTypeConversions(
      contract: string,
      version: string,
      event: string,
      options?: any
    ): AxiosPromise<GetEventTypeConversions200Response> {
      return localVarFp
        .getEventTypeConversions(contract, version, event, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the type conversion options for a given contract and function signature.
     * @summary Get function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctionTypeConversions(
      contract: string,
      version: string,
      method: string,
      options?: any
    ): AxiosPromise<GetFunctionTypeConversions200Response> {
      return localVarFp
        .getFunctionTypeConversions(contract, version, method, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Links an address to a contract.
     * @summary Link address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {LinkAddressContractRequest} [linkAddressContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAddressContract(
      chain: ChainName,
      addressOrLabel: string,
      linkAddressContractRequest?: LinkAddressContractRequest,
      options?: any
    ): AxiosPromise<SetAddress201Response> {
      return localVarFp
        .linkAddressContract(chain, addressOrLabel, linkAddressContractRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of the versions of a contract.
     * @summary List all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContractVersions(contract: string, options?: any): AxiosPromise<ListContractVersions200Response> {
      return localVarFp.listContractVersions(contract, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of contracts.
     * @summary List contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContracts(options?: any): AxiosPromise<ListContracts200Response> {
      return localVarFp.listContracts(options).then((request) => request(axios, basePath));
    },
    /**
     * Sets the type conversion options for a given contract and event signature.
     * @summary Set event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {ContractEventOptions} [contractEventOptions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEventTypeConversions(
      contract: string,
      version: string,
      event: string,
      contractEventOptions?: ContractEventOptions,
      options?: any
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setEventTypeConversions(contract, version, event, contractEventOptions, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sets the type conversion options for a given contract and function signature.
     * @summary Set function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {ContractMethodOptions} [contractMethodOptions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFunctionTypeConversions(
      contract: string,
      version: string,
      method: string,
      contractMethodOptions?: ContractMethodOptions,
      options?: any
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setFunctionTypeConversions(contract, version, method, contractMethodOptions, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Unlinks an address from a contract.
     * @summary Unlink address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrLabel An address or the label of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkAddressContract(
      chain: ChainName,
      addressOrLabel: string,
      contract: string,
      options?: any
    ): AxiosPromise<SetAddress201Response> {
      return localVarFp
        .unlinkAddressContract(chain, addressOrLabel, contract, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * ContractsApi - interface
 * @export
 * @interface ContractsApi
 */
export interface ContractsApiInterface {
  /**
   * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
   * @summary Call a contract function
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrLabel An address or the label of an address.
   * @param {string} contract
   * @param {string} method Contract function.
   * @param {PostMethodArgs} [postMethodArgs]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  callContractFunction(
    chain: ChainName,
    addressOrLabel: string,
    contract: string,
    method: string,
    postMethodArgs?: PostMethodArgs,
    options?: AxiosRequestConfig
  ): AxiosPromise<CallContractFunction200Response>;

  /**
   * Adds a contract.
   * @summary Create a contract
   * @param {string} contract
   * @param {BaseContract} [baseContract]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  createContract(
    contract: string,
    baseContract?: BaseContract,
    options?: AxiosRequestConfig
  ): AxiosPromise<GetContract200Response>;

  /**
   * Adds multiple contracts.
   * @summary Create multiple contracts
   * @param {Array<BaseContract>} [baseContract]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  createContracts(
    baseContract?: Array<BaseContract>,
    options?: AxiosRequestConfig
  ): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Deletes a contract and all its versions.
   * @summary Delete a contract
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  deleteContract(contract: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Deletes a specific contract version.
   * @summary Delete a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  deleteContractVersion(contract: string, version: string, options?: AxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Returns a transaction to deploy the given contract to the blockchain.
   * @summary Deploy a contract
   * @param {string} contract
   * @param {PostMethodArgs} [postMethodArgs]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  deployContract(
    contract: string,
    postMethodArgs?: PostMethodArgs,
    options?: AxiosRequestConfig
  ): AxiosPromise<DeployContract200Response>;

  /**
   * Returns a transaction to deploy the given contract version to the blockchain.
   * @summary Deploy a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {PostMethodArgs} [postMethodArgs]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  deployContractVersion(
    contract: string,
    version: string,
    postMethodArgs?: PostMethodArgs,
    options?: AxiosRequestConfig
  ): AxiosPromise<DeployContract200Response>;

  /**
   * Returns the given contract.
   * @summary Get a contract
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  getContract(contract: string, options?: AxiosRequestConfig): AxiosPromise<GetContract200Response>;

  /**
   * Returns a specific contract version.
   * @summary Get a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  getContractVersion(
    contract: string,
    version: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<GetContract200Response>;

  /**
   * Returns all the versions of a contract.
   * @summary Get all contract versions
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  getContractVersions(contract: string, options?: AxiosRequestConfig): AxiosPromise<GetContractVersions200Response>;

  /**
   * Returns the event monitor status for a given address and contract.
   * @summary Get event monitor status
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrLabel An address or the label of an address.
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  getEventMonitorStatus(
    chain: ChainName,
    addressOrLabel: string,
    contract: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<GetEventMonitorStatus200Response>;

  /**
   * Returns the type conversion options for a given contract and event signature.
   * @summary Get event type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} event Contract Event.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  getEventTypeConversions(
    contract: string,
    version: string,
    event: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<GetEventTypeConversions200Response>;

  /**
   * Returns the type conversion options for a given contract and function signature.
   * @summary Get function type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} method Contract function.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  getFunctionTypeConversions(
    contract: string,
    version: string,
    method: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<GetFunctionTypeConversions200Response>;

  /**
   * Links an address to a contract.
   * @summary Link address and contract
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrLabel An address or the label of an address.
   * @param {LinkAddressContractRequest} [linkAddressContractRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  linkAddressContract(
    chain: ChainName,
    addressOrLabel: string,
    linkAddressContractRequest?: LinkAddressContractRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<SetAddress201Response>;

  /**
   * Returns a list of the versions of a contract.
   * @summary List all contract versions
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  listContractVersions(contract: string, options?: AxiosRequestConfig): AxiosPromise<ListContractVersions200Response>;

  /**
   * Returns a list of contracts.
   * @summary List contracts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  listContracts(options?: AxiosRequestConfig): AxiosPromise<ListContracts200Response>;

  /**
   * Sets the type conversion options for a given contract and event signature.
   * @summary Set event type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} event Contract Event.
   * @param {ContractEventOptions} [contractEventOptions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  setEventTypeConversions(
    contract: string,
    version: string,
    event: string,
    contractEventOptions?: ContractEventOptions,
    options?: AxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Sets the type conversion options for a given contract and function signature.
   * @summary Set function type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} method Contract function.
   * @param {ContractMethodOptions} [contractMethodOptions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  setFunctionTypeConversions(
    contract: string,
    version: string,
    method: string,
    contractMethodOptions?: ContractMethodOptions,
    options?: AxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Unlinks an address from a contract.
   * @summary Unlink address and contract
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrLabel An address or the label of an address.
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  unlinkAddressContract(
    chain: ChainName,
    addressOrLabel: string,
    contract: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<SetAddress201Response>;
}

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI implements ContractsApiInterface {
  /**
   * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
   * @summary Call a contract function
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrLabel An address or the label of an address.
   * @param {string} contract
   * @param {string} method Contract function.
   * @param {PostMethodArgs} [postMethodArgs]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public callContractFunction(
    chain: ChainName,
    addressOrLabel: string,
    contract: string,
    method: string,
    postMethodArgs?: PostMethodArgs,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .callContractFunction(chain, addressOrLabel, contract, method, postMethodArgs, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a contract.
   * @summary Create a contract
   * @param {string} contract
   * @param {BaseContract} [baseContract]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public createContract(contract: string, baseContract?: BaseContract, options?: AxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .createContract(contract, baseContract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds multiple contracts.
   * @summary Create multiple contracts
   * @param {Array<BaseContract>} [baseContract]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public createContracts(baseContract?: Array<BaseContract>, options?: AxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .createContracts(baseContract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a contract and all its versions.
   * @summary Delete a contract
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public deleteContract(contract: string, options?: AxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .deleteContract(contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a specific contract version.
   * @summary Delete a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public deleteContractVersion(contract: string, version: string, options?: AxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .deleteContractVersion(contract, version, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transaction to deploy the given contract to the blockchain.
   * @summary Deploy a contract
   * @param {string} contract
   * @param {PostMethodArgs} [postMethodArgs]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public deployContract(contract: string, postMethodArgs?: PostMethodArgs, options?: AxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .deployContract(contract, postMethodArgs, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transaction to deploy the given contract version to the blockchain.
   * @summary Deploy a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {PostMethodArgs} [postMethodArgs]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public deployContractVersion(
    contract: string,
    version: string,
    postMethodArgs?: PostMethodArgs,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .deployContractVersion(contract, version, postMethodArgs, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the given contract.
   * @summary Get a contract
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getContract(contract: string, options?: AxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getContract(contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a specific contract version.
   * @summary Get a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getContractVersion(contract: string, version: string, options?: AxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getContractVersion(contract, version, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the versions of a contract.
   * @summary Get all contract versions
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getContractVersions(contract: string, options?: AxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getContractVersions(contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the event monitor status for a given address and contract.
   * @summary Get event monitor status
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrLabel An address or the label of an address.
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getEventMonitorStatus(
    chain: ChainName,
    addressOrLabel: string,
    contract: string,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getEventMonitorStatus(chain, addressOrLabel, contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the type conversion options for a given contract and event signature.
   * @summary Get event type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} event Contract Event.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getEventTypeConversions(contract: string, version: string, event: string, options?: AxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getEventTypeConversions(contract, version, event, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the type conversion options for a given contract and function signature.
   * @summary Get function type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} method Contract function.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getFunctionTypeConversions(contract: string, version: string, method: string, options?: AxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getFunctionTypeConversions(contract, version, method, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Links an address to a contract.
   * @summary Link address and contract
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrLabel An address or the label of an address.
   * @param {LinkAddressContractRequest} [linkAddressContractRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public linkAddressContract(
    chain: ChainName,
    addressOrLabel: string,
    linkAddressContractRequest?: LinkAddressContractRequest,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .linkAddressContract(chain, addressOrLabel, linkAddressContractRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of the versions of a contract.
   * @summary List all contract versions
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public listContractVersions(contract: string, options?: AxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .listContractVersions(contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of contracts.
   * @summary List contracts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public listContracts(options?: AxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .listContracts(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the type conversion options for a given contract and event signature.
   * @summary Set event type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} event Contract Event.
   * @param {ContractEventOptions} [contractEventOptions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public setEventTypeConversions(
    contract: string,
    version: string,
    event: string,
    contractEventOptions?: ContractEventOptions,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .setEventTypeConversions(contract, version, event, contractEventOptions, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the type conversion options for a given contract and function signature.
   * @summary Set function type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} method Contract function.
   * @param {ContractMethodOptions} [contractMethodOptions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public setFunctionTypeConversions(
    contract: string,
    version: string,
    method: string,
    contractMethodOptions?: ContractMethodOptions,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .setFunctionTypeConversions(contract, version, method, contractMethodOptions, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Unlinks an address from a contract.
   * @summary Unlink address and contract
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrLabel An address or the label of an address.
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public unlinkAddressContract(
    chain: ChainName,
    addressOrLabel: string,
    contract: string,
    options?: AxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .unlinkAddressContract(chain, addressOrLabel, contract, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EventQueriesApi - axios parameter creator
 * @export
 */
export const EventQueriesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns the record count of the given saved event query.
     * @summary Count event query records
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countEventQueryRecords: async (eventQuery: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('countEventQueryRecords', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}/count`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the given saved event query.
     * @summary Delete event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventQuery: async (eventQuery: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('deleteEventQuery', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Executes an arbitrary event query.
     * @summary Execute arbitrary event query
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {EventQuery} [eventQuery]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeArbitraryEventQuery: async (
      offset?: number,
      limit?: number,
      eventQuery?: EventQuery,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/queries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(eventQuery, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Executes the given saved event query.
     * @summary Execute event query
     * @param {string} eventQuery An event query label.
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeEventQuery: async (
      eventQuery: string,
      offset?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('executeEventQuery', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}/results`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the given saved event query.
     * @summary Get event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventQuery: async (eventQuery: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('getEventQuery', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of saved event queries.
     * @summary List event queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventQueries: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/queries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates or updates the given saved event query.
     * @summary Create or update event query
     * @param {string} eventQuery An event query label.
     * @param {EventQuery} [eventQuery2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEventQuery: async (
      eventQuery: string,
      eventQuery2?: EventQuery,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('setEventQuery', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(eventQuery2, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * EventQueriesApi - functional programming interface
 * @export
 */
export const EventQueriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EventQueriesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the record count of the given saved event query.
     * @summary Count event query records
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countEventQueryRecords(
      eventQuery: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountEventQueryRecords200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countEventQueryRecords(eventQuery, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Deletes the given saved event query.
     * @summary Delete event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEventQuery(
      eventQuery: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventQuery(eventQuery, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Executes an arbitrary event query.
     * @summary Execute arbitrary event query
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {EventQuery} [eventQuery]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeArbitraryEventQuery(
      offset?: number,
      limit?: number,
      eventQuery?: EventQuery,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteArbitraryEventQuery200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeArbitraryEventQuery(
        offset,
        limit,
        eventQuery,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Executes the given saved event query.
     * @summary Execute event query
     * @param {string} eventQuery An event query label.
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeEventQuery(
      eventQuery: string,
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteArbitraryEventQuery200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeEventQuery(eventQuery, offset, limit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns the given saved event query.
     * @summary Get event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventQuery(
      eventQuery: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventQuery200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventQuery(eventQuery, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns a list of saved event queries.
     * @summary List event queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEventQueries(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEventQueries200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listEventQueries(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Creates or updates the given saved event query.
     * @summary Create or update event query
     * @param {string} eventQuery An event query label.
     * @param {EventQuery} [eventQuery2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setEventQuery(
      eventQuery: string,
      eventQuery2?: EventQuery,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setEventQuery(eventQuery, eventQuery2, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * EventQueriesApi - factory interface
 * @export
 */
export const EventQueriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EventQueriesApiFp(configuration);
  return {
    /**
     * Returns the record count of the given saved event query.
     * @summary Count event query records
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countEventQueryRecords(eventQuery: string, options?: any): AxiosPromise<CountEventQueryRecords200Response> {
      return localVarFp.countEventQueryRecords(eventQuery, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the given saved event query.
     * @summary Delete event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventQuery(eventQuery: string, options?: any): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp.deleteEventQuery(eventQuery, options).then((request) => request(axios, basePath));
    },
    /**
     * Executes an arbitrary event query.
     * @summary Execute arbitrary event query
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {EventQuery} [eventQuery]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeArbitraryEventQuery(
      offset?: number,
      limit?: number,
      eventQuery?: EventQuery,
      options?: any
    ): AxiosPromise<ExecuteArbitraryEventQuery200Response> {
      return localVarFp
        .executeArbitraryEventQuery(offset, limit, eventQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Executes the given saved event query.
     * @summary Execute event query
     * @param {string} eventQuery An event query label.
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeEventQuery(
      eventQuery: string,
      offset?: number,
      limit?: number,
      options?: any
    ): AxiosPromise<ExecuteArbitraryEventQuery200Response> {
      return localVarFp
        .executeEventQuery(eventQuery, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the given saved event query.
     * @summary Get event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventQuery(eventQuery: string, options?: any): AxiosPromise<GetEventQuery200Response> {
      return localVarFp.getEventQuery(eventQuery, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of saved event queries.
     * @summary List event queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventQueries(options?: any): AxiosPromise<ListEventQueries200Response> {
      return localVarFp.listEventQueries(options).then((request) => request(axios, basePath));
    },
    /**
     * Creates or updates the given saved event query.
     * @summary Create or update event query
     * @param {string} eventQuery An event query label.
     * @param {EventQuery} [eventQuery2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEventQuery(
      eventQuery: string,
      eventQuery2?: EventQuery,
      options?: any
    ): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp.setEventQuery(eventQuery, eventQuery2, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * EventQueriesApi - interface
 * @export
 * @interface EventQueriesApi
 */
export interface EventQueriesApiInterface {
  /**
   * Returns the record count of the given saved event query.
   * @summary Count event query records
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  countEventQueryRecords(
    eventQuery: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<CountEventQueryRecords200Response>;

  /**
   * Deletes the given saved event query.
   * @summary Delete event query
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  deleteEventQuery(eventQuery: string, options?: AxiosRequestConfig): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Executes an arbitrary event query.
   * @summary Execute arbitrary event query
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {EventQuery} [eventQuery]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  executeArbitraryEventQuery(
    offset?: number,
    limit?: number,
    eventQuery?: EventQuery,
    options?: AxiosRequestConfig
  ): AxiosPromise<ExecuteArbitraryEventQuery200Response>;

  /**
   * Executes the given saved event query.
   * @summary Execute event query
   * @param {string} eventQuery An event query label.
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  executeEventQuery(
    eventQuery: string,
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig
  ): AxiosPromise<ExecuteArbitraryEventQuery200Response>;

  /**
   * Returns the given saved event query.
   * @summary Get event query
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  getEventQuery(eventQuery: string, options?: AxiosRequestConfig): AxiosPromise<GetEventQuery200Response>;

  /**
   * Returns a list of saved event queries.
   * @summary List event queries
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  listEventQueries(options?: AxiosRequestConfig): AxiosPromise<ListEventQueries200Response>;

  /**
   * Creates or updates the given saved event query.
   * @summary Create or update event query
   * @param {string} eventQuery An event query label.
   * @param {EventQuery} [eventQuery2]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  setEventQuery(
    eventQuery: string,
    eventQuery2?: EventQuery,
    options?: AxiosRequestConfig
  ): AxiosPromise<SubmitSignedTransaction200Response>;
}

/**
 * EventQueriesApi - object-oriented interface
 * @export
 * @class EventQueriesApi
 * @extends {BaseAPI}
 */
export class EventQueriesApi extends BaseAPI implements EventQueriesApiInterface {
  /**
   * Returns the record count of the given saved event query.
   * @summary Count event query records
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public countEventQueryRecords(eventQuery: string, options?: AxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .countEventQueryRecords(eventQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the given saved event query.
   * @summary Delete event query
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public deleteEventQuery(eventQuery: string, options?: AxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .deleteEventQuery(eventQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Executes an arbitrary event query.
   * @summary Execute arbitrary event query
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {EventQuery} [eventQuery]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public executeArbitraryEventQuery(
    offset?: number,
    limit?: number,
    eventQuery?: EventQuery,
    options?: AxiosRequestConfig
  ) {
    return EventQueriesApiFp(this.configuration)
      .executeArbitraryEventQuery(offset, limit, eventQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Executes the given saved event query.
   * @summary Execute event query
   * @param {string} eventQuery An event query label.
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public executeEventQuery(eventQuery: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .executeEventQuery(eventQuery, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the given saved event query.
   * @summary Get event query
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public getEventQuery(eventQuery: string, options?: AxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .getEventQuery(eventQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of saved event queries.
   * @summary List event queries
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public listEventQueries(options?: AxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .listEventQueries(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates or updates the given saved event query.
   * @summary Create or update event query
   * @param {string} eventQuery An event query label.
   * @param {EventQuery} [eventQuery2]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public setEventQuery(eventQuery: string, eventQuery2?: EventQuery, options?: AxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .setEventQuery(eventQuery, eventQuery2, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Gets all events stored in the database.
     * @summary Get all events
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllEvents: async (
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/events`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (blockHash !== undefined) {
        localVarQueryParameter['block_hash'] = blockHash;
      }

      if (blockNumber !== undefined) {
        localVarQueryParameter['block_number'] = blockNumber;
      }

      if (txIndexInBlock !== undefined) {
        localVarQueryParameter['tx_index_in_block'] = txIndexInBlock;
      }

      if (eventIndexInLog !== undefined) {
        localVarQueryParameter['event_index_in_log'] = eventIndexInLog;
      }

      if (txHash !== undefined) {
        localVarQueryParameter['tx_hash'] = txHash;
      }

      if (fromConstructor !== undefined) {
        localVarQueryParameter['from_constructor'] = fromConstructor;
      }

      if (chain !== undefined) {
        localVarQueryParameter['chain'] = chain;
      }

      if (contractAddress !== undefined) {
        localVarQueryParameter['contract_address'] = contractAddress;
      }

      if (contractLabel !== undefined) {
        localVarQueryParameter['contract_label'] = contractLabel;
      }

      if (eventSignature !== undefined) {
        localVarQueryParameter['event_signature'] = eventSignature;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets the number of events stored in the database.
     * @summary Get event count
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventCount: async (
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/events/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (blockHash !== undefined) {
        localVarQueryParameter['block_hash'] = blockHash;
      }

      if (blockNumber !== undefined) {
        localVarQueryParameter['block_number'] = blockNumber;
      }

      if (txIndexInBlock !== undefined) {
        localVarQueryParameter['tx_index_in_block'] = txIndexInBlock;
      }

      if (eventIndexInLog !== undefined) {
        localVarQueryParameter['event_index_in_log'] = eventIndexInLog;
      }

      if (txHash !== undefined) {
        localVarQueryParameter['tx_hash'] = txHash;
      }

      if (fromConstructor !== undefined) {
        localVarQueryParameter['from_constructor'] = fromConstructor;
      }

      if (chain !== undefined) {
        localVarQueryParameter['chain'] = chain;
      }

      if (contractAddress !== undefined) {
        localVarQueryParameter['contract_address'] = contractAddress;
      }

      if (contractLabel !== undefined) {
        localVarQueryParameter['contract_label'] = contractLabel;
      }

      if (eventSignature !== undefined) {
        localVarQueryParameter['event_signature'] = eventSignature;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration);
  return {
    /**
     * Gets all events stored in the database.
     * @summary Get all events
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllEvents(
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllEvents200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEvents(
        blockHash,
        blockNumber,
        txIndexInBlock,
        eventIndexInLog,
        txHash,
        fromConstructor,
        chain,
        contractAddress,
        contractLabel,
        eventSignature,
        limit,
        offset,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Gets the number of events stored in the database.
     * @summary Get event count
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventCount(
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventCount200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventCount(
        blockHash,
        blockNumber,
        txIndexInBlock,
        eventIndexInLog,
        txHash,
        fromConstructor,
        chain,
        contractAddress,
        contractLabel,
        eventSignature,
        limit,
        offset,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = EventsApiFp(configuration);
  return {
    /**
     * Gets all events stored in the database.
     * @summary Get all events
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllEvents(
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options?: any
    ): AxiosPromise<GetAllEvents200Response> {
      return localVarFp
        .getAllEvents(
          blockHash,
          blockNumber,
          txIndexInBlock,
          eventIndexInLog,
          txHash,
          fromConstructor,
          chain,
          contractAddress,
          contractLabel,
          eventSignature,
          limit,
          offset,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets the number of events stored in the database.
     * @summary Get event count
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventCount(
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options?: any
    ): AxiosPromise<GetEventCount200Response> {
      return localVarFp
        .getEventCount(
          blockHash,
          blockNumber,
          txIndexInBlock,
          eventIndexInLog,
          txHash,
          fromConstructor,
          chain,
          contractAddress,
          contractLabel,
          eventSignature,
          limit,
          offset,
          options
        )
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * EventsApi - interface
 * @export
 * @interface EventsApi
 */
export interface EventsApiInterface {
  /**
   * Gets all events stored in the database.
   * @summary Get all events
   * @param {string} [blockHash] Filter events by a block hash.
   * @param {number} [blockNumber] Filter events by a block number.
   * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
   * @param {number} [eventIndexInLog] Filter events by index in the log.
   * @param {string} [txHash] Filter events by a transaction hash.
   * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
   * @param {ChainName} [chain] Filter events by a chain name.
   * @param {string} [contractAddress] Filter events by a contract address.
   * @param {string} [contractLabel] Filter events by a contract label.
   * @param {string} [eventSignature] Filter events by the signature.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApiInterface
   */
  getAllEvents(
    blockHash?: string,
    blockNumber?: number,
    txIndexInBlock?: number,
    eventIndexInLog?: number,
    txHash?: string,
    fromConstructor?: boolean,
    chain?: ChainName,
    contractAddress?: string,
    contractLabel?: string,
    eventSignature?: string,
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig
  ): AxiosPromise<GetAllEvents200Response>;

  /**
   * Gets the number of events stored in the database.
   * @summary Get event count
   * @param {string} [blockHash] Filter events by a block hash.
   * @param {number} [blockNumber] Filter events by a block number.
   * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
   * @param {number} [eventIndexInLog] Filter events by index in the log.
   * @param {string} [txHash] Filter events by a transaction hash.
   * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
   * @param {ChainName} [chain] Filter events by a chain name.
   * @param {string} [contractAddress] Filter events by a contract address.
   * @param {string} [contractLabel] Filter events by a contract label.
   * @param {string} [eventSignature] Filter events by the signature.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApiInterface
   */
  getEventCount(
    blockHash?: string,
    blockNumber?: number,
    txIndexInBlock?: number,
    eventIndexInLog?: number,
    txHash?: string,
    fromConstructor?: boolean,
    chain?: ChainName,
    contractAddress?: string,
    contractLabel?: string,
    eventSignature?: string,
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig
  ): AxiosPromise<GetEventCount200Response>;
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI implements EventsApiInterface {
  /**
   * Gets all events stored in the database.
   * @summary Get all events
   * @param {string} [blockHash] Filter events by a block hash.
   * @param {number} [blockNumber] Filter events by a block number.
   * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
   * @param {number} [eventIndexInLog] Filter events by index in the log.
   * @param {string} [txHash] Filter events by a transaction hash.
   * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
   * @param {ChainName} [chain] Filter events by a chain name.
   * @param {string} [contractAddress] Filter events by a contract address.
   * @param {string} [contractLabel] Filter events by a contract label.
   * @param {string} [eventSignature] Filter events by the signature.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApi
   */
  public getAllEvents(
    blockHash?: string,
    blockNumber?: number,
    txIndexInBlock?: number,
    eventIndexInLog?: number,
    txHash?: string,
    fromConstructor?: boolean,
    chain?: ChainName,
    contractAddress?: string,
    contractLabel?: string,
    eventSignature?: string,
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig
  ) {
    return EventsApiFp(this.configuration)
      .getAllEvents(
        blockHash,
        blockNumber,
        txIndexInBlock,
        eventIndexInLog,
        txHash,
        fromConstructor,
        chain,
        contractAddress,
        contractLabel,
        eventSignature,
        limit,
        offset,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets the number of events stored in the database.
   * @summary Get event count
   * @param {string} [blockHash] Filter events by a block hash.
   * @param {number} [blockNumber] Filter events by a block number.
   * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
   * @param {number} [eventIndexInLog] Filter events by index in the log.
   * @param {string} [txHash] Filter events by a transaction hash.
   * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
   * @param {ChainName} [chain] Filter events by a chain name.
   * @param {string} [contractAddress] Filter events by a contract address.
   * @param {string} [contractLabel] Filter events by a contract label.
   * @param {string} [eventSignature] Filter events by the signature.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApi
   */
  public getEventCount(
    blockHash?: string,
    blockNumber?: number,
    txIndexInBlock?: number,
    eventIndexInLog?: number,
    txHash?: string,
    fromConstructor?: boolean,
    chain?: ChainName,
    contractAddress?: string,
    contractLabel?: string,
    eventSignature?: string,
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig
  ) {
    return EventsApiFp(this.configuration)
      .getEventCount(
        blockHash,
        blockNumber,
        txIndexInBlock,
        eventIndexInLog,
        txHash,
        fromConstructor,
        chain,
        contractAddress,
        contractLabel,
        eventSignature,
        limit,
        offset,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HsmApi - axios parameter creator
 * @export
 */
export const HsmApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Adds a new Azure account configuration.
     * @summary Add HSM config
     * @param {BaseAzureAccount} [baseAzureAccount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addHsmConfig: async (
      baseAzureAccount?: BaseAzureAccount,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/hsm/config`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseAzureAccount, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds an existing key configuration.
     * @summary Add HSM key
     * @param {AddKey} [addKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addHsmKey: async (addKey?: AddKey, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/hsm/key`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(addKey, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new key in the Azure KeyVault.
     * @summary Create HSM key
     * @param {CreateKey} [createKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHsmKey: async (createKey?: CreateKey, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/hsm/key/new`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createKey, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the specified Azure account configuration and its associated keys.
     * @summary Delete HSM config
     * @param {string} clientId The HSM client ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHsmConfig: async (clientId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('deleteHsmConfig', 'clientId', clientId);
      const localVarPath = `/hsm/config/{client_id}`.replace(`{${'client_id'}}`, encodeURIComponent(String(clientId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the specified key configuration.
     * @summary Delete HSM key
     * @param {string} walletAddress An HSM ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHsmKey: async (walletAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('deleteHsmKey', 'walletAddress', walletAddress);
      const localVarPath = `/hsm/key/{wallet_address}`.replace(
        `{${'wallet_address'}}`,
        encodeURIComponent(String(walletAddress))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of HSM configs and their associated wallets.
     * @summary List HSM configs and wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHsm: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/hsm`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of HSM wallets.
     * @summary List HSM wallets
     * @param {string} [keyName] Filter wallets by a key name.
     * @param {string} [keyVersion] Filter wallets by a key version.
     * @param {string} [vaultName] Filter wallets by a vault name.
     * @param {string} [baseGroupName] Filter wallets by a base group name.
     * @param {string} [clientId] Filter wallets by a client ID.
     * @param {string} [publicAddress] Filter wallets by a public address.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHsmWallets: async (
      keyName?: string,
      keyVersion?: string,
      vaultName?: string,
      baseGroupName?: string,
      clientId?: string,
      publicAddress?: string,
      limit?: number,
      offset?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/hsm/wallets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (keyName !== undefined) {
        localVarQueryParameter['key_name'] = keyName;
      }

      if (keyVersion !== undefined) {
        localVarQueryParameter['key_version'] = keyVersion;
      }

      if (vaultName !== undefined) {
        localVarQueryParameter['vault_name'] = vaultName;
      }

      if (baseGroupName !== undefined) {
        localVarQueryParameter['base_group_name'] = baseGroupName;
      }

      if (clientId !== undefined) {
        localVarQueryParameter['client_id'] = clientId;
      }

      if (publicAddress !== undefined) {
        localVarQueryParameter['public_address'] = publicAddress;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
     * @summary Set local nonce
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {SetNonceRequest} [setNonceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLocalNonce: async (
      chain: ChainName,
      walletAddress: string,
      setNonceRequest?: SetNonceRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('setLocalNonce', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('setLocalNonce', 'walletAddress', walletAddress);
      const localVarPath = `/chains/{chain}/hsm/nonce/{wallet_address}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(setNonceRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Signs and submits the given transaction using an HSM address.
     * @summary Sign and submit transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {BaseTransactionToSign} [baseTransactionToSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signAndSubmitTransaction: async (
      chain: ChainName,
      baseTransactionToSign?: BaseTransactionToSign,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('signAndSubmitTransaction', 'chain', chain);
      const localVarPath = `/chains/{chain}/hsm/submit`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseTransactionToSign, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Signs the given data using the given HSM address.
     * @summary Sign data
     * @param {ChainName} chain The blockchain chain label.
     * @param {HSMSignRequest} [hSMSignRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signData: async (
      chain: ChainName,
      hSMSignRequest?: HSMSignRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('signData', 'chain', chain);
      const localVarPath = `/chains/{chain}/hsm/sign`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(hSMSignRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * HsmApi - functional programming interface
 * @export
 */
export const HsmApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HsmApiAxiosParamCreator(configuration);
  return {
    /**
     * Adds a new Azure account configuration.
     * @summary Add HSM config
     * @param {BaseAzureAccount} [baseAzureAccount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addHsmConfig(
      baseAzureAccount?: BaseAzureAccount,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addHsmConfig(baseAzureAccount, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Adds an existing key configuration.
     * @summary Add HSM key
     * @param {AddKey} [addKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addHsmKey(
      addKey?: AddKey,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addHsmKey(addKey, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Creates a new key in the Azure KeyVault.
     * @summary Create HSM key
     * @param {CreateKey} [createKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createHsmKey(
      createKey?: CreateKey,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateHsmKey200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createHsmKey(createKey, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Deletes the specified Azure account configuration and its associated keys.
     * @summary Delete HSM config
     * @param {string} clientId The HSM client ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteHsmConfig(
      clientId: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHsmConfig(clientId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Deletes the specified key configuration.
     * @summary Delete HSM key
     * @param {string} walletAddress An HSM ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteHsmKey(
      walletAddress: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHsmKey(walletAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns a list of HSM configs and their associated wallets.
     * @summary List HSM configs and wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listHsm(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListHsm200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listHsm(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns a list of HSM wallets.
     * @summary List HSM wallets
     * @param {string} [keyName] Filter wallets by a key name.
     * @param {string} [keyVersion] Filter wallets by a key version.
     * @param {string} [vaultName] Filter wallets by a vault name.
     * @param {string} [baseGroupName] Filter wallets by a base group name.
     * @param {string} [clientId] Filter wallets by a client ID.
     * @param {string} [publicAddress] Filter wallets by a public address.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listHsmWallets(
      keyName?: string,
      keyVersion?: string,
      vaultName?: string,
      baseGroupName?: string,
      clientId?: string,
      publicAddress?: string,
      limit?: number,
      offset?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListHsmWallets200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listHsmWallets(
        keyName,
        keyVersion,
        vaultName,
        baseGroupName,
        clientId,
        publicAddress,
        limit,
        offset,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
     * @summary Set local nonce
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {SetNonceRequest} [setNonceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setLocalNonce(
      chain: ChainName,
      walletAddress: string,
      setNonceRequest?: SetNonceRequest,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setLocalNonce(
        chain,
        walletAddress,
        setNonceRequest,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Signs and submits the given transaction using an HSM address.
     * @summary Sign and submit transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {BaseTransactionToSign} [baseTransactionToSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signAndSubmitTransaction(
      chain: ChainName,
      baseTransactionToSign?: BaseTransactionToSign,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferEth200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signAndSubmitTransaction(
        chain,
        baseTransactionToSign,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Signs the given data using the given HSM address.
     * @summary Sign data
     * @param {ChainName} chain The blockchain chain label.
     * @param {HSMSignRequest} [hSMSignRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signData(
      chain: ChainName,
      hSMSignRequest?: HSMSignRequest,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignData200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signData(chain, hSMSignRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * HsmApi - factory interface
 * @export
 */
export const HsmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = HsmApiFp(configuration);
  return {
    /**
     * Adds a new Azure account configuration.
     * @summary Add HSM config
     * @param {BaseAzureAccount} [baseAzureAccount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addHsmConfig(baseAzureAccount?: BaseAzureAccount, options?: any): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp.addHsmConfig(baseAzureAccount, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds an existing key configuration.
     * @summary Add HSM key
     * @param {AddKey} [addKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addHsmKey(addKey?: AddKey, options?: any): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp.addHsmKey(addKey, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new key in the Azure KeyVault.
     * @summary Create HSM key
     * @param {CreateKey} [createKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHsmKey(createKey?: CreateKey, options?: any): AxiosPromise<CreateHsmKey200Response> {
      return localVarFp.createHsmKey(createKey, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the specified Azure account configuration and its associated keys.
     * @summary Delete HSM config
     * @param {string} clientId The HSM client ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHsmConfig(clientId: string, options?: any): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp.deleteHsmConfig(clientId, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the specified key configuration.
     * @summary Delete HSM key
     * @param {string} walletAddress An HSM ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteHsmKey(walletAddress: string, options?: any): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp.deleteHsmKey(walletAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of HSM configs and their associated wallets.
     * @summary List HSM configs and wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHsm(options?: any): AxiosPromise<ListHsm200Response> {
      return localVarFp.listHsm(options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of HSM wallets.
     * @summary List HSM wallets
     * @param {string} [keyName] Filter wallets by a key name.
     * @param {string} [keyVersion] Filter wallets by a key version.
     * @param {string} [vaultName] Filter wallets by a vault name.
     * @param {string} [baseGroupName] Filter wallets by a base group name.
     * @param {string} [clientId] Filter wallets by a client ID.
     * @param {string} [publicAddress] Filter wallets by a public address.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHsmWallets(
      keyName?: string,
      keyVersion?: string,
      vaultName?: string,
      baseGroupName?: string,
      clientId?: string,
      publicAddress?: string,
      limit?: number,
      offset?: number,
      options?: any
    ): AxiosPromise<ListHsmWallets200Response> {
      return localVarFp
        .listHsmWallets(keyName, keyVersion, vaultName, baseGroupName, clientId, publicAddress, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
     * @summary Set local nonce
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {SetNonceRequest} [setNonceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLocalNonce(
      chain: ChainName,
      walletAddress: string,
      setNonceRequest?: SetNonceRequest,
      options?: any
    ): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp
        .setLocalNonce(chain, walletAddress, setNonceRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Signs and submits the given transaction using an HSM address.
     * @summary Sign and submit transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {BaseTransactionToSign} [baseTransactionToSign]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signAndSubmitTransaction(
      chain: ChainName,
      baseTransactionToSign?: BaseTransactionToSign,
      options?: any
    ): AxiosPromise<TransferEth200Response> {
      return localVarFp
        .signAndSubmitTransaction(chain, baseTransactionToSign, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Signs the given data using the given HSM address.
     * @summary Sign data
     * @param {ChainName} chain The blockchain chain label.
     * @param {HSMSignRequest} [hSMSignRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signData(chain: ChainName, hSMSignRequest?: HSMSignRequest, options?: any): AxiosPromise<SignData200Response> {
      return localVarFp.signData(chain, hSMSignRequest, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * HsmApi - interface
 * @export
 * @interface HsmApi
 */
export interface HsmApiInterface {
  /**
   * Adds a new Azure account configuration.
   * @summary Add HSM config
   * @param {BaseAzureAccount} [baseAzureAccount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  addHsmConfig(
    baseAzureAccount?: BaseAzureAccount,
    options?: AxiosRequestConfig
  ): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Adds an existing key configuration.
   * @summary Add HSM key
   * @param {AddKey} [addKey]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  addHsmKey(addKey?: AddKey, options?: AxiosRequestConfig): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Creates a new key in the Azure KeyVault.
   * @summary Create HSM key
   * @param {CreateKey} [createKey]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  createHsmKey(createKey?: CreateKey, options?: AxiosRequestConfig): AxiosPromise<CreateHsmKey200Response>;

  /**
   * Deletes the specified Azure account configuration and its associated keys.
   * @summary Delete HSM config
   * @param {string} clientId The HSM client ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  deleteHsmConfig(clientId: string, options?: AxiosRequestConfig): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Deletes the specified key configuration.
   * @summary Delete HSM key
   * @param {string} walletAddress An HSM ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  deleteHsmKey(walletAddress: string, options?: AxiosRequestConfig): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Returns a list of HSM configs and their associated wallets.
   * @summary List HSM configs and wallets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  listHsm(options?: AxiosRequestConfig): AxiosPromise<ListHsm200Response>;

  /**
   * Returns a list of HSM wallets.
   * @summary List HSM wallets
   * @param {string} [keyName] Filter wallets by a key name.
   * @param {string} [keyVersion] Filter wallets by a key version.
   * @param {string} [vaultName] Filter wallets by a vault name.
   * @param {string} [baseGroupName] Filter wallets by a base group name.
   * @param {string} [clientId] Filter wallets by a client ID.
   * @param {string} [publicAddress] Filter wallets by a public address.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  listHsmWallets(
    keyName?: string,
    keyVersion?: string,
    vaultName?: string,
    baseGroupName?: string,
    clientId?: string,
    publicAddress?: string,
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig
  ): AxiosPromise<ListHsmWallets200Response>;

  /**
   * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
   * @summary Set local nonce
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An HSM ethereum address.
   * @param {SetNonceRequest} [setNonceRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  setLocalNonce(
    chain: ChainName,
    walletAddress: string,
    setNonceRequest?: SetNonceRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Signs and submits the given transaction using an HSM address.
   * @summary Sign and submit transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {BaseTransactionToSign} [baseTransactionToSign]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  signAndSubmitTransaction(
    chain: ChainName,
    baseTransactionToSign?: BaseTransactionToSign,
    options?: AxiosRequestConfig
  ): AxiosPromise<TransferEth200Response>;

  /**
   * Signs the given data using the given HSM address.
   * @summary Sign data
   * @param {ChainName} chain The blockchain chain label.
   * @param {HSMSignRequest} [hSMSignRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  signData(
    chain: ChainName,
    hSMSignRequest?: HSMSignRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<SignData200Response>;
}

/**
 * HsmApi - object-oriented interface
 * @export
 * @class HsmApi
 * @extends {BaseAPI}
 */
export class HsmApi extends BaseAPI implements HsmApiInterface {
  /**
   * Adds a new Azure account configuration.
   * @summary Add HSM config
   * @param {BaseAzureAccount} [baseAzureAccount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public addHsmConfig(baseAzureAccount?: BaseAzureAccount, options?: AxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .addHsmConfig(baseAzureAccount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an existing key configuration.
   * @summary Add HSM key
   * @param {AddKey} [addKey]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public addHsmKey(addKey?: AddKey, options?: AxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .addHsmKey(addKey, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new key in the Azure KeyVault.
   * @summary Create HSM key
   * @param {CreateKey} [createKey]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public createHsmKey(createKey?: CreateKey, options?: AxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .createHsmKey(createKey, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the specified Azure account configuration and its associated keys.
   * @summary Delete HSM config
   * @param {string} clientId The HSM client ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public deleteHsmConfig(clientId: string, options?: AxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .deleteHsmConfig(clientId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the specified key configuration.
   * @summary Delete HSM key
   * @param {string} walletAddress An HSM ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public deleteHsmKey(walletAddress: string, options?: AxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .deleteHsmKey(walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of HSM configs and their associated wallets.
   * @summary List HSM configs and wallets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public listHsm(options?: AxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .listHsm(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of HSM wallets.
   * @summary List HSM wallets
   * @param {string} [keyName] Filter wallets by a key name.
   * @param {string} [keyVersion] Filter wallets by a key version.
   * @param {string} [vaultName] Filter wallets by a vault name.
   * @param {string} [baseGroupName] Filter wallets by a base group name.
   * @param {string} [clientId] Filter wallets by a client ID.
   * @param {string} [publicAddress] Filter wallets by a public address.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public listHsmWallets(
    keyName?: string,
    keyVersion?: string,
    vaultName?: string,
    baseGroupName?: string,
    clientId?: string,
    publicAddress?: string,
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig
  ) {
    return HsmApiFp(this.configuration)
      .listHsmWallets(keyName, keyVersion, vaultName, baseGroupName, clientId, publicAddress, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
   * @summary Set local nonce
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An HSM ethereum address.
   * @param {SetNonceRequest} [setNonceRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public setLocalNonce(
    chain: ChainName,
    walletAddress: string,
    setNonceRequest?: SetNonceRequest,
    options?: AxiosRequestConfig
  ) {
    return HsmApiFp(this.configuration)
      .setLocalNonce(chain, walletAddress, setNonceRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Signs and submits the given transaction using an HSM address.
   * @summary Sign and submit transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {BaseTransactionToSign} [baseTransactionToSign]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public signAndSubmitTransaction(
    chain: ChainName,
    baseTransactionToSign?: BaseTransactionToSign,
    options?: AxiosRequestConfig
  ) {
    return HsmApiFp(this.configuration)
      .signAndSubmitTransaction(chain, baseTransactionToSign, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Signs the given data using the given HSM address.
   * @summary Sign data
   * @param {ChainName} chain The blockchain chain label.
   * @param {HSMSignRequest} [hSMSignRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public signData(chain: ChainName, hSMSignRequest?: HSMSignRequest, options?: AxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .signData(chain, hSMSignRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TxmApi - axios parameter creator
 * @export
 */
export const TxmApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
     * @summary Cancel transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} [gasParams]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelTransaction: async (
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams?: GasParams,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('cancelTransaction', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('cancelTransaction', 'walletAddress', walletAddress);
      // verify required parameter 'nonce' is not null or undefined
      assertParamExists('cancelTransaction', 'nonce', nonce);
      const localVarPath = `/chains/{chain}/txm/{wallet_address}/nonce/{nonce}/cancel`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)))
        .replace(`{${'nonce'}}`, encodeURIComponent(String(nonce)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(gasParams, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Count all transactions for the given wallet address.
     * @summary Count all transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWalletTransactions: async (
      chain: ChainName,
      walletAddress: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('countWalletTransactions', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('countWalletTransactions', 'walletAddress', walletAddress);
      const localVarPath = `/chains/{chain}/txm/{wallet_address}/count`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List the transactions submitted by the given wallet address.
     * @summary List transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
     * @param {number} [nonce] Filter transactions by nonce
     * @param {TransactionStatus} [status] Filter transactions by status
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWalletTransactions: async (
      chain: ChainName,
      walletAddress: string,
      hash?: string,
      nonce?: number,
      status?: TransactionStatus,
      limit?: number,
      offset?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('listWalletTransactions', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('listWalletTransactions', 'walletAddress', walletAddress);
      const localVarPath = `/chains/{chain}/txm/{wallet_address}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (hash !== undefined) {
        localVarQueryParameter['hash'] = hash;
      }

      if (nonce !== undefined) {
        localVarQueryParameter['nonce'] = nonce;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Speeds up a transaction by resubmitting it with a higher gas price.
     * @summary Speed up transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} [gasParams]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speedUpTransaction: async (
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams?: GasParams,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('speedUpTransaction', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('speedUpTransaction', 'walletAddress', walletAddress);
      // verify required parameter 'nonce' is not null or undefined
      assertParamExists('speedUpTransaction', 'nonce', nonce);
      const localVarPath = `/chains/{chain}/txm/{wallet_address}/nonce/{nonce}/speed_up`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)))
        .replace(`{${'nonce'}}`, encodeURIComponent(String(nonce)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(gasParams, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * TxmApi - functional programming interface
 * @export
 */
export const TxmApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TxmApiAxiosParamCreator(configuration);
  return {
    /**
     * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
     * @summary Cancel transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} [gasParams]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelTransaction(
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams?: GasParams,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferEth200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransaction(
        chain,
        walletAddress,
        nonce,
        gasParams,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Count all transactions for the given wallet address.
     * @summary Count all transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countWalletTransactions(
      chain: ChainName,
      walletAddress: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountWalletTransactions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countWalletTransactions(chain, walletAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * List the transactions submitted by the given wallet address.
     * @summary List transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
     * @param {number} [nonce] Filter transactions by nonce
     * @param {TransactionStatus} [status] Filter transactions by status
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWalletTransactions(
      chain: ChainName,
      walletAddress: string,
      hash?: string,
      nonce?: number,
      status?: TransactionStatus,
      limit?: number,
      offset?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWalletTransactions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWalletTransactions(
        chain,
        walletAddress,
        hash,
        nonce,
        status,
        limit,
        offset,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Speeds up a transaction by resubmitting it with a higher gas price.
     * @summary Speed up transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} [gasParams]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async speedUpTransaction(
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams?: GasParams,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferEth200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.speedUpTransaction(
        chain,
        walletAddress,
        nonce,
        gasParams,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * TxmApi - factory interface
 * @export
 */
export const TxmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TxmApiFp(configuration);
  return {
    /**
     * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
     * @summary Cancel transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} [gasParams]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelTransaction(
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams?: GasParams,
      options?: any
    ): AxiosPromise<TransferEth200Response> {
      return localVarFp
        .cancelTransaction(chain, walletAddress, nonce, gasParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Count all transactions for the given wallet address.
     * @summary Count all transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWalletTransactions(
      chain: ChainName,
      walletAddress: string,
      options?: any
    ): AxiosPromise<CountWalletTransactions200Response> {
      return localVarFp
        .countWalletTransactions(chain, walletAddress, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List the transactions submitted by the given wallet address.
     * @summary List transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
     * @param {number} [nonce] Filter transactions by nonce
     * @param {TransactionStatus} [status] Filter transactions by status
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWalletTransactions(
      chain: ChainName,
      walletAddress: string,
      hash?: string,
      nonce?: number,
      status?: TransactionStatus,
      limit?: number,
      offset?: number,
      options?: any
    ): AxiosPromise<ListWalletTransactions200Response> {
      return localVarFp
        .listWalletTransactions(chain, walletAddress, hash, nonce, status, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Speeds up a transaction by resubmitting it with a higher gas price.
     * @summary Speed up transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An HSM ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} [gasParams]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speedUpTransaction(
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams?: GasParams,
      options?: any
    ): AxiosPromise<TransferEth200Response> {
      return localVarFp
        .speedUpTransaction(chain, walletAddress, nonce, gasParams, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * TxmApi - interface
 * @export
 * @interface TxmApi
 */
export interface TxmApiInterface {
  /**
   * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
   * @summary Cancel transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An HSM ethereum address.
   * @param {number} nonce Transaction nonce.
   * @param {GasParams} [gasParams]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApiInterface
   */
  cancelTransaction(
    chain: ChainName,
    walletAddress: string,
    nonce: number,
    gasParams?: GasParams,
    options?: AxiosRequestConfig
  ): AxiosPromise<TransferEth200Response>;

  /**
   * Count all transactions for the given wallet address.
   * @summary Count all transactions for a wallet
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An HSM ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApiInterface
   */
  countWalletTransactions(
    chain: ChainName,
    walletAddress: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<CountWalletTransactions200Response>;

  /**
   * List the transactions submitted by the given wallet address.
   * @summary List transactions for a wallet
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An HSM ethereum address.
   * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
   * @param {number} [nonce] Filter transactions by nonce
   * @param {TransactionStatus} [status] Filter transactions by status
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApiInterface
   */
  listWalletTransactions(
    chain: ChainName,
    walletAddress: string,
    hash?: string,
    nonce?: number,
    status?: TransactionStatus,
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig
  ): AxiosPromise<ListWalletTransactions200Response>;

  /**
   * Speeds up a transaction by resubmitting it with a higher gas price.
   * @summary Speed up transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An HSM ethereum address.
   * @param {number} nonce Transaction nonce.
   * @param {GasParams} [gasParams]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApiInterface
   */
  speedUpTransaction(
    chain: ChainName,
    walletAddress: string,
    nonce: number,
    gasParams?: GasParams,
    options?: AxiosRequestConfig
  ): AxiosPromise<TransferEth200Response>;
}

/**
 * TxmApi - object-oriented interface
 * @export
 * @class TxmApi
 * @extends {BaseAPI}
 */
export class TxmApi extends BaseAPI implements TxmApiInterface {
  /**
   * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
   * @summary Cancel transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An HSM ethereum address.
   * @param {number} nonce Transaction nonce.
   * @param {GasParams} [gasParams]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApi
   */
  public cancelTransaction(
    chain: ChainName,
    walletAddress: string,
    nonce: number,
    gasParams?: GasParams,
    options?: AxiosRequestConfig
  ) {
    return TxmApiFp(this.configuration)
      .cancelTransaction(chain, walletAddress, nonce, gasParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Count all transactions for the given wallet address.
   * @summary Count all transactions for a wallet
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An HSM ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApi
   */
  public countWalletTransactions(chain: ChainName, walletAddress: string, options?: AxiosRequestConfig) {
    return TxmApiFp(this.configuration)
      .countWalletTransactions(chain, walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List the transactions submitted by the given wallet address.
   * @summary List transactions for a wallet
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An HSM ethereum address.
   * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
   * @param {number} [nonce] Filter transactions by nonce
   * @param {TransactionStatus} [status] Filter transactions by status
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApi
   */
  public listWalletTransactions(
    chain: ChainName,
    walletAddress: string,
    hash?: string,
    nonce?: number,
    status?: TransactionStatus,
    limit?: number,
    offset?: number,
    options?: AxiosRequestConfig
  ) {
    return TxmApiFp(this.configuration)
      .listWalletTransactions(chain, walletAddress, hash, nonce, status, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Speeds up a transaction by resubmitting it with a higher gas price.
   * @summary Speed up transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An HSM ethereum address.
   * @param {number} nonce Transaction nonce.
   * @param {GasParams} [gasParams]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApi
   */
  public speedUpTransaction(
    chain: ChainName,
    walletAddress: string,
    nonce: number,
    gasParams?: GasParams,
    options?: AxiosRequestConfig
  ) {
    return TxmApiFp(this.configuration)
      .speedUpTransaction(chain, walletAddress, nonce, gasParams, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
