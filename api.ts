/* tslint:disable */
/* eslint-disable */
/**
 * MultiBaas API
 * MultiBaas\'s REST APIv0.
 *
 * The version of the OpenAPI document: 0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * An API key.
 * @export
 * @interface APIKey
 */
export interface APIKey {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof APIKey
   */
  label: string;
  /**
   *
   * @type {number}
   * @memberof APIKey
   */
  id: number;
  /**
   * The time the API key was created.
   * @type {string}
   * @memberof APIKey
   */
  createdAt: string;
  /**
   * The time the API key was last used.
   * @type {string}
   * @memberof APIKey
   */
  lastUsedAt?: string;
  /**
   * The ID of the user that created the API key.
   * @type {number}
   * @memberof APIKey
   */
  createdBy: number;
  /**
   * The signature of the API key.
   * @type {string}
   * @memberof APIKey
   */
  signature: string;
}
/**
 * A freshly created API key with its secret.
 * @export
 * @interface APIKeyWithSecret
 */
export interface APIKeyWithSecret {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof APIKeyWithSecret
   */
  label: string;
  /**
   *
   * @type {number}
   * @memberof APIKeyWithSecret
   */
  id: number;
  /**
   * The time the API key was created.
   * @type {string}
   * @memberof APIKeyWithSecret
   */
  createdAt: string;
  /**
   * The time the API key was last used.
   * @type {string}
   * @memberof APIKeyWithSecret
   */
  lastUsedAt?: string;
  /**
   * The ID of the user that created the API key.
   * @type {number}
   * @memberof APIKeyWithSecret
   */
  createdBy: number;
  /**
   * The signature of the API key.
   * @type {string}
   * @memberof APIKeyWithSecret
   */
  signature: string;
  /**
   * The secret key of the API key.
   * @type {string}
   * @memberof APIKeyWithSecret
   */
  key: string;
}
/**
 *
 * @export
 * @interface AcceptInvite200Response
 */
export interface AcceptInvite200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof AcceptInvite200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof AcceptInvite200Response
   */
  message: string;
  /**
   *
   * @type {User}
   * @memberof AcceptInvite200Response
   */
  result: User;
}
/**
 *
 * @export
 * @interface AcceptInviteRequest
 */
export interface AcceptInviteRequest {
  /**
   * The user ID Token
   * @type {string}
   * @memberof AcceptInviteRequest
   */
  idToken?: string;
}
/**
 * An access tuple representing an address and its storage keys.
 * @export
 * @interface AccessTuple
 */
export interface AccessTuple {
  /**
   * An ethereum address.
   * @type {string}
   * @memberof AccessTuple
   */
  address: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof AccessTuple
   */
  storageKeys: Array<string>;
}
/**
 * Add key request data.
 * @export
 * @interface AddKey
 */
export interface AddKey {
  /**
   * The Application ID that will be accessing the Key Vault.
   * @type {string}
   * @memberof AddKey
   */
  clientID: string;
  /**
   * The name of the key.
   * @type {string}
   * @memberof AddKey
   */
  keyName: string;
  /**
   * The version of the key.
   * @type {string}
   * @memberof AddKey
   */
  keyVersion: string;
  /**
   * The name given to the vault your key is stored in.
   * @type {string}
   * @memberof AddKey
   */
  vaultName: string;
}
/**
 * An address details.
 * @export
 * @interface Address
 */
export interface Address {
  /**
   * An alias to easily identify and reference addresses.
   * @type {string}
   * @memberof Address
   */
  alias: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof Address
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  balance?: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  chain: string;
  /**
   * The next transaction nonce for this address (obtained from the blockchain node).
   * @type {number}
   * @memberof Address
   */
  nonce?: number;
  /**
   * The next transaction nonce for this address when using the nonce management feature.
   * @type {number}
   * @memberof Address
   */
  localNonce?: number;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  codeAt?: string;
  /**
   *
   * @type {Array<ContractMetadata>}
   * @memberof Address
   */
  contracts: Array<ContractMetadata>;
  /**
   *
   * @type {Array<ContractLookup>}
   * @memberof Address
   */
  contractLookup?: Array<ContractLookup>;
}
/**
 * An address and it\'s alias.
 * @export
 * @interface AddressAlias
 */
export interface AddressAlias {
  /**
   * An alias to easily identify and reference addresses.
   * @type {string}
   * @memberof AddressAlias
   */
  alias: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof AddressAlias
   */
  address: string;
}
/**
 * An audit log entry.
 * @export
 * @interface AuditLog
 */
export interface AuditLog {
  /**
   * The ID of the user who performed the action.
   * @type {number}
   * @memberof AuditLog
   */
  actionByID: number;
  /**
   * The ID of the user who was acted upon.
   * @type {number}
   * @memberof AuditLog
   */
  actionOnID?: number;
  /**
   * The email of the user who performed the action.
   * @type {string}
   * @memberof AuditLog
   */
  actionByUserEmail: string;
  /**
   * The email of the user who was acted upon.
   * @type {string}
   * @memberof AuditLog
   */
  actionOnUserEmail?: string;
  /**
   * The type of action that was performed.
   * @type {string}
   * @memberof AuditLog
   */
  type: string;
  /**
   * The time the action was performed.
   * @type {string}
   * @memberof AuditLog
   */
  createdAt: string;
  /**
   * The data associated with the action.
   * @type {object}
   * @memberof AuditLog
   */
  activityData: object;
}
/**
 * An Azure account.
 * @export
 * @interface AzureAccount
 */
export interface AzureAccount {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof AzureAccount
   */
  label: string;
  /**
   * The Application ID that will be accessing the Key Vault.
   * @type {string}
   * @memberof AzureAccount
   */
  clientID: string;
  /**
   * The application’s secret key that you generate when you first register the application in Azure.
   * @type {string}
   * @memberof AzureAccount
   */
  clientSecret: string;
  /**
   * Also known as Directory ID.
   * @type {string}
   * @memberof AzureAccount
   */
  tenantID: string;
  /**
   * The ID linked to your subscription to Azure services.
   * @type {string}
   * @memberof AzureAccount
   */
  subscriptionID: string;
  /**
   * The Resource Group Name for the resource being accessed.
   * @type {string}
   * @memberof AzureAccount
   */
  baseGroupName: string;
  /**
   *
   * @type {number}
   * @memberof AzureAccount
   */
  id: number;
}
/**
 * An HSM Wallet
 * @export
 * @interface AzureHardwareWallet
 */
export interface AzureHardwareWallet {
  /**
   *
   * @type {number}
   * @memberof AzureHardwareWallet
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof AzureHardwareWallet
   */
  azureAccountID: number;
  /**
   * The name given to the vault your key is stored in.
   * @type {string}
   * @memberof AzureHardwareWallet
   */
  vaultName: string;
  /**
   * The name of the key.
   * @type {string}
   * @memberof AzureHardwareWallet
   */
  keyName: string;
  /**
   * The version of the key.
   * @type {string}
   * @memberof AzureHardwareWallet
   */
  keyVersion: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof AzureHardwareWallet
   */
  publicAddress: string;
}
/**
 * An HSM Wallet returned when a new key is created
 * @export
 * @interface AzureWallet
 */
export interface AzureWallet {
  /**
   * The name of the key.
   * @type {string}
   * @memberof AzureWallet
   */
  keyName: string;
  /**
   * The version of the key.
   * @type {string}
   * @memberof AzureWallet
   */
  keyVersion: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof AzureWallet
   */
  publicAddress: string;
}
/**
 * An API key.
 * @export
 * @interface BaseAPIKey
 */
export interface BaseAPIKey {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof BaseAPIKey
   */
  label: string;
}
/**
 * An Azure account.
 * @export
 * @interface BaseAzureAccount
 */
export interface BaseAzureAccount {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof BaseAzureAccount
   */
  label: string;
  /**
   * The Application ID that will be accessing the Key Vault.
   * @type {string}
   * @memberof BaseAzureAccount
   */
  clientID: string;
  /**
   * The application’s secret key that you generate when you first register the application in Azure.
   * @type {string}
   * @memberof BaseAzureAccount
   */
  clientSecret: string;
  /**
   * Also known as Directory ID.
   * @type {string}
   * @memberof BaseAzureAccount
   */
  tenantID: string;
  /**
   * The ID linked to your subscription to Azure services.
   * @type {string}
   * @memberof BaseAzureAccount
   */
  subscriptionID: string;
  /**
   * The Resource Group Name for the resource being accessed.
   * @type {string}
   * @memberof BaseAzureAccount
   */
  baseGroupName: string;
}
/**
 * A contract.
 * @export
 * @interface BaseContract
 */
export interface BaseContract {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof BaseContract
   */
  label: string;
  /**
   * The name of the contract.
   * @type {string}
   * @memberof BaseContract
   */
  contractName: string;
  /**
   * The contract version.
   * @type {string}
   * @memberof BaseContract
   */
  version: string;
  /**
   * The smart-contract bytecode.
   * @type {string}
   * @memberof BaseContract
   */
  bin?: string;
  /**
   * The contract raw ABI JSON string.
   * @type {string}
   * @memberof BaseContract
   */
  rawAbi: string;
  /**
   * The user documentation JSON string.
   * @type {string}
   * @memberof BaseContract
   */
  userDoc?: string;
  /**
   * The developer documentation JSON string.
   * @type {string}
   * @memberof BaseContract
   */
  developerDoc?: string;
  /**
   * The contract metadata JSON string.
   * @type {string}
   * @memberof BaseContract
   */
  metadata?: string;
  /**
   *
   * @type {boolean}
   * @memberof BaseContract
   */
  isFavorite?: boolean;
}
/**
 * Standard response.
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
  /**
   * The status code.
   * @type {number}
   * @memberof BaseResponse
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof BaseResponse
   */
  message: string;
}
/**
 * A user.
 * @export
 * @interface BaseUser
 */
export interface BaseUser {
  /**
   * The user\'s email address.
   * @type {string}
   * @memberof BaseUser
   */
  email: string;
  /**
   * The user\'s name.
   * @type {string}
   * @memberof BaseUser
   */
  name: string;
}
/**
 *
 * @export
 * @interface BaseWebhookEndpoint
 */
export interface BaseWebhookEndpoint {
  /**
   * The URL to send the webhook to.
   * @type {string}
   * @memberof BaseWebhookEndpoint
   */
  url: string;
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof BaseWebhookEndpoint
   */
  label: string;
  /**
   * The events to subscribe to.
   * @type {Array<WebhookEventsType>}
   * @memberof BaseWebhookEndpoint
   */
  subscriptions: Array<WebhookEventsType>;
}
/**
 * A block in the Ethereum blockchain.
 * @export
 * @interface Block
 */
export interface Block {
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  hash: string;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  difficulty: string;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  gasLimit: number;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  number: string;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  timestamp: number;
  /**
   *
   * @type {Array<Transaction>}
   * @memberof Block
   */
  transactions: Array<Transaction>;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  receiptsRoot: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  parentHash: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  sha3Uncles: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof Block
   */
  miner: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  stateRoot: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  transactionsRoot: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Block
   */
  logsBloom: string;
  /**
   *
   * @type {number}
   * @memberof Block
   */
  gasUsed: number;
  /**
   * A hex string.
   * @type {string}
   * @memberof Block
   */
  nonce: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Block
   */
  mixHash: string;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  extraData: string;
  /**
   *
   * @type {string}
   * @memberof Block
   */
  baseFeePerGas?: string;
}
/**
 * CORS Origin
 * @export
 * @interface CORSOrigin
 */
export interface CORSOrigin {
  /**
   *
   * @type {number}
   * @memberof CORSOrigin
   */
  id?: number;
  /**
   * The CORS Origin
   * @type {string}
   * @memberof CORSOrigin
   */
  origin?: string;
}
/**
 *
 * @export
 * @interface CallContractFunction200Response
 */
export interface CallContractFunction200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CallContractFunction200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CallContractFunction200Response
   */
  message: string;
  /**
   *
   * @type {CallContractFunction200ResponseAllOfResult}
   * @memberof CallContractFunction200Response
   */
  result: CallContractFunction200ResponseAllOfResult;
}
/**
 * @type CallContractFunction200ResponseAllOfResult
 * @export
 */
export type CallContractFunction200ResponseAllOfResult =
  | ({ kind: 'MethodCallPreviewResponse' } & MethodCallPreviewResponse)
  | ({ kind: 'MethodCallResponse' } & MethodCallResponse)
  | ({ kind: 'TransactionToSignResponse' } & TransactionToSignResponse);

/**
 * A blockchain chain name.
 * @export
 * @enum {string}
 */

export const ChainName = {
  Ethereum: 'ethereum'
} as const;

export type ChainName = typeof ChainName[keyof typeof ChainName];

/**
 * The status of the Chain
 * @export
 * @interface ChainStatus
 */
export interface ChainStatus {
  /**
   *
   * @type {number}
   * @memberof ChainStatus
   */
  blockNumber: number;
  /**
   * The client version for this chain node.
   * @type {string}
   * @memberof ChainStatus
   */
  version: string;
  /**
   *
   * @type {number}
   * @memberof ChainStatus
   */
  chainID: number;
  /**
   *
   * @type {number}
   * @memberof ChainStatus
   */
  networkID: number;
  /**
   * The current base fee (only available for chains that support EIP-1559).
   * @type {string}
   * @memberof ChainStatus
   */
  baseFee?: string;
}
/**
 * A Cloud Wallet transaction to be signed.
 * @export
 * @interface CloudWalletTXToSign
 */
export interface CloudWalletTXToSign {
  /**
   *
   * @type {CloudWalletTXToSignTx}
   * @memberof CloudWalletTXToSign
   */
  tx: CloudWalletTXToSignTx;
}
/**
 * An Ethereum transaction.
 * @export
 * @interface CloudWalletTXToSignTx
 */
export interface CloudWalletTXToSignTx {
  /**
   * Sender account nonce of the transaction
   * @type {number}
   * @memberof CloudWalletTXToSignTx
   */
  nonce?: number;
  /**
   * Gas price of the transaction
   * @type {string}
   * @memberof CloudWalletTXToSignTx
   */
  gasPrice?: string;
  /**
   * Fee cap per gas of the transaction
   * @type {string}
   * @memberof CloudWalletTXToSignTx
   */
  gasFeeCap?: string;
  /**
   * GasTipCap per gas of the transaction
   * @type {string}
   * @memberof CloudWalletTXToSignTx
   */
  gasTipCap?: string;
  /**
   * Gas limit of the transaction
   * @type {number}
   * @memberof CloudWalletTXToSignTx
   */
  gas: number;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof CloudWalletTXToSignTx
   */
  from: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof CloudWalletTXToSignTx
   */
  to?: string | null;
  /**
   * Amount (in wei) to send with the transaction.
   * @type {string}
   * @memberof CloudWalletTXToSignTx
   */
  value: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof CloudWalletTXToSignTx
   */
  data: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof CloudWalletTXToSignTx
   */
  hash?: string;
  /**
   * Transaction type
   * @type {number}
   * @memberof CloudWalletTXToSignTx
   */
  type: number;
}
/**
 * A returned contract.
 * @export
 * @interface Contract
 */
export interface Contract {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof Contract
   */
  label: string;
  /**
   * The name of the contract.
   * @type {string}
   * @memberof Contract
   */
  contractName: string;
  /**
   * The contract version.
   * @type {string}
   * @memberof Contract
   */
  version: string;
  /**
   * The smart-contract bytecode.
   * @type {string}
   * @memberof Contract
   */
  bin?: string;
  /**
   * The contract raw ABI JSON string.
   * @type {string}
   * @memberof Contract
   */
  rawAbi: string;
  /**
   * The user documentation JSON string.
   * @type {string}
   * @memberof Contract
   */
  userDoc?: string;
  /**
   * The developer documentation JSON string.
   * @type {string}
   * @memberof Contract
   */
  developerDoc?: string;
  /**
   * The contract metadata JSON string.
   * @type {string}
   * @memberof Contract
   */
  metadata?: string;
  /**
   *
   * @type {boolean}
   * @memberof Contract
   */
  isFavorite?: boolean;
  /**
   *
   * @type {ContractABI}
   * @memberof Contract
   */
  abi: ContractABI;
  /**
   * List of the contract instances.
   * @type {Array<ContractInstance>}
   * @memberof Contract
   */
  instances?: Array<ContractInstance>;
}
/**
 * The contract ABI.
 * @export
 * @interface ContractABI
 */
export interface ContractABI {
  /**
   *
   * @type {ContractABIMethod1}
   * @memberof ContractABI
   */
  constructor: ContractABIMethod1 | null;
  /**
   *
   * @type {{ [key: string]: ContractABIMethod; }}
   * @memberof ContractABI
   */
  methods: { [key: string]: ContractABIMethod };
  /**
   *
   * @type {{ [key: string]: ContractABIEvent; }}
   * @memberof ContractABI
   */
  events: { [key: string]: ContractABIEvent };
  /**
   *
   * @type {{ [key: string]: ContractABIError; }}
   * @memberof ContractABI
   */
  errors?: { [key: string]: ContractABIError };
  /**
   *
   * @type {ContractABIMethod}
   * @memberof ContractABI
   */
  fallback: ContractABIMethod | null;
  /**
   *
   * @type {ContractABIMethod}
   * @memberof ContractABI
   */
  receive: ContractABIMethod | null;
}
/**
 * A contract error.
 * @export
 * @interface ContractABIError
 */
export interface ContractABIError {
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof ContractABIError
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ContractABIError
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ContractABIError
   */
  signature: string;
  /**
   * List of contract event\'s input arguments.
   * @type {Array<ContractABIErrorArgument>}
   * @memberof ContractABIError
   */
  inputs: Array<ContractABIErrorArgument>;
  /**
   * The developer documentation.
   * @type {string}
   * @memberof ContractABIError
   */
  notes?: string;
  /**
   * The user documentation.
   * @type {string}
   * @memberof ContractABIError
   */
  description?: string;
}
/**
 * A contract error argument.
 * @export
 * @interface ContractABIErrorArgument
 */
export interface ContractABIErrorArgument {
  /**
   *
   * @type {string}
   * @memberof ContractABIErrorArgument
   */
  name: string;
  /**
   *
   * @type {ContractABIType}
   * @memberof ContractABIErrorArgument
   */
  type: ContractABIType;
  /**
   *
   * @type {string}
   * @memberof ContractABIErrorArgument
   */
  typeName: string;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIErrorArgument
   */
  indexed: boolean;
  /**
   * The developer documentation.
   * @type {string}
   * @memberof ContractABIErrorArgument
   */
  notes: string;
}
/**
 * A contract event.
 * @export
 * @interface ContractABIEvent
 */
export interface ContractABIEvent {
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof ContractABIEvent
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ContractABIEvent
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ContractABIEvent
   */
  signature: string;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIEvent
   */
  anonymous: boolean;
  /**
   * List of contract event\'s input arguments.
   * @type {Array<ContractABIEventArgument>}
   * @memberof ContractABIEvent
   */
  inputs: Array<ContractABIEventArgument>;
  /**
   * The developer documentation.
   * @type {string}
   * @memberof ContractABIEvent
   */
  notes: string;
  /**
   * The user documentation.
   * @type {string}
   * @memberof ContractABIEvent
   */
  description: string;
}
/**
 * A contract event argument.
 * @export
 * @interface ContractABIEventArgument
 */
export interface ContractABIEventArgument {
  /**
   *
   * @type {string}
   * @memberof ContractABIEventArgument
   */
  name: string;
  /**
   *
   * @type {ContractABIType}
   * @memberof ContractABIEventArgument
   */
  type: ContractABIType;
  /**
   *
   * @type {string}
   * @memberof ContractABIEventArgument
   */
  typeName: string;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIEventArgument
   */
  indexed: boolean;
  /**
   *
   * @type {ContractABITypeConversion}
   * @memberof ContractABIEventArgument
   */
  typeConversion: ContractABITypeConversion | null;
  /**
   * The developer documentation.
   * @type {string}
   * @memberof ContractABIEventArgument
   */
  notes: string;
}
/**
 * A contract function.
 * @export
 * @interface ContractABIMethod
 */
export interface ContractABIMethod {
  /**
   * A hex string.
   * @type {string}
   * @memberof ContractABIMethod
   */
  id: string;
  /**
   * Name of the function.
   * @type {string}
   * @memberof ContractABIMethod
   */
  name: string;
  /**
   * The function signature.
   * @type {string}
   * @memberof ContractABIMethod
   */
  signature: string;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIMethod
   */
  const: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIMethod
   */
  payable: boolean;
  /**
   * List of function arguments.
   * @type {Array<ContractABIMethodArgument>}
   * @memberof ContractABIMethod
   */
  inputs: Array<ContractABIMethodArgument>;
  /**
   * List of function outputs.
   * @type {Array<ContractABIMethodArgument>}
   * @memberof ContractABIMethod
   */
  outputs: Array<ContractABIMethodArgument>;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethod
   */
  author: string;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethod
   */
  notes: string;
  /**
   * The function description.
   * @type {string}
   * @memberof ContractABIMethod
   */
  description: string;
}
/**
 * A contract function.
 * @export
 * @interface ContractABIMethod1
 */
export interface ContractABIMethod1 {
  /**
   * A hex string.
   * @type {string}
   * @memberof ContractABIMethod1
   */
  id: string;
  /**
   * Name of the function.
   * @type {string}
   * @memberof ContractABIMethod1
   */
  name: string;
  /**
   * The function signature.
   * @type {string}
   * @memberof ContractABIMethod1
   */
  signature: string;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIMethod1
   */
  const: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ContractABIMethod1
   */
  payable: boolean;
  /**
   * List of function arguments.
   * @type {Array<ContractABIMethodArgument>}
   * @memberof ContractABIMethod1
   */
  inputs: Array<ContractABIMethodArgument>;
  /**
   * List of function outputs.
   * @type {Array<ContractABIMethodArgument>}
   * @memberof ContractABIMethod1
   */
  outputs: Array<ContractABIMethodArgument>;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethod1
   */
  author: string;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethod1
   */
  notes: string;
  /**
   * The function description.
   * @type {string}
   * @memberof ContractABIMethod1
   */
  description: string;
}
/**
 * A contract function argument.
 * @export
 * @interface ContractABIMethodArgument
 */
export interface ContractABIMethodArgument {
  /**
   *
   * @type {string}
   * @memberof ContractABIMethodArgument
   */
  name: string;
  /**
   *
   * @type {ContractABIType}
   * @memberof ContractABIMethodArgument
   */
  type: ContractABIType;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethodArgument
   */
  typeName: string;
  /**
   *
   * @type {ContractABITypeConversion}
   * @memberof ContractABIMethodArgument
   */
  typeConversion: ContractABITypeConversion | null;
  /**
   *
   * @type {string}
   * @memberof ContractABIMethodArgument
   */
  notes: string;
}
/**
 * A contract function or event argument type.
 * @export
 * @interface ContractABIType
 */
export interface ContractABIType {
  /**
   *
   * @type {string}
   * @memberof ContractABIType
   */
  type: string;
  /**
   *
   * @type {number}
   * @memberof ContractABIType
   */
  size?: number;
  /**
   *
   * @type {Array<ContractABIType>}
   * @memberof ContractABIType
   */
  tupleElems?: Array<ContractABIType>;
  /**
   *
   * @type {Array<string>}
   * @memberof ContractABIType
   */
  tupleRawNames?: Array<string>;
  /**
   *
   * @type {ContractABIType}
   * @memberof ContractABIType
   */
  elem?: ContractABIType;
}
/**
 * Holds JSON-compatible type conversion information.
 * @export
 * @interface ContractABITypeConversion
 */
export interface ContractABITypeConversion {
  /**
   *
   * @type {string}
   * @memberof ContractABITypeConversion
   */
  mode: string;
  /**
   *
   * @type {number}
   * @memberof ContractABITypeConversion
   */
  decimalsAbsolute: number | null;
  /**
   *
   * @type {string}
   * @memberof ContractABITypeConversion
   */
  decimalsFunction: string | null;
}
/**
 * Type conversion options for an event.
 * @export
 * @interface ContractEventOptions
 */
export interface ContractEventOptions {
  /**
   *
   * @type {string}
   * @memberof ContractEventOptions
   */
  signature?: string;
  /**
   *
   * @type {Array<ContractParameter>}
   * @memberof ContractEventOptions
   */
  inputs: Array<ContractParameter>;
}
/**
 * The contract information within the event or transaction.
 * @export
 * @interface ContractInformation
 */
export interface ContractInformation {
  /**
   * An ethereum address.
   * @type {string}
   * @memberof ContractInformation
   */
  address: string;
  /**
   * An alias to easily identify and reference addresses.
   * @type {string}
   * @memberof ContractInformation
   */
  addressAlias: string;
  /**
   * The name of the contract.
   * @type {string}
   * @memberof ContractInformation
   */
  name: string;
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof ContractInformation
   */
  label: string;
}
/**
 * A contract instance
 * @export
 * @interface ContractInstance
 */
export interface ContractInstance {
  /**
   *
   * @type {string}
   * @memberof ContractInstance
   */
  alias: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof ContractInstance
   */
  address: string;
}
/**
 * The contract lookup item.
 * @export
 * @interface ContractLookup
 */
export interface ContractLookup {
  /**
   * An ethereum address.
   * @type {string}
   * @memberof ContractLookup
   */
  address: string;
  /**
   * The name of the contract.
   * @type {string}
   * @memberof ContractLookup
   */
  name?: string;
  /**
   * The contract ABI JSON string.
   * @type {string}
   * @memberof ContractLookup
   */
  abi: string;
  /**
   * The smart-contract bytecode.
   * @type {string}
   * @memberof ContractLookup
   */
  bytecode?: string;
  /**
   * The contract\'s source code.
   * @type {string}
   * @memberof ContractLookup
   */
  source?: string;
  /**
   * The user documentation JSON string.
   * @type {string}
   * @memberof ContractLookup
   */
  userdoc?: string;
  /**
   * The developer documentation JSON string.
   * @type {string}
   * @memberof ContractLookup
   */
  devdoc?: string;
  /**
   * Indicates whether the contract has been verified.
   * @type {boolean}
   * @memberof ContractLookup
   */
  verified: boolean;
  /**
   * The name of the service that provided the contract verification.
   * @type {string}
   * @memberof ContractLookup
   */
  verifiedSource?: string;
  /**
   * The URL to the contract\'s verification details on the verification service.
   * @type {string}
   * @memberof ContractLookup
   */
  verifiedLink?: string;
  /**
   * Indicates whether the contract is a proxy contract.
   * @type {boolean}
   * @memberof ContractLookup
   */
  proxy: boolean;
}
/**
 *
 * @export
 * @interface ContractMetadata
 */
export interface ContractMetadata {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof ContractMetadata
   */
  label: string;
  /**
   * The name of the contract.
   * @type {string}
   * @memberof ContractMetadata
   */
  name: string;
  /**
   * The contract version.
   * @type {string}
   * @memberof ContractMetadata
   */
  version: string;
}
/**
 * The contract method\'s information returned within the event or transaction.
 * @export
 * @interface ContractMethodInformation
 */
export interface ContractMethodInformation {
  /**
   * The name of the method.
   * @type {string}
   * @memberof ContractMethodInformation
   */
  name: string;
  /**
   * The method signature.
   * @type {string}
   * @memberof ContractMethodInformation
   */
  signature: string;
  /**
   *
   * @type {Array<MethodArg>}
   * @memberof ContractMethodInformation
   */
  inputs: Array<MethodArg>;
}
/**
 * Type conversion options for a function.
 * @export
 * @interface ContractMethodOptions
 */
export interface ContractMethodOptions {
  /**
   * The function signature.
   * @type {string}
   * @memberof ContractMethodOptions
   */
  signature?: string;
  /**
   * List of function input parameters.
   * @type {Array<ContractParameter>}
   * @memberof ContractMethodOptions
   */
  inputs: Array<ContractParameter>;
  /**
   * List of function output parameters.
   * @type {Array<ContractParameter>}
   * @memberof ContractMethodOptions
   */
  outputs?: Array<ContractParameter>;
}
/**
 * A contract overview.
 * @export
 * @interface ContractOverview
 */
export interface ContractOverview {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof ContractOverview
   */
  label: string;
  /**
   * The name of the contract.
   * @type {string}
   * @memberof ContractOverview
   */
  contractName: string;
  /**
   * The contract version.
   * @type {string}
   * @memberof ContractOverview
   */
  version: string;
  /**
   *
   * @type {boolean}
   * @memberof ContractOverview
   */
  isFavorite?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ContractOverview
   */
  deployable: boolean;
  /**
   * List of contract instances.
   * @type {Array<ContractInstance>}
   * @memberof ContractOverview
   */
  instances: Array<ContractInstance>;
}
/**
 * Type conversion options for an input or an output of a function or an event.
 * @export
 * @interface ContractParameter
 */
export interface ContractParameter {
  /**
   *
   * @type {ContractABITypeConversion}
   * @memberof ContractParameter
   */
  typeConversion: ContractABITypeConversion | null;
}
/**
 *
 * @export
 * @interface CountEventQueryRecords200Response
 */
export interface CountEventQueryRecords200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CountEventQueryRecords200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CountEventQueryRecords200Response
   */
  message: string;
  /**
   * The record count.
   * @type {number}
   * @memberof CountEventQueryRecords200Response
   */
  result: number;
}
/**
 *
 * @export
 * @interface CountWalletTransactions200Response
 */
export interface CountWalletTransactions200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CountWalletTransactions200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CountWalletTransactions200Response
   */
  message: string;
  /**
   * The transaction count.
   * @type {number}
   * @memberof CountWalletTransactions200Response
   */
  result: number;
}
/**
 *
 * @export
 * @interface CountWebhookEvents200Response
 */
export interface CountWebhookEvents200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CountWebhookEvents200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CountWebhookEvents200Response
   */
  message: string;
  /**
   * The number of webhook events.
   * @type {number}
   * @memberof CountWebhookEvents200Response
   */
  result: number;
}
/**
 *
 * @export
 * @interface CountWebhooks200Response
 */
export interface CountWebhooks200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CountWebhooks200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CountWebhooks200Response
   */
  message: string;
  /**
   * The webhook count.
   * @type {number}
   * @memberof CountWebhooks200Response
   */
  result: number;
}
/**
 *
 * @export
 * @interface CreateApiKey200Response
 */
export interface CreateApiKey200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CreateApiKey200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CreateApiKey200Response
   */
  message: string;
  /**
   *
   * @type {APIKeyWithSecret}
   * @memberof CreateApiKey200Response
   */
  result: APIKeyWithSecret;
}
/**
 *
 * @export
 * @interface CreateApiKeyRequest
 */
export interface CreateApiKeyRequest {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof CreateApiKeyRequest
   */
  label: string;
  /**
   *
   * @type {Array<number>}
   * @memberof CreateApiKeyRequest
   */
  groupIDs?: Array<number>;
}
/**
 *
 * @export
 * @interface CreateHsmKey200Response
 */
export interface CreateHsmKey200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CreateHsmKey200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CreateHsmKey200Response
   */
  message: string;
  /**
   *
   * @type {AzureWallet}
   * @memberof CreateHsmKey200Response
   */
  result: AzureWallet;
}
/**
 * Create Key request data.
 * @export
 * @interface CreateKey
 */
export interface CreateKey {
  /**
   * The Application ID that will be accessing the Key Vault.
   * @type {string}
   * @memberof CreateKey
   */
  clientID: string;
  /**
   * The name of the key.
   * @type {string}
   * @memberof CreateKey
   */
  keyName: string;
  /**
   * The name given to the vault your key is stored in.
   * @type {string}
   * @memberof CreateKey
   */
  vaultName: string;
  /**
   *
   * @type {boolean}
   * @memberof CreateKey
   */
  useHardwareModule: boolean;
}
/**
 *
 * @export
 * @interface CreateWebhook200Response
 */
export interface CreateWebhook200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof CreateWebhook200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof CreateWebhook200Response
   */
  message: string;
  /**
   *
   * @type {WebhookEndpoint}
   * @memberof CreateWebhook200Response
   */
  result: WebhookEndpoint;
}
/**
 *
 * @export
 * @interface DeployContract200Response
 */
export interface DeployContract200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof DeployContract200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof DeployContract200Response
   */
  message: string;
  /**
   *
   * @type {DeployContractTransaction}
   * @memberof DeployContract200Response
   */
  result: DeployContractTransaction;
}
/**
 * The transaction returned when you deploy a contracts.
 * @export
 * @interface DeployContractTransaction
 */
export interface DeployContractTransaction {
  /**
   *
   * @type {TransactionToSignTx}
   * @memberof DeployContractTransaction
   */
  tx: TransactionToSignTx;
  /**
   *
   * @type {boolean}
   * @memberof DeployContractTransaction
   */
  submitted: boolean;
  /**
   *
   * @type {string}
   * @memberof DeployContractTransaction
   */
  deployAt?: string;
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof DeployContractTransaction
   */
  label?: string;
}
/**
 * The domain fields for EIP-712. All fields are optional per the specification.
 * @export
 * @interface EIP712Domain
 */
export interface EIP712Domain {
  /**
   * Human-readable name of the signing domain.
   * @type {string}
   * @memberof EIP712Domain
   */
  name?: string;
  /**
   * Current major version of the signing domain.
   * @type {string}
   * @memberof EIP712Domain
   */
  version?: string;
  /**
   *
   * @type {EIP712DomainChainId}
   * @memberof EIP712Domain
   */
  chainId?: EIP712DomainChainId;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof EIP712Domain
   */
  verifyingContract?: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof EIP712Domain
   */
  salt?: string;
}
/**
 * @type EIP712DomainChainId
 * The EIP-155 chain ID of the application using the typed data.
 * @export
 */
export type EIP712DomainChainId = number | string;

/**
 *
 * @export
 * @interface EIP712TypeEntry
 */
export interface EIP712TypeEntry {
  /**
   *
   * @type {string}
   * @memberof EIP712TypeEntry
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof EIP712TypeEntry
   */
  type: string;
}
/**
 * EIP-712 structured typed data object.
 * @export
 * @interface EIP712TypedData
 */
export interface EIP712TypedData {
  /**
   *
   * @type {EIP712Types}
   * @memberof EIP712TypedData
   */
  types: EIP712Types;
  /**
   * The root type of the message object. Must correspond to a key in the `types` object.
   * @type {string}
   * @memberof EIP712TypedData
   */
  primaryType: string;
  /**
   *
   * @type {EIP712Domain}
   * @memberof EIP712TypedData
   */
  domain: EIP712Domain;
  /**
   * The actual data, conforming to the `primaryType` definition in `types`.
   * @type {object}
   * @memberof EIP712TypedData
   */
  message: object;
}
/**
 * A mapping of type names to arrays of fields.
 * @export
 * @interface EIP712Types
 */
export interface EIP712Types {
  [key: string]: Array<EIP712TypeEntry> | any;

  /**
   *
   * @type {Array<EIP712TypeEntry>}
   * @memberof EIP712Types
   */
  EIP712Domain: Array<EIP712TypeEntry>;
}
/**
 * An event returned by the API call.
 * @export
 * @interface Event
 */
export interface Event {
  /**
   * The time at which the event was triggered.
   * @type {string}
   * @memberof Event
   */
  triggeredAt: string;
  /**
   *
   * @type {EventInformation}
   * @memberof Event
   */
  event: EventInformation;
  /**
   *
   * @type {TransactionInformation}
   * @memberof Event
   */
  transaction: TransactionInformation;
}
/**
 * Holds a field in the event\'s data.
 * @export
 * @interface EventField
 */
export interface EventField {
  /**
   * The input name.
   * @type {string}
   * @memberof EventField
   */
  name: string;
  /**
   * The input value.
   * @type {any}
   * @memberof EventField
   */
  value: any;
  /**
   * Has the value been hashed into a keccak256 string?
   * @type {boolean}
   * @memberof EventField
   */
  hashed: boolean;
  /**
   * The type of the argument.
   * @type {string}
   * @memberof EventField
   */
  type: string;
}
/**
 * The event information returned as part of an event.
 * @export
 * @interface EventInformation
 */
export interface EventInformation {
  /**
   * The name of the event.
   * @type {string}
   * @memberof EventInformation
   */
  name: string;
  /**
   * The event signature.
   * @type {string}
   * @memberof EventInformation
   */
  signature: string;
  /**
   * The list of input arguments for the event.
   * @type {Array<EventField>}
   * @memberof EventInformation
   */
  inputs: Array<EventField>;
  /**
   * The raw output from an event. Omitted when returned as part of a transaction receipt.
   * @type {string}
   * @memberof EventInformation
   */
  rawFields?: string;
  /**
   *
   * @type {ContractInformation}
   * @memberof EventInformation
   */
  contract: ContractInformation;
  /**
   * The event\'s index in the log.
   * @type {number}
   * @memberof EventInformation
   */
  indexInLog: number;
}
/**
 * Status of an Event Monitor
 * @export
 * @interface EventMonitorStatus
 */
export interface EventMonitorStatus {
  /**
   *
   * @type {number}
   * @memberof EventMonitorStatus
   */
  contractId?: number;
  /**
   *
   * @type {number}
   * @memberof EventMonitorStatus
   */
  addressId?: number;
  /**
   *
   * @type {boolean}
   * @memberof EventMonitorStatus
   */
  isProcessingPastLogs: boolean;
  /**
   *
   * @type {number}
   * @memberof EventMonitorStatus
   */
  idealBlockRange?: number;
  /**
   *
   * @type {number}
   * @memberof EventMonitorStatus
   */
  latestBlockNumber: number;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof EventMonitorStatus
   */
  latestBlockHash: string;
  /**
   *
   * @type {number}
   * @memberof EventMonitorStatus
   */
  startBlockNumber: number;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof EventMonitorStatus
   */
  startBlockHash: string;
  /**
   *
   * @type {string}
   * @memberof EventMonitorStatus
   */
  updatedAt: string;
}
/**
 * An event query.
 * @export
 * @interface EventQuery
 */
export interface EventQuery {
  /**
   *
   * @type {Array<EventQueryEvent>}
   * @memberof EventQuery
   */
  events: Array<EventQueryEvent>;
  /**
   * The results will be grouped according to this field. An aggregator for non Group By fields must be specified if groupBy is specified.
   * @type {string}
   * @memberof EventQuery
   */
  groupBy?: string;
  /**
   * The results will be ordered according to this field.
   * @type {string}
   * @memberof EventQuery
   */
  orderBy?: string;
  /**
   * Specify ascending or descending order, the default is \"ASC\".
   * @type {string}
   * @memberof EventQuery
   */
  order?: EventQueryOrderEnum;
}

export const EventQueryOrderEnum = {
  Asc: 'ASC',
  Desc: 'DESC'
} as const;

export type EventQueryOrderEnum = typeof EventQueryOrderEnum[keyof typeof EventQueryOrderEnum];

/**
 * A query on a single event.
 * @export
 * @interface EventQueryEvent
 */
export interface EventQueryEvent {
  /**
   * The name of an event.
   * @type {string}
   * @memberof EventQueryEvent
   */
  eventName: string;
  /**
   * The query information about all the fields to select from an event.
   * @type {Array<EventQueryField>}
   * @memberof EventQueryEvent
   */
  select: Array<EventQueryField>;
  /**
   *
   * @type {EventQueryFilter}
   * @memberof EventQueryEvent
   */
  filter?: EventQueryFilter;
}
/**
 * A single event field\'s query information.
 * @export
 * @interface EventQueryField
 */
export interface EventQueryField {
  /**
   *
   * @type {FieldType}
   * @memberof EventQueryField
   */
  type: FieldType;
  /**
   * The field name. Either `name` or `inputIndex` is required if `fieldType == \"input\"`.
   * @type {string}
   * @memberof EventQueryField
   */
  name?: string;
  /**
   * The field\'s index, can be used in place of `name`.
   * @type {number}
   * @memberof EventQueryField
   */
  inputIndex?: number | null;
  /**
   * The name that will be used to return the field.
   * @type {string}
   * @memberof EventQueryField
   */
  alias?: string;
  /**
   * The type of aggregation to perform on the field.
   * @type {string}
   * @memberof EventQueryField
   */
  aggregator?: EventQueryFieldAggregatorEnum | null;
}

export const EventQueryFieldAggregatorEnum = {
  Add: 'add',
  Subtract: 'subtract',
  Last: 'last',
  First: 'first',
  Min: 'min',
  Max: 'max'
} as const;

export type EventQueryFieldAggregatorEnum =
  typeof EventQueryFieldAggregatorEnum[keyof typeof EventQueryFieldAggregatorEnum];

/**
 * A event query filter.
 * @export
 * @interface EventQueryFilter
 */
export interface EventQueryFilter {
  /**
   * The rule type, can be omitted if this is the last filter to be applied.
   * @type {string}
   * @memberof EventQueryFilter
   */
  rule?: EventQueryFilterRuleEnum;
  /**
   *
   * @type {FieldType}
   * @memberof EventQueryFilter
   */
  fieldType?: FieldType;
  /**
   * The field\'s index, can be used in place of `name`.
   * @type {number}
   * @memberof EventQueryFilter
   */
  inputIndex?: number | null;
  /**
   * The operator on the filter.
   * @type {string}
   * @memberof EventQueryFilter
   */
  operator?: EventQueryFilterOperatorEnum;
  /**
   * The value to be compared with.
   * @type {string}
   * @memberof EventQueryFilter
   */
  value?: string;
  /**
   * Other filters to be applied in succession with the rule specified.
   * @type {Array<EventQueryFilter>}
   * @memberof EventQueryFilter
   */
  children?: Array<EventQueryFilter>;
}

export const EventQueryFilterRuleEnum = {
  And: 'and',
  Or: 'or'
} as const;

export type EventQueryFilterRuleEnum = typeof EventQueryFilterRuleEnum[keyof typeof EventQueryFilterRuleEnum];
export const EventQueryFilterOperatorEnum = {
  Equal: 'equal',
  Notequal: 'notequal',
  Lessthan: 'lessthan',
  Greaterthan: 'greaterthan',
  Lessthanorequal: 'lessthanorequal',
  Greaterthanorequal: 'greaterthanorequal'
} as const;

export type EventQueryFilterOperatorEnum =
  typeof EventQueryFilterOperatorEnum[keyof typeof EventQueryFilterOperatorEnum];

/**
 * Results of an executed event query.
 * @export
 * @interface EventQueryResults
 */
export interface EventQueryResults {
  /**
   *
   * @type {Array<{ [key: string]: any; }>}
   * @memberof EventQueryResults
   */
  rows: Array<{ [key: string]: any }>;
}
/**
 * Type conversion options for each of the inputs of an event.
 * @export
 * @interface EventTypeConversionOptions
 */
export interface EventTypeConversionOptions {
  /**
   * List of event\'s input parameters.
   * @type {Array<TypeConversionOptions>}
   * @memberof EventTypeConversionOptions
   */
  inputs: Array<TypeConversionOptions>;
}
/**
 *
 * @export
 * @interface ExecuteArbitraryEventQuery200Response
 */
export interface ExecuteArbitraryEventQuery200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ExecuteArbitraryEventQuery200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ExecuteArbitraryEventQuery200Response
   */
  message: string;
  /**
   *
   * @type {EventQueryResults}
   * @memberof ExecuteArbitraryEventQuery200Response
   */
  result: EventQueryResults;
}
/**
 * The field type in a select or filter.
 * @export
 * @enum {string}
 */

export const FieldType = {
  Input: 'input',
  ContractLabel: 'contract_label',
  ContractName: 'contract_name',
  ContractAddress: 'contract_address',
  ContractAddressAlias: 'contract_address_alias',
  BlockNumber: 'block_number',
  TriggeredAt: 'triggered_at',
  EventSignature: 'event_signature',
  BlockHash: 'block_hash',
  TxHash: 'tx_hash',
  TxFrom: 'tx_from'
} as const;

export type FieldType = typeof FieldType[keyof typeof FieldType];

/**
 * Specify custom gas parameters
 * @export
 * @interface GasParams
 */
export interface GasParams {
  /**
   * Gas price to use for the cancel/resubmit.
   * @type {string}
   * @memberof GasParams
   */
  gasPrice?: string;
  /**
   * Gas fee cap to use for the EIP-1559 cancel/resubmit.
   * @type {string}
   * @memberof GasParams
   */
  gasFeeCap?: string;
  /**
   * Gas priority fee cap to use for the EIP-1559 cancel/resubmit.
   * @type {string}
   * @memberof GasParams
   */
  gasTipCap?: string;
  /**
   * Gas limit to set for the cancel/resubmit.
   * @type {number}
   * @memberof GasParams
   */
  gas?: number;
}
/**
 *
 * @export
 * @interface GetApiKey200Response
 */
export interface GetApiKey200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetApiKey200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetApiKey200Response
   */
  message: string;
  /**
   *
   * @type {APIKey}
   * @memberof GetApiKey200Response
   */
  result: APIKey;
}
/**
 *
 * @export
 * @interface GetBlock200Response
 */
export interface GetBlock200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetBlock200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetBlock200Response
   */
  message: string;
  /**
   *
   * @type {Block}
   * @memberof GetBlock200Response
   */
  result: Block;
}
/**
 *
 * @export
 * @interface GetChainStatus200Response
 */
export interface GetChainStatus200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetChainStatus200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetChainStatus200Response
   */
  message: string;
  /**
   *
   * @type {ChainStatus}
   * @memberof GetChainStatus200Response
   */
  result: ChainStatus;
}
/**
 *
 * @export
 * @interface GetContract200Response
 */
export interface GetContract200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetContract200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetContract200Response
   */
  message: string;
  /**
   *
   * @type {Contract}
   * @memberof GetContract200Response
   */
  result: Contract;
}
/**
 *
 * @export
 * @interface GetContractVersions200Response
 */
export interface GetContractVersions200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetContractVersions200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetContractVersions200Response
   */
  message: string;
  /**
   *
   * @type {Array<Contract>}
   * @memberof GetContractVersions200Response
   */
  result: Array<Contract>;
}
/**
 *
 * @export
 * @interface GetEventCount200Response
 */
export interface GetEventCount200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetEventCount200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetEventCount200Response
   */
  message: string;
  /**
   * The number of events.
   * @type {number}
   * @memberof GetEventCount200Response
   */
  result: number;
}
/**
 *
 * @export
 * @interface GetEventMonitorStatus200Response
 */
export interface GetEventMonitorStatus200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetEventMonitorStatus200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetEventMonitorStatus200Response
   */
  message: string;
  /**
   *
   * @type {EventMonitorStatus}
   * @memberof GetEventMonitorStatus200Response
   */
  result: EventMonitorStatus;
}
/**
 *
 * @export
 * @interface GetEventQuery200Response
 */
export interface GetEventQuery200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetEventQuery200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetEventQuery200Response
   */
  message: string;
  /**
   *
   * @type {EventQuery}
   * @memberof GetEventQuery200Response
   */
  result: EventQuery;
}
/**
 *
 * @export
 * @interface GetEventTypeConversions200Response
 */
export interface GetEventTypeConversions200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetEventTypeConversions200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetEventTypeConversions200Response
   */
  message: string;
  /**
   *
   * @type {EventTypeConversionOptions}
   * @memberof GetEventTypeConversions200Response
   */
  result: EventTypeConversionOptions;
}
/**
 *
 * @export
 * @interface GetFunctionTypeConversions200Response
 */
export interface GetFunctionTypeConversions200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetFunctionTypeConversions200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetFunctionTypeConversions200Response
   */
  message: string;
  /**
   *
   * @type {MethodTypeConversionOptions}
   * @memberof GetFunctionTypeConversions200Response
   */
  result: MethodTypeConversionOptions;
}
/**
 *
 * @export
 * @interface GetTransaction200Response
 */
export interface GetTransaction200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetTransaction200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetTransaction200Response
   */
  message: string;
  /**
   *
   * @type {TransactionData}
   * @memberof GetTransaction200Response
   */
  result: TransactionData;
}
/**
 *
 * @export
 * @interface GetTransactionReceipt200Response
 */
export interface GetTransactionReceipt200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof GetTransactionReceipt200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof GetTransactionReceipt200Response
   */
  message: string;
  /**
   *
   * @type {TransactionReceipt}
   * @memberof GetTransactionReceipt200Response
   */
  result: TransactionReceipt;
}
/**
 * A group.
 * @export
 * @interface Group
 */
export interface Group {
  /**
   * The group ID.
   * @type {number}
   * @memberof Group
   */
  id: number;
  /**
   * The group name.
   * @type {string}
   * @memberof Group
   */
  name: string;
  /**
   * The group short name.
   * @type {string}
   * @memberof Group
   */
  shortName: string;
  /**
   * The group description.
   * @type {string}
   * @memberof Group
   */
  description: string;
  /**
   * The group roles.
   * @type {Array<Role>}
   * @memberof Group
   */
  roles: Array<Role>;
}
/**
 * Response body for returning HSM Data.
 * @export
 * @interface HSMData
 */
export interface HSMData {
  /**
   *
   * @type {AzureAccount}
   * @memberof HSMData
   */
  configuration: AzureAccount;
  /**
   * An array of Azure Hardware Wallets.
   * @type {Array<AzureHardwareWallet>}
   * @memberof HSMData
   */
  wallets: Array<AzureHardwareWallet>;
}
/**
 * @type HSMSignRequest
 * @export
 */
export type HSMSignRequest =
  | ({ method: 'eth_signTypedData_v4' } & HSMSignRequestTypedData)
  | ({ method: 'personal_sign' } & HSMSignRequestPersonalSign)
  | ({ method: 'HSMSignRequestPersonalSign' } & HSMSignRequestPersonalSign)
  | ({ method: 'HSMSignRequestTypedData' } & HSMSignRequestTypedData);

/**
 * Request to sign a message using a cloud wallet.
 * @export
 * @interface HSMSignRequestPersonalSign
 */
export interface HSMSignRequestPersonalSign {
  /**
   * The signing method to use.
   * @type {string}
   * @memberof HSMSignRequestPersonalSign
   */
  method: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof HSMSignRequestPersonalSign
   */
  address: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof HSMSignRequestPersonalSign
   */
  data: string;
  /**
   *
   * @type {HSMSignRequestPersonalSignChainId}
   * @memberof HSMSignRequestPersonalSign
   */
  chainId?: HSMSignRequestPersonalSignChainId;
}
/**
 * @type HSMSignRequestPersonalSignChainId
 * Optionally lock the message to a specific chain by encoding the chain ID in the signature per EIP-155.
 * @export
 */
export type HSMSignRequestPersonalSignChainId = number | string;

/**
 * Request to sign typed data using a cloud wallet.
 * @export
 * @interface HSMSignRequestTypedData
 */
export interface HSMSignRequestTypedData {
  /**
   * The signing method to use.
   * @type {string}
   * @memberof HSMSignRequestTypedData
   */
  method: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof HSMSignRequestTypedData
   */
  address: string;
  /**
   *
   * @type {EIP712TypedData}
   * @memberof HSMSignRequestTypedData
   */
  data: EIP712TypedData;
}
/**
 * Response body representing a sign-data response.
 * @export
 * @interface HSMSignResponse
 */
export interface HSMSignResponse {
  /**
   *
   * @type {string}
   * @memberof HSMSignResponse
   */
  publicKey: string;
  /**
   *
   * @type {string}
   * @memberof HSMSignResponse
   */
  signature: string;
}
/**
 * A user invitation to MultiBaas.
 * @export
 * @interface Invite
 */
export interface Invite {
  /**
   * The invite ID.
   * @type {string}
   * @memberof Invite
   */
  id: string;
  /**
   * The invitee\'s email address.
   * @type {string}
   * @memberof Invite
   */
  email: string;
  /**
   * The time the invite was created.
   * @type {string}
   * @memberof Invite
   */
  createdAt: string;
}
/**
 * An invite request with groups.
 * @export
 * @interface InviteRequest
 */
export interface InviteRequest {
  /**
   * The invitee\'s email address.
   * @type {string}
   * @memberof InviteRequest
   */
  email: string;
  /**
   *
   * @type {Array<number>}
   * @memberof InviteRequest
   */
  groupIDs?: Array<number>;
}
/**
 *
 * @export
 * @interface LinkAddressContractRequest
 */
export interface LinkAddressContractRequest {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof LinkAddressContractRequest
   */
  label: string;
  /**
   * The contract version.
   * @type {string}
   * @memberof LinkAddressContractRequest
   */
  version?: string;
  /**
   * The block number from which to start syncing events. The value can be `latest` for the latest block number, an absolute block number (e.g. `123` for the block number 123), or a relative block number (e.g. `-100` for 100 blocks before the latest block). If absent, the event monitor will be disabled for this contract and events won\'t be synced.
   * @type {string}
   * @memberof LinkAddressContractRequest
   */
  startingBlock?: string;
}
/**
 *
 * @export
 * @interface ListAddresses200Response
 */
export interface ListAddresses200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListAddresses200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListAddresses200Response
   */
  message: string;
  /**
   *
   * @type {Array<AddressAlias>}
   * @memberof ListAddresses200Response
   */
  result: Array<AddressAlias>;
}
/**
 *
 * @export
 * @interface ListApiKeys200Response
 */
export interface ListApiKeys200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListApiKeys200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListApiKeys200Response
   */
  message: string;
  /**
   *
   * @type {Array<APIKey>}
   * @memberof ListApiKeys200Response
   */
  result: Array<APIKey>;
}
/**
 *
 * @export
 * @interface ListAuditLogs200Response
 */
export interface ListAuditLogs200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListAuditLogs200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListAuditLogs200Response
   */
  message: string;
  /**
   *
   * @type {Array<AuditLog>}
   * @memberof ListAuditLogs200Response
   */
  result: Array<AuditLog>;
}
/**
 *
 * @export
 * @interface ListContractVersions200Response
 */
export interface ListContractVersions200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListContractVersions200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListContractVersions200Response
   */
  message: string;
  /**
   *
   * @type {ListContractVersions200ResponseAllOfResult}
   * @memberof ListContractVersions200Response
   */
  result: ListContractVersions200ResponseAllOfResult;
}
/**
 *
 * @export
 * @interface ListContractVersions200ResponseAllOfResult
 */
export interface ListContractVersions200ResponseAllOfResult {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof ListContractVersions200ResponseAllOfResult
   */
  label: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ListContractVersions200ResponseAllOfResult
   */
  versions: Array<string>;
}
/**
 *
 * @export
 * @interface ListContracts200Response
 */
export interface ListContracts200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListContracts200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListContracts200Response
   */
  message: string;
  /**
   *
   * @type {Array<ContractOverview>}
   * @memberof ListContracts200Response
   */
  result: Array<ContractOverview>;
}
/**
 *
 * @export
 * @interface ListCorsOrigins200Response
 */
export interface ListCorsOrigins200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListCorsOrigins200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListCorsOrigins200Response
   */
  message: string;
  /**
   *
   * @type {Array<CORSOrigin>}
   * @memberof ListCorsOrigins200Response
   */
  result: Array<CORSOrigin>;
}
/**
 *
 * @export
 * @interface ListEventQueries200Response
 */
export interface ListEventQueries200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListEventQueries200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListEventQueries200Response
   */
  message: string;
  /**
   *
   * @type {Array<SavedEventQuery>}
   * @memberof ListEventQueries200Response
   */
  result: Array<SavedEventQuery>;
}
/**
 *
 * @export
 * @interface ListEvents200Response
 */
export interface ListEvents200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListEvents200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListEvents200Response
   */
  message: string;
  /**
   *
   * @type {Array<Event>}
   * @memberof ListEvents200Response
   */
  result: Array<Event>;
}
/**
 *
 * @export
 * @interface ListGroups200Response
 */
export interface ListGroups200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListGroups200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListGroups200Response
   */
  message: string;
  /**
   *
   * @type {Array<Group>}
   * @memberof ListGroups200Response
   */
  result: Array<Group>;
}
/**
 *
 * @export
 * @interface ListHsm200Response
 */
export interface ListHsm200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListHsm200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListHsm200Response
   */
  message: string;
  /**
   *
   * @type {Array<HSMData>}
   * @memberof ListHsm200Response
   */
  result: Array<HSMData>;
}
/**
 *
 * @export
 * @interface ListHsmWallets200Response
 */
export interface ListHsmWallets200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListHsmWallets200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListHsmWallets200Response
   */
  message: string;
  /**
   *
   * @type {Array<StandaloneWallet>}
   * @memberof ListHsmWallets200Response
   */
  result: Array<StandaloneWallet>;
}
/**
 *
 * @export
 * @interface ListInvites200Response
 */
export interface ListInvites200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListInvites200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListInvites200Response
   */
  message: string;
  /**
   *
   * @type {Array<Invite>}
   * @memberof ListInvites200Response
   */
  result: Array<Invite>;
}
/**
 *
 * @export
 * @interface ListUserSigners200Response
 */
export interface ListUserSigners200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListUserSigners200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListUserSigners200Response
   */
  message: string;
  /**
   *
   * @type {Array<SignerWallet>}
   * @memberof ListUserSigners200Response
   */
  result: Array<SignerWallet>;
}
/**
 *
 * @export
 * @interface ListUsers200Response
 */
export interface ListUsers200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListUsers200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListUsers200Response
   */
  message: string;
  /**
   *
   * @type {Array<User>}
   * @memberof ListUsers200Response
   */
  result: Array<User>;
}
/**
 *
 * @export
 * @interface ListWalletTransactions200Response
 */
export interface ListWalletTransactions200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListWalletTransactions200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListWalletTransactions200Response
   */
  message: string;
  /**
   *
   * @type {Array<WalletTransaction>}
   * @memberof ListWalletTransactions200Response
   */
  result: Array<WalletTransaction>;
}
/**
 *
 * @export
 * @interface ListWebhookEvents200Response
 */
export interface ListWebhookEvents200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListWebhookEvents200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListWebhookEvents200Response
   */
  message: string;
  /**
   *
   * @type {Array<WebhookEvent>}
   * @memberof ListWebhookEvents200Response
   */
  result: Array<WebhookEvent>;
}
/**
 *
 * @export
 * @interface ListWebhooks200Response
 */
export interface ListWebhooks200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof ListWebhooks200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof ListWebhooks200Response
   */
  message: string;
  /**
   *
   * @type {Array<WebhookEndpoint>}
   * @memberof ListWebhooks200Response
   */
  result: Array<WebhookEndpoint>;
}
/**
 * A contract log event.
 * @export
 * @interface Log
 */
export interface Log {
  /**
   * An ethereum address.
   * @type {string}
   * @memberof Log
   */
  address: string;
  /**
   * A list of topics provided by the contract.
   * @type {Array<string>}
   * @memberof Log
   */
  topics: Array<string>;
  /**
   * A hex string.
   * @type {string}
   * @memberof Log
   */
  data: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Log
   */
  blockNumber: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Log
   */
  transactionHash: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Log
   */
  transactionIndex: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Log
   */
  blockHash: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Log
   */
  logIndex: string;
  /**
   * True if this log was reverted due to a chain reorganization.
   * @type {boolean}
   * @memberof Log
   */
  removed: boolean;
}
/**
 * An argument passed to a method call.
 * @export
 * @interface MethodArg
 */
export interface MethodArg {
  /**
   * The input name.
   * @type {string}
   * @memberof MethodArg
   */
  name: string;
  /**
   * The input value.
   * @type {any}
   * @memberof MethodArg
   */
  value: any;
  /**
   * The type of the argument.
   * @type {string}
   * @memberof MethodArg
   */
  type: string;
}
/**
 * The result of a preview function arguments call.
 * @export
 * @interface MethodCallPreviewResponse
 */
export interface MethodCallPreviewResponse extends PostMethodResponse {
  /**
   * The function call inputs.
   * @type {Array<any>}
   * @memberof MethodCallPreviewResponse
   */
  input: Array<any>;
  /**
   * The function call output.
   * @type {any}
   * @memberof MethodCallPreviewResponse
   */
  output: any;
}
/**
 * The result of a function call.
 * @export
 * @interface MethodCallResponse
 */
export interface MethodCallResponse extends PostMethodResponse {
  /**
   * The function call output.
   * @type {any}
   * @memberof MethodCallResponse
   */
  output: any;
}
/**
 * Type conversion options for each of the inputs and outputs of a function.
 * @export
 * @interface MethodTypeConversionOptions
 */
export interface MethodTypeConversionOptions {
  /**
   *
   * @type {Array<TypeConversionOptions>}
   * @memberof MethodTypeConversionOptions
   */
  inputs: Array<TypeConversionOptions>;
  /**
   *
   * @type {Array<TypeConversionOptions>}
   * @memberof MethodTypeConversionOptions
   */
  outputs: Array<TypeConversionOptions>;
}
/**
 * An error response.
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * The unique error code.
   * @type {number}
   * @memberof ModelError
   */
  status: number;
  /**
   * The human-readable error message.
   * @type {string}
   * @memberof ModelError
   */
  message: string;
}
/**
 * Arguments to be passed into a contract function.
 * @export
 * @interface PostMethodArgs
 */
export interface PostMethodArgs {
  /**
   *
   * @type {string}
   * @memberof PostMethodArgs
   */
  signature?: string;
  /**
   * List of the function arguments.
   * @type {Array<any>}
   * @memberof PostMethodArgs
   */
  args?: Array<any>;
  /**
   * An Ethereum address (0x prefixed hex) or an address alias.
   * @type {string}
   * @memberof PostMethodArgs
   */
  from?: string;
  /**
   * Nonce to use for the transaction execution.
   * @type {number}
   * @memberof PostMethodArgs
   */
  nonce?: number;
  /**
   * Gas price to use for the transaction execution.
   * @type {number}
   * @memberof PostMethodArgs
   */
  gasPrice?: number;
  /**
   * Gas fee cap to use for the 1559 transaction execution.
   * @type {number}
   * @memberof PostMethodArgs
   */
  gasFeeCap?: number;
  /**
   * Gas priority fee cap to use for the 1559 transaction execution.
   * @type {number}
   * @memberof PostMethodArgs
   */
  gasTipCap?: number;
  /**
   * Gas limit to set for the transaction execution.
   * @type {number}
   * @memberof PostMethodArgs
   */
  gas?: number;
  /**
   * An Ethereum address (0x prefixed hex) or an address alias.
   * @type {string}
   * @memberof PostMethodArgs
   */
  to?: string;
  /**
   * Amount (in wei) to send with the transaction.
   * @type {string}
   * @memberof PostMethodArgs
   */
  value?: string;
  /**
   * If the `from` address is an HSM address and this flag is set to `true`, the transaction will be automatically signed and submitted to the blockchain.
   * @type {boolean}
   * @memberof PostMethodArgs
   */
  signAndSubmit?: boolean;
  /**
   * If the `from` address is an HSM address and this flag is set to `true`, MultiBaas will keep track of the nonce and set it accordingly. This is particularly useful when submitting multiple transactions concurrently or in a very short period of time. If this flag is set to `true` and a `nonce` is provided, it will reset the nonce tracker to the given nonce (useful if the nonce tracker is out of sync).
   * @type {boolean}
   * @memberof PostMethodArgs
   */
  nonceManagement?: boolean;
  /**
   * If set to `true`, forces a legacy type transaction. Otherwise an EIP-1559 transaction will created if the network supports it.
   * @type {boolean}
   * @memberof PostMethodArgs
   */
  preEIP1559?: boolean;
  /**
   * An Ethereum address (0x prefixed hex) or an address alias.
   * @type {string}
   * @memberof PostMethodArgs
   */
  signer?: string;
  /**
   * Mode to format integer outputs in the function call\'s responses. There are 3 possible modes:   - `auto` (the default option), where number format is decided by its type:     - If the type has size at most 32 bits, then the number is returned verbatim.     - If the type has size larger than 32 bits, then the number is returned as a string.   - `as_numbers`, where all numbers are returned verbatim.   - `as_strings`, where all numbers are returned as strings.
   * @type {string}
   * @memberof PostMethodArgs
   */
  formatInts?: string;
  /**
   * Call the function at a specific timestamp. Only available for read functions calls and if the `historical_blocks_feature` is enabled (see the plan endpoint). Mutually exclusive with the `blockNumber` parameter.
   * @type {string}
   * @memberof PostMethodArgs
   */
  timestamp?: string;
  /**
   * Call the function at a specific block. Only available for read functions calls and if the `historical_blocks_feature` is enabled (see the plan endpoint). Mutually exclusive with the `timestamp` parameter.
   * @type {string}
   * @memberof PostMethodArgs
   */
  blockNumber?: string;
  /**
   * If set to true the given address and contract don\'t need to be linked for the function to be called.
   * @type {boolean}
   * @memberof PostMethodArgs
   */
  contractOverride?: boolean;
  /**
   *
   * @type {PreviewArgs}
   * @memberof PostMethodArgs
   */
  preview?: PreviewArgs;
}
/**
 *
 * @export
 * @interface PostMethodResponse
 */
export interface PostMethodResponse {
  /**
   * The response object type (discriminator).
   * @type {string}
   * @memberof PostMethodResponse
   */
  kind: string;
}
/**
 * Ephemeral configuration for previewing the effect of a Type Conversion on a contract function call.
 * @export
 * @interface PreviewArgs
 */
export interface PreviewArgs {
  /**
   * Only preview the effect of a Type Conversion on the inputs. Only applicable for write function calls, where the output is an unsigned transaction.
   * @type {boolean}
   * @memberof PreviewArgs
   */
  inputsOnly: boolean;
  /**
   * Type Conversion information for the function inputs. The number of inputs must match that of the actual function inputs. The parameter is a contract function argument where only the type conversion information is used.
   * @type {Array<ContractABIMethodArgument>}
   * @memberof PreviewArgs
   */
  inputs: Array<ContractABIMethodArgument>;
  /**
   * Type Conversion information for the function outputs. The number of outputs must match that of the actual function outputs. The parameter is a contract function argument where only the type conversion information is used.
   * @type {Array<ContractABIMethodArgument>}
   * @memberof PreviewArgs
   */
  outputs: Array<ContractABIMethodArgument>;
}
/**
 * A role.
 * @export
 * @interface Role
 */
export interface Role {
  /**
   * The role ID.
   * @type {number}
   * @memberof Role
   */
  id: number;
  /**
   * The role name.
   * @type {string}
   * @memberof Role
   */
  name: string;
  /**
   * The role short name.
   * @type {string}
   * @memberof Role
   */
  shortName: string;
  /**
   * The role description.
   * @type {string}
   * @memberof Role
   */
  description: string;
}
/**
 * A saved event query.
 * @export
 * @interface SavedEventQuery
 */
export interface SavedEventQuery {
  /**
   *
   * @type {number}
   * @memberof SavedEventQuery
   */
  id: number;
  /**
   * An event query label.
   * @type {string}
   * @memberof SavedEventQuery
   */
  label: string;
  /**
   *
   * @type {EventQuery}
   * @memberof SavedEventQuery
   */
  query: EventQuery;
  /**
   * Specifies if this a system-generated query which is not modifiable by the user.
   * @type {boolean}
   * @memberof SavedEventQuery
   */
  isSystem: boolean;
}
/**
 *
 * @export
 * @interface SetAddress201Response
 */
export interface SetAddress201Response {
  /**
   * The status code.
   * @type {number}
   * @memberof SetAddress201Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof SetAddress201Response
   */
  message: string;
  /**
   *
   * @type {Address}
   * @memberof SetAddress201Response
   */
  result: Address;
}
/**
 * Authorization data for setCode operations.
 * @export
 * @interface SetCodeAuthorization
 */
export interface SetCodeAuthorization {
  /**
   * A hex string.
   * @type {string}
   * @memberof SetCodeAuthorization
   */
  chainId: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof SetCodeAuthorization
   */
  address: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof SetCodeAuthorization
   */
  nonce: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof SetCodeAuthorization
   */
  yParity: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof SetCodeAuthorization
   */
  r: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof SetCodeAuthorization
   */
  s: string;
}
/**
 * Request body representing a set local nonce request.
 * @export
 * @interface SetNonceRequest
 */
export interface SetNonceRequest {
  /**
   * If nonce is specified the provided value is set, otherwise the value is read from the blockchain.
   * @type {number}
   * @memberof SetNonceRequest
   */
  nonce?: number;
}
/**
 *
 * @export
 * @interface SignData200Response
 */
export interface SignData200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof SignData200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof SignData200Response
   */
  message: string;
  /**
   *
   * @type {HSMSignResponse}
   * @memberof SignData200Response
   */
  result: HSMSignResponse;
}
/**
 * A transaction that was signed externally and submitted.
 * @export
 * @interface SignedTransactionResponse
 */
export interface SignedTransactionResponse {
  /**
   *
   * @type {Transaction}
   * @memberof SignedTransactionResponse
   */
  tx: Transaction;
}
/**
 * The object used to receive a pre-signed raw transaction.
 * @export
 * @interface SignedTransactionSubmission
 */
export interface SignedTransactionSubmission {
  /**
   * The pre-signed raw transaction.
   * @type {string}
   * @memberof SignedTransactionSubmission
   */
  signedTx: string;
}
/**
 * A signer label.
 * @export
 * @interface SignerLabel
 */
export interface SignerLabel {
  /**
   * The label of the signer.
   * @type {string}
   * @memberof SignerLabel
   */
  label: string;
}
/**
 * A signer wallet.
 * @export
 * @interface SignerWallet
 */
export interface SignerWallet {
  /**
   * The type of the signer.
   * @type {string}
   * @memberof SignerWallet
   */
  type: SignerWalletTypeEnum;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof SignerWallet
   */
  wallet: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof SignerWallet
   */
  signer: string;
  /**
   * The label of the signer.
   * @type {string}
   * @memberof SignerWallet
   */
  label: string;
}

export const SignerWalletTypeEnum = {
  Web3: 'web3',
  Cloud: 'cloud',
  Multisig: 'multisig',
  Safe: 'safe'
} as const;

export type SignerWalletTypeEnum = typeof SignerWalletTypeEnum[keyof typeof SignerWalletTypeEnum];

/**
 * An object containing an HSM wallet\'s details.
 * @export
 * @interface StandaloneWallet
 */
export interface StandaloneWallet {
  /**
   * The Application ID that accesses the Key Vault.
   * @type {string}
   * @memberof StandaloneWallet
   */
  clientID?: string;
  /**
   * The Resource Group Name for the resource being accessed.
   * @type {string}
   * @memberof StandaloneWallet
   */
  baseGroupName: string;
  /**
   * The name given to the vault your key is stored in.
   * @type {string}
   * @memberof StandaloneWallet
   */
  vaultName?: string;
  /**
   * The name of the key.
   * @type {string}
   * @memberof StandaloneWallet
   */
  keyName: string;
  /**
   * The version of the key.
   * @type {string}
   * @memberof StandaloneWallet
   */
  keyVersion?: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof StandaloneWallet
   */
  publicAddress: string;
}
/**
 *
 * @export
 * @interface SubmitSignedTransaction200Response
 */
export interface SubmitSignedTransaction200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof SubmitSignedTransaction200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof SubmitSignedTransaction200Response
   */
  message: string;
  /**
   *
   * @type {SignedTransactionResponse}
   * @memberof SubmitSignedTransaction200Response
   */
  result: SignedTransactionResponse;
}
/**
 * A transaction from the Ethereum Blockchain.
 * @export
 * @interface Transaction
 */
export interface Transaction {
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  type: string;
  /**
   * A hex string or null.
   * @type {string}
   * @memberof Transaction
   */
  chainId?: string | null;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  nonce: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof Transaction
   */
  to: string | null;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof Transaction
   */
  from?: string | null;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  gas: string;
  /**
   * A hex string or null.
   * @type {string}
   * @memberof Transaction
   */
  gasPrice?: string | null;
  /**
   * A hex string or null.
   * @type {string}
   * @memberof Transaction
   */
  maxPriorityFeePerGas?: string | null;
  /**
   * A hex string or null.
   * @type {string}
   * @memberof Transaction
   */
  maxFeePerGas?: string | null;
  /**
   * A hex string or null.
   * @type {string}
   * @memberof Transaction
   */
  maxFeePerBlobGas?: string | null;
  /**
   * A hex string or null.
   * @type {string}
   * @memberof Transaction
   */
  value: string | null;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  input: string;
  /**
   *
   * @type {Array<AccessTuple>}
   * @memberof Transaction
   */
  accessList?: Array<AccessTuple> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof Transaction
   */
  blobVersionedHashes?: Array<string> | null;
  /**
   *
   * @type {Array<SetCodeAuthorization>}
   * @memberof Transaction
   */
  authorizationList?: Array<SetCodeAuthorization> | null;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  v: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  r: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof Transaction
   */
  s: string;
  /**
   * A hex string or null.
   * @type {string}
   * @memberof Transaction
   */
  yParity?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof Transaction
   */
  blobs?: Array<string> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof Transaction
   */
  commitments?: Array<string> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof Transaction
   */
  proofs?: Array<string> | null;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof Transaction
   */
  hash: string;
}
/**
 * The transaction data returned from a call to get transaction by hash.
 * @export
 * @interface TransactionData
 */
export interface TransactionData {
  /**
   *
   * @type {Transaction}
   * @memberof TransactionData
   */
  data: Transaction;
  /**
   * Whether the transaction has been included yet.
   * @type {boolean}
   * @memberof TransactionData
   */
  isPending: boolean;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof TransactionData
   */
  from: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof TransactionData
   */
  blockHash?: string;
  /**
   * The transaction block number.
   * @type {string}
   * @memberof TransactionData
   */
  blockNumber?: string;
  /**
   *
   * @type {ContractInformation}
   * @memberof TransactionData
   */
  contract?: ContractInformation;
  /**
   *
   * @type {ContractMethodInformation}
   * @memberof TransactionData
   */
  method?: ContractMethodInformation;
}
/**
 * The transaction information returned as part of an event.
 * @export
 * @interface TransactionInformation
 */
export interface TransactionInformation {
  /**
   * An ethereum address.
   * @type {string}
   * @memberof TransactionInformation
   */
  from: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionInformation
   */
  txData: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof TransactionInformation
   */
  txHash: string;
  /**
   * The location of the transaction in the block.
   * @type {number}
   * @memberof TransactionInformation
   */
  txIndexInBlock: number;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof TransactionInformation
   */
  blockHash: string;
  /**
   * The transaction block number.
   * @type {number}
   * @memberof TransactionInformation
   */
  blockNumber: number;
  /**
   *
   * @type {ContractInformation}
   * @memberof TransactionInformation
   */
  contract: ContractInformation;
  /**
   *
   * @type {ContractMethodInformation}
   * @memberof TransactionInformation
   */
  method: ContractMethodInformation;
}
/**
 * Record of the transaction\'s outcome.
 * @export
 * @interface TransactionReceipt
 */
export interface TransactionReceipt {
  /**
   *
   * @type {TransactionReceiptData}
   * @memberof TransactionReceipt
   */
  data: TransactionReceiptData;
  /**
   *
   * @type {Array<EventInformation>}
   * @memberof TransactionReceipt
   */
  events?: Array<EventInformation>;
}
/**
 *
 * @export
 * @interface TransactionReceiptData
 */
export interface TransactionReceiptData {
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  type?: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  root: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  status: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  cumulativeGasUsed: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  logsBloom: string;
  /**
   *
   * @type {Array<Log>}
   * @memberof TransactionReceiptData
   */
  logs: Array<Log>;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  transactionHash: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  contractAddress: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  gasUsed: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  effectiveGasPrice: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  blockNumber: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  transactionIndex: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof TransactionReceiptData
   */
  blockHash: string;
}
/**
 * The status of a TXM transaction.
 * @export
 * @enum {string}
 */

export const TransactionStatus = {
  Pending: 'pending',
  Included: 'included',
  Replaced: 'replaced',
  Cancelled: 'cancelled',
  Rejected: 'rejected',
  ExceededRetryLimit: 'exceeded retry limit'
} as const;

export type TransactionStatus = typeof TransactionStatus[keyof typeof TransactionStatus];

/**
 * A transaction to be signed.
 * @export
 * @interface TransactionToSign
 */
export interface TransactionToSign {
  /**
   *
   * @type {TransactionToSignTx}
   * @memberof TransactionToSign
   */
  tx: TransactionToSignTx;
  /**
   *
   * @type {boolean}
   * @memberof TransactionToSign
   */
  submitted: boolean;
}
/**
 *
 * @export
 * @interface TransactionToSignResponse
 */
export interface TransactionToSignResponse extends PostMethodResponse {
  /**
   *
   * @type {TransactionToSignTx}
   * @memberof TransactionToSignResponse
   */
  tx: TransactionToSignTx;
  /**
   *
   * @type {boolean}
   * @memberof TransactionToSignResponse
   */
  submitted: boolean;
}
/**
 * An Ethereum transaction.
 * @export
 * @interface TransactionToSignTx
 */
export interface TransactionToSignTx {
  /**
   * Sender account nonce of the transaction
   * @type {number}
   * @memberof TransactionToSignTx
   */
  nonce: number;
  /**
   * Gas price of the transaction
   * @type {string}
   * @memberof TransactionToSignTx
   */
  gasPrice?: string;
  /**
   * Fee cap per gas of the transaction
   * @type {string}
   * @memberof TransactionToSignTx
   */
  gasFeeCap?: string;
  /**
   * GasTipCap per gas of the transaction
   * @type {string}
   * @memberof TransactionToSignTx
   */
  gasTipCap?: string;
  /**
   * Gas limit of the transaction
   * @type {number}
   * @memberof TransactionToSignTx
   */
  gas: number;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof TransactionToSignTx
   */
  from: string;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof TransactionToSignTx
   */
  to?: string | null;
  /**
   * Amount (in wei) to send with the transaction.
   * @type {string}
   * @memberof TransactionToSignTx
   */
  value: string;
  /**
   * A hex string.
   * @type {string}
   * @memberof TransactionToSignTx
   */
  data: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof TransactionToSignTx
   */
  hash?: string;
  /**
   * Transaction type
   * @type {number}
   * @memberof TransactionToSignTx
   */
  type: number;
}
/**
 *
 * @export
 * @interface TransferEth200Response
 */
export interface TransferEth200Response {
  /**
   * The status code.
   * @type {number}
   * @memberof TransferEth200Response
   */
  status: number;
  /**
   * The human-readable status message.
   * @type {string}
   * @memberof TransferEth200Response
   */
  message: string;
  /**
   *
   * @type {TransactionToSign}
   * @memberof TransferEth200Response
   */
  result: TransactionToSign;
}
/**
 * Represents the set of type conversions allowed for a particular input or output of a function (how it may be \"cast\").
 * @export
 * @interface TypeConversionOptions
 */
export interface TypeConversionOptions {
  /**
   *
   * @type {Array<string>}
   * @memberof TypeConversionOptions
   */
  types?: Array<string> | null;
}
/**
 * A user.
 * @export
 * @interface User
 */
export interface User {
  /**
   * The user\'s email address.
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   * The user\'s name.
   * @type {string}
   * @memberof User
   */
  name: string;
  /**
   * The user ID.
   * @type {number}
   * @memberof User
   */
  id: number;
}
/**
 *
 * @export
 * @interface WalletTransaction
 */
export interface WalletTransaction {
  /**
   *
   * @type {Transaction}
   * @memberof WalletTransaction
   */
  tx: Transaction;
  /**
   *
   * @type {TransactionStatus}
   * @memberof WalletTransaction
   */
  status: TransactionStatus;
  /**
   * An ethereum address.
   * @type {string}
   * @memberof WalletTransaction
   */
  from: string;
  /**
   * The total number of resubmission attempts.
   * @type {number}
   * @memberof WalletTransaction
   */
  resubmissionAttempts: number;
  /**
   * The total number of successful resubmission (added into the transaction pool).
   * @type {number}
   * @memberof WalletTransaction
   */
  successfulResubmissions: number;
  /**
   * The time the transaction was created.
   * @type {string}
   * @memberof WalletTransaction
   */
  createdAt: string;
  /**
   * The time the transaction was last updated.
   * @type {string}
   * @memberof WalletTransaction
   */
  updatedAt: string;
  /**
   * Whether the transaction failed when it was included in a block.
   * @type {boolean}
   * @memberof WalletTransaction
   */
  failed?: boolean;
  /**
   * The block number that the transaction was included in.
   * @type {number}
   * @memberof WalletTransaction
   */
  blockNumber?: number;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   * @type {string}
   * @memberof WalletTransaction
   */
  blockHash?: string;
}

/**
 *
 * @export
 * @interface WebhookEndpoint
 */
export interface WebhookEndpoint {
  /**
   * The URL to send the webhook to.
   * @type {string}
   * @memberof WebhookEndpoint
   */
  url: string;
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   * @type {string}
   * @memberof WebhookEndpoint
   */
  label: string;
  /**
   * The events to subscribe to.
   * @type {Array<WebhookEventsType>}
   * @memberof WebhookEndpoint
   */
  subscriptions: Array<WebhookEventsType>;
  /**
   *
   * @type {number}
   * @memberof WebhookEndpoint
   */
  id: number;
  /**
   * The time the next attempt will be made.
   * @type {string}
   * @memberof WebhookEndpoint
   */
  nextAttempt?: string;
  /**
   * The time the last attempt was made.
   * @type {string}
   * @memberof WebhookEndpoint
   */
  lastAttempt?: string;
  /**
   * The number of failed webhook endpoint calls since the last successful call.
   * @type {number}
   * @memberof WebhookEndpoint
   */
  failedCalls: number;
  /**
   * The last error received from the webhook endpoint.
   * @type {string}
   * @memberof WebhookEndpoint
   */
  lastError?: string;
  /**
   * The time the webhook was created.
   * @type {string}
   * @memberof WebhookEndpoint
   */
  createdAt: string;
  /**
   * The time the webhook was last updated.
   * @type {string}
   * @memberof WebhookEndpoint
   */
  updatedAt: string;
  /**
   * The secret key used to sign the webhook.
   * @type {string}
   * @memberof WebhookEndpoint
   */
  secret: string;
}
/**
 *
 * @export
 * @interface WebhookEvent
 */
export interface WebhookEvent {
  /**
   * The ID of the webhook event.
   * @type {number}
   * @memberof WebhookEvent
   */
  id: number;
  /**
   *
   * @type {WebhookEventsType}
   * @memberof WebhookEvent
   */
  eventType: WebhookEventsType;
  /**
   * The data associated with the event.
   * @type {object}
   * @memberof WebhookEvent
   */
  data: object;
  /**
   * The time the webhook event was created.
   * @type {string}
   * @memberof WebhookEvent
   */
  createdAt: string;
  /**
   * The time the webhook event was last updated.
   * @type {string}
   * @memberof WebhookEvent
   */
  deliveredAt?: string;
}

/**
 * The type of the webhook event.
 * @export
 * @enum {string}
 */

export const WebhookEventsType = {
  TransactionIncluded: 'transaction.included',
  EventEmitted: 'event.emitted'
} as const;

export type WebhookEventsType = typeof WebhookEventsType[keyof typeof WebhookEventsType];

/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Deletes an address alias.
     * @summary Delete address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAddress: async (
      chain: ChainName,
      addressOrAlias: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('deleteAddress', 'chain', chain);
      // verify required parameter 'addressOrAlias' is not null or undefined
      assertParamExists('deleteAddress', 'addressOrAlias', addressOrAlias);
      const localVarPath = `/chains/{chain}/addresses/{address-or-alias}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-alias'}}`, encodeURIComponent(String(addressOrAlias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns details about an address.
     * @summary Get address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {Array<GetAddressIncludeEnum>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address. - &#x60;contractLookup&#x60; to get the contract(s) details for this address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress: async (
      chain: ChainName,
      addressOrAlias: string,
      include?: Array<GetAddressIncludeEnum>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getAddress', 'chain', chain);
      // verify required parameter 'addressOrAlias' is not null or undefined
      assertParamExists('getAddress', 'addressOrAlias', addressOrAlias);
      const localVarPath = `/chains/{chain}/addresses/{address-or-alias}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-alias'}}`, encodeURIComponent(String(addressOrAlias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (include) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the aliased addresses.
     * @summary List addresses
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses: async (chain: ChainName, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('listAddresses', 'chain', chain);
      const localVarPath = `/chains/{chain}/addresses`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Associates an address with an alias.
     * @summary Create or update address
     * @param {ChainName} chain The blockchain chain label.
     * @param {AddressAlias} addressAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAddress: async (
      chain: ChainName,
      addressAlias: AddressAlias,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('setAddress', 'chain', chain);
      // verify required parameter 'addressAlias' is not null or undefined
      assertParamExists('setAddress', 'addressAlias', addressAlias);
      const localVarPath = `/chains/{chain}/addresses`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(addressAlias, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration);
  return {
    /**
     * Deletes an address alias.
     * @summary Delete address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAddress(
      chain: ChainName,
      addressOrAlias: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAddress(chain, addressOrAlias, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AddressesApi.deleteAddress']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns details about an address.
     * @summary Get address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {Array<GetAddressIncludeEnum>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address. - &#x60;contractLookup&#x60; to get the contract(s) details for this address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAddress(
      chain: ChainName,
      addressOrAlias: string,
      include?: Array<GetAddressIncludeEnum>,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetAddress201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(chain, addressOrAlias, include, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AddressesApi.getAddress']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the aliased addresses.
     * @summary List addresses
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAddresses(
      chain: ChainName,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAddresses200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(chain, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AddressesApi.listAddresses']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Associates an address with an alias.
     * @summary Create or update address
     * @param {ChainName} chain The blockchain chain label.
     * @param {AddressAlias} addressAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setAddress(
      chain: ChainName,
      addressAlias: AddressAlias,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetAddress201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setAddress(chain, addressAlias, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AddressesApi.setAddress']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AddressesApiFp(configuration);
  return {
    /**
     * Deletes an address alias.
     * @summary Delete address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAddress(
      chain: ChainName,
      addressOrAlias: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp.deleteAddress(chain, addressOrAlias, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns details about an address.
     * @summary Get address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {Array<GetAddressIncludeEnum>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address. - &#x60;contractLookup&#x60; to get the contract(s) details for this address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress(
      chain: ChainName,
      addressOrAlias: string,
      include?: Array<GetAddressIncludeEnum>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SetAddress201Response> {
      return localVarFp.getAddress(chain, addressOrAlias, include, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the aliased addresses.
     * @summary List addresses
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses(chain: ChainName, options?: RawAxiosRequestConfig): AxiosPromise<ListAddresses200Response> {
      return localVarFp.listAddresses(chain, options).then((request) => request(axios, basePath));
    },
    /**
     * Associates an address with an alias.
     * @summary Create or update address
     * @param {ChainName} chain The blockchain chain label.
     * @param {AddressAlias} addressAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAddress(
      chain: ChainName,
      addressAlias: AddressAlias,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SetAddress201Response> {
      return localVarFp.setAddress(chain, addressAlias, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * AddressesApi - interface
 * @export
 * @interface AddressesApi
 */
export interface AddressesApiInterface {
  /**
   * Deletes an address alias.
   * @summary Delete address
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApiInterface
   */
  deleteAddress(chain: ChainName, addressOrAlias: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Returns details about an address.
   * @summary Get address
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {Array<GetAddressIncludeEnum>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address. - &#x60;contractLookup&#x60; to get the contract(s) details for this address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApiInterface
   */
  getAddress(
    chain: ChainName,
    addressOrAlias: string,
    include?: Array<GetAddressIncludeEnum>,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<SetAddress201Response>;

  /**
   * Returns all the aliased addresses.
   * @summary List addresses
   * @param {ChainName} chain The blockchain chain label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApiInterface
   */
  listAddresses(chain: ChainName, options?: RawAxiosRequestConfig): AxiosPromise<ListAddresses200Response>;

  /**
   * Associates an address with an alias.
   * @summary Create or update address
   * @param {ChainName} chain The blockchain chain label.
   * @param {AddressAlias} addressAlias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApiInterface
   */
  setAddress(
    chain: ChainName,
    addressAlias: AddressAlias,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<SetAddress201Response>;
}

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI implements AddressesApiInterface {
  /**
   * Deletes an address alias.
   * @summary Delete address
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public deleteAddress(chain: ChainName, addressOrAlias: string, options?: RawAxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .deleteAddress(chain, addressOrAlias, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns details about an address.
   * @summary Get address
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {Array<GetAddressIncludeEnum>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address. - &#x60;contractLookup&#x60; to get the contract(s) details for this address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public getAddress(
    chain: ChainName,
    addressOrAlias: string,
    include?: Array<GetAddressIncludeEnum>,
    options?: RawAxiosRequestConfig
  ) {
    return AddressesApiFp(this.configuration)
      .getAddress(chain, addressOrAlias, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the aliased addresses.
   * @summary List addresses
   * @param {ChainName} chain The blockchain chain label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public listAddresses(chain: ChainName, options?: RawAxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .listAddresses(chain, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Associates an address with an alias.
   * @summary Create or update address
   * @param {ChainName} chain The blockchain chain label.
   * @param {AddressAlias} addressAlias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public setAddress(chain: ChainName, addressAlias: AddressAlias, options?: RawAxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .setAddress(chain, addressAlias, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetAddressIncludeEnum = {
  Balance: 'balance',
  Code: 'code',
  Nonce: 'nonce',
  ContractLookup: 'contractLookup'
} as const;
export type GetAddressIncludeEnum = typeof GetAddressIncludeEnum[keyof typeof GetAddressIncludeEnum];

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Accepts a user invite.
     * @summary Accept invite
     * @param {string} inviteID
     * @param {AcceptInviteRequest} acceptInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInvite: async (
      inviteID: string,
      acceptInviteRequest: AcceptInviteRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'inviteID' is not null or undefined
      assertParamExists('acceptInvite', 'inviteID', inviteID);
      // verify required parameter 'acceptInviteRequest' is not null or undefined
      assertParamExists('acceptInvite', 'acceptInviteRequest', acceptInviteRequest);
      const localVarPath = `/invites/{inviteID}`.replace(`{${'inviteID'}}`, encodeURIComponent(String(inviteID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds a CORS origin.
     * @summary Add CORS origin
     * @param {CORSOrigin} cORSOrigin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCorsOrigin: async (cORSOrigin: CORSOrigin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'cORSOrigin' is not null or undefined
      assertParamExists('addCorsOrigin', 'cORSOrigin', cORSOrigin);
      const localVarPath = `/cors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cORSOrigin, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds an API key to a group.
     * @summary Add API key to group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupApiKey: async (
      groupID: number,
      apiKeyID: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('addGroupApiKey', 'groupID', groupID);
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('addGroupApiKey', 'apiKeyID', apiKeyID);
      const localVarPath = `/groups/{groupID}/api_keys/{apiKeyID}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds a role to a group.
     * @summary Add role to group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupRole: async (
      groupID: number,
      roleShortName: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('addGroupRole', 'groupID', groupID);
      // verify required parameter 'roleShortName' is not null or undefined
      assertParamExists('addGroupRole', 'roleShortName', roleShortName);
      const localVarPath = `/groups/{groupID}/roles/{roleShortName}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'roleShortName'}}`, encodeURIComponent(String(roleShortName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds a user to a group.
     * @summary Add user to group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupUser: async (
      groupID: number,
      userID: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('addGroupUser', 'groupID', groupID);
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('addGroupUser', 'userID', userID);
      const localVarPath = `/groups/{groupID}/users/{userID}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Checks if a user invite is valid.
     * @summary Check invite
     * @param {string} inviteID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkInvite: async (inviteID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'inviteID' is not null or undefined
      assertParamExists('checkInvite', 'inviteID', inviteID);
      const localVarPath = `/invites/{inviteID}`.replace(`{${'inviteID'}}`, encodeURIComponent(String(inviteID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates an API key and adds it to group IDs.
     * @summary Create API key
     * @param {CreateApiKeyRequest} createApiKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey: async (
      createApiKeyRequest: CreateApiKeyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createApiKeyRequest' is not null or undefined
      assertParamExists('createApiKey', 'createApiKeyRequest', createApiKeyRequest);
      const localVarPath = `/api_keys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createApiKeyRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an API key.
     * @summary Delete API key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey: async (apiKeyID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('deleteApiKey', 'apiKeyID', apiKeyID);
      const localVarPath = `/api_keys/{apiKeyID}`.replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a user invite.
     * @summary Delete invite
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvite: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('deleteInvite', 'email', email);
      const localVarPath = `/invites/{email}/delete`.replace(`{${'email'}}`, encodeURIComponent(String(email)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a user.
     * @summary Delete user
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (userID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('deleteUser', 'userID', userID);
      const localVarPath = `/users/{userID}`.replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns an API key.
     * @summary Get API Key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey: async (apiKeyID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('getApiKey', 'apiKeyID', apiKeyID);
      const localVarPath = `/api_keys/{apiKeyID}`.replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Invites a new user.
     * @summary Invite user
     * @param {InviteRequest} inviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteUser: async (inviteRequest: InviteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'inviteRequest' is not null or undefined
      assertParamExists('inviteUser', 'inviteRequest', inviteRequest);
      const localVarPath = `/invites`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(inviteRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the API keys.
     * @summary List API keys
     * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys: async (all?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api_keys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (all !== undefined) {
        localVarQueryParameter['all'] = all;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the audit logs.
     * @summary List audit logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAuditLogs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/systemactivities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of CORS origins.
     * @summary List CORS origins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCorsOrigins: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/cors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the groups.
     * @summary List groups
     * @param {number} [userID]
     * @param {number} [apiKeyID]
     * @param {boolean} [assignable]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroups: async (
      userID?: number,
      apiKeyID?: number,
      assignable?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/groups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (userID !== undefined) {
        localVarQueryParameter['userID'] = userID;
      }

      if (apiKeyID !== undefined) {
        localVarQueryParameter['apiKeyID'] = apiKeyID;
      }

      if (assignable !== undefined) {
        localVarQueryParameter['assignable'] = assignable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the user invites.
     * @summary List invites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvites: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/invites`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the signers for a user.
     * @summary List user signers
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserSigners: async (userID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('listUserSigners', 'userID', userID);
      const localVarPath = `/users/{userID}/signers`.replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the users.
     * @summary List users
     * @param {number} [groupID]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers: async (groupID?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (groupID !== undefined) {
        localVarQueryParameter['groupID'] = groupID;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a CORS origin.
     * @summary Remove CORS Origin
     * @param {number} originID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCorsOrigin: async (originID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'originID' is not null or undefined
      assertParamExists('removeCorsOrigin', 'originID', originID);
      const localVarPath = `/cors/{originID}`.replace(`{${'originID'}}`, encodeURIComponent(String(originID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes an API key from a group.
     * @summary Remove API key from group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupApiKey: async (
      groupID: number,
      apiKeyID: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('removeGroupApiKey', 'groupID', groupID);
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('removeGroupApiKey', 'apiKeyID', apiKeyID);
      const localVarPath = `/groups/{groupID}/api_keys/{apiKeyID}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a role from a group.
     * @summary Remove role from group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupRole: async (
      groupID: number,
      roleShortName: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('removeGroupRole', 'groupID', groupID);
      // verify required parameter 'roleShortName' is not null or undefined
      assertParamExists('removeGroupRole', 'roleShortName', roleShortName);
      const localVarPath = `/groups/{groupID}/roles/{roleShortName}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'roleShortName'}}`, encodeURIComponent(String(roleShortName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a user from a group.
     * @summary Remove user from group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupUser: async (
      groupID: number,
      userID: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('removeGroupUser', 'groupID', groupID);
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('removeGroupUser', 'userID', userID);
      const localVarPath = `/groups/{groupID}/users/{userID}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a cloud wallet signer from a user.
     * @summary Remove user cloud wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserSignerCloudWallet: async (
      userID: number,
      walletAddress: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('removeUserSignerCloudWallet', 'userID', userID);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('removeUserSignerCloudWallet', 'walletAddress', walletAddress);
      const localVarPath = `/users/{userID}/cloudwallets/{wallet_address}`
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a safe account signer from a user.
     * @summary Remove user safe account signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserSignerSafeAccount: async (
      userID: number,
      walletAddress: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('removeUserSignerSafeAccount', 'userID', userID);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('removeUserSignerSafeAccount', 'walletAddress', walletAddress);
      const localVarPath = `/users/{userID}/safeaccounts/{wallet_address}`
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a web3 wallet signer from a user.
     * @summary Remove user web3 wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserSignerWeb3Wallet: async (
      userID: number,
      walletAddress: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('removeUserSignerWeb3Wallet', 'userID', userID);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('removeUserSignerWeb3Wallet', 'walletAddress', walletAddress);
      const localVarPath = `/users/{userID}/web3wallets/{wallet_address}`
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds or updates a user\'s cloud wallet signer.
     * @summary Add or update user cloud wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserSignerCloudWallet: async (
      userID: number,
      walletAddress: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('setUserSignerCloudWallet', 'userID', userID);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('setUserSignerCloudWallet', 'walletAddress', walletAddress);
      const localVarPath = `/users/{userID}/cloudwallets/{wallet_address}`
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds or updates a user\'s safe account signer.
     * @summary Add or update user safe account signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {SignerLabel} signerLabel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserSignerSafeAccount: async (
      userID: number,
      walletAddress: string,
      signerLabel: SignerLabel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('setUserSignerSafeAccount', 'userID', userID);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('setUserSignerSafeAccount', 'walletAddress', walletAddress);
      // verify required parameter 'signerLabel' is not null or undefined
      assertParamExists('setUserSignerSafeAccount', 'signerLabel', signerLabel);
      const localVarPath = `/users/{userID}/safeaccounts/{wallet_address}`
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(signerLabel, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds or updates a user\'s web3 wallet signer.
     * @summary Add or update user web3 wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {SignerLabel} signerLabel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserSignerWeb3Wallet: async (
      userID: number,
      walletAddress: string,
      signerLabel: SignerLabel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('setUserSignerWeb3Wallet', 'userID', userID);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('setUserSignerWeb3Wallet', 'walletAddress', walletAddress);
      // verify required parameter 'signerLabel' is not null or undefined
      assertParamExists('setUserSignerWeb3Wallet', 'signerLabel', signerLabel);
      const localVarPath = `/users/{userID}/web3wallets/{wallet_address}`
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(signerLabel, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates an API key.
     * @summary Update API key
     * @param {number} apiKeyID
     * @param {BaseAPIKey} baseAPIKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApiKey: async (
      apiKeyID: number,
      baseAPIKey: BaseAPIKey,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('updateApiKey', 'apiKeyID', apiKeyID);
      // verify required parameter 'baseAPIKey' is not null or undefined
      assertParamExists('updateApiKey', 'baseAPIKey', baseAPIKey);
      const localVarPath = `/api_keys/{apiKeyID}`.replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseAPIKey, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration);
  return {
    /**
     * Accepts a user invite.
     * @summary Accept invite
     * @param {string} inviteID
     * @param {AcceptInviteRequest} acceptInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async acceptInvite(
      inviteID: string,
      acceptInviteRequest: AcceptInviteRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcceptInvite200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(inviteID, acceptInviteRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.acceptInvite']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds a CORS origin.
     * @summary Add CORS origin
     * @param {CORSOrigin} cORSOrigin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addCorsOrigin(
      cORSOrigin: CORSOrigin,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addCorsOrigin(cORSOrigin, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.addCorsOrigin']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds an API key to a group.
     * @summary Add API key to group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGroupApiKey(
      groupID: number,
      apiKeyID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupApiKey(groupID, apiKeyID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.addGroupApiKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds a role to a group.
     * @summary Add role to group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGroupRole(
      groupID: number,
      roleShortName: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupRole(groupID, roleShortName, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.addGroupRole']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds a user to a group.
     * @summary Add user to group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGroupUser(
      groupID: number,
      userID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupUser(groupID, userID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.addGroupUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Checks if a user invite is valid.
     * @summary Check invite
     * @param {string} inviteID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkInvite(
      inviteID: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkInvite(inviteID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.checkInvite']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates an API key and adds it to group IDs.
     * @summary Create API key
     * @param {CreateApiKeyRequest} createApiKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApiKey(
      createApiKeyRequest: CreateApiKeyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateApiKey200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(createApiKeyRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.createApiKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes an API key.
     * @summary Delete API key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApiKey(
      apiKeyID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(apiKeyID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.deleteApiKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes a user invite.
     * @summary Delete invite
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteInvite(
      email: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvite(email, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.deleteInvite']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes a user.
     * @summary Delete user
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.deleteUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns an API key.
     * @summary Get API Key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKey(
      apiKeyID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApiKey200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKey(apiKeyID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.getApiKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Invites a new user.
     * @summary Invite user
     * @param {InviteRequest} inviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async inviteUser(
      inviteRequest: InviteRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUser(inviteRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.inviteUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the API keys.
     * @summary List API keys
     * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listApiKeys(
      all?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApiKeys200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeys(all, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listApiKeys']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the audit logs.
     * @summary List audit logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAuditLogs(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAuditLogs200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAuditLogs(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listAuditLogs']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of CORS origins.
     * @summary List CORS origins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCorsOrigins(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCorsOrigins200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listCorsOrigins(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listCorsOrigins']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the groups.
     * @summary List groups
     * @param {number} [userID]
     * @param {number} [apiKeyID]
     * @param {boolean} [assignable]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGroups(
      userID?: number,
      apiKeyID?: number,
      assignable?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListGroups200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(userID, apiKeyID, assignable, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listGroups']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the user invites.
     * @summary List invites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInvites(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListInvites200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listInvites(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listInvites']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the signers for a user.
     * @summary List user signers
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUserSigners(
      userID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUserSigners200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUserSigners(userID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listUserSigners']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the users.
     * @summary List users
     * @param {number} [groupID]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUsers(
      groupID?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsers200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(groupID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listUsers']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes a CORS origin.
     * @summary Remove CORS Origin
     * @param {number} originID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeCorsOrigin(
      originID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeCorsOrigin(originID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeCorsOrigin']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes an API key from a group.
     * @summary Remove API key from group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeGroupApiKey(
      groupID: number,
      apiKeyID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeGroupApiKey(groupID, apiKeyID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeGroupApiKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes a role from a group.
     * @summary Remove role from group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeGroupRole(
      groupID: number,
      roleShortName: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeGroupRole(groupID, roleShortName, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeGroupRole']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes a user from a group.
     * @summary Remove user from group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeGroupUser(
      groupID: number,
      userID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeGroupUser(groupID, userID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeGroupUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes a cloud wallet signer from a user.
     * @summary Remove user cloud wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeUserSignerCloudWallet(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserSignerCloudWallet(
        userID,
        walletAddress,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeUserSignerCloudWallet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes a safe account signer from a user.
     * @summary Remove user safe account signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeUserSignerSafeAccount(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserSignerSafeAccount(
        userID,
        walletAddress,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeUserSignerSafeAccount']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes a web3 wallet signer from a user.
     * @summary Remove user web3 wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeUserSignerWeb3Wallet(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserSignerWeb3Wallet(
        userID,
        walletAddress,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeUserSignerWeb3Wallet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds or updates a user\'s cloud wallet signer.
     * @summary Add or update user cloud wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserSignerCloudWallet(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserSignerCloudWallet(
        userID,
        walletAddress,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.setUserSignerCloudWallet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds or updates a user\'s safe account signer.
     * @summary Add or update user safe account signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {SignerLabel} signerLabel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserSignerSafeAccount(
      userID: number,
      walletAddress: string,
      signerLabel: SignerLabel,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserSignerSafeAccount(
        userID,
        walletAddress,
        signerLabel,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.setUserSignerSafeAccount']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds or updates a user\'s web3 wallet signer.
     * @summary Add or update user web3 wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {SignerLabel} signerLabel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserSignerWeb3Wallet(
      userID: number,
      walletAddress: string,
      signerLabel: SignerLabel,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserSignerWeb3Wallet(
        userID,
        walletAddress,
        signerLabel,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.setUserSignerWeb3Wallet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Updates an API key.
     * @summary Update API key
     * @param {number} apiKeyID
     * @param {BaseAPIKey} baseAPIKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateApiKey(
      apiKeyID: number,
      baseAPIKey: BaseAPIKey,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateApiKey(apiKeyID, baseAPIKey, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.updateApiKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AdminApiFp(configuration);
  return {
    /**
     * Accepts a user invite.
     * @summary Accept invite
     * @param {string} inviteID
     * @param {AcceptInviteRequest} acceptInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInvite(
      inviteID: string,
      acceptInviteRequest: AcceptInviteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AcceptInvite200Response> {
      return localVarFp
        .acceptInvite(inviteID, acceptInviteRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds a CORS origin.
     * @summary Add CORS origin
     * @param {CORSOrigin} cORSOrigin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCorsOrigin(cORSOrigin: CORSOrigin, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.addCorsOrigin(cORSOrigin, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds an API key to a group.
     * @summary Add API key to group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupApiKey(groupID: number, apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.addGroupApiKey(groupID, apiKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds a role to a group.
     * @summary Add role to group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupRole(groupID: number, roleShortName: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.addGroupRole(groupID, roleShortName, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds a user to a group.
     * @summary Add user to group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupUser(groupID: number, userID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.addGroupUser(groupID, userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Checks if a user invite is valid.
     * @summary Check invite
     * @param {string} inviteID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkInvite(inviteID: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.checkInvite(inviteID, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates an API key and adds it to group IDs.
     * @summary Create API key
     * @param {CreateApiKeyRequest} createApiKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(
      createApiKeyRequest: CreateApiKeyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CreateApiKey200Response> {
      return localVarFp.createApiKey(createApiKeyRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes an API key.
     * @summary Delete API key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey(apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.deleteApiKey(apiKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a user invite.
     * @summary Delete invite
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvite(email: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.deleteInvite(email, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a user.
     * @summary Delete user
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.deleteUser(userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns an API key.
     * @summary Get API Key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey(apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<GetApiKey200Response> {
      return localVarFp.getApiKey(apiKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Invites a new user.
     * @summary Invite user
     * @param {InviteRequest} inviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteUser(inviteRequest: InviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.inviteUser(inviteRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the API keys.
     * @summary List API keys
     * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys(all?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListApiKeys200Response> {
      return localVarFp.listApiKeys(all, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the audit logs.
     * @summary List audit logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAuditLogs(options?: RawAxiosRequestConfig): AxiosPromise<ListAuditLogs200Response> {
      return localVarFp.listAuditLogs(options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of CORS origins.
     * @summary List CORS origins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCorsOrigins(options?: RawAxiosRequestConfig): AxiosPromise<ListCorsOrigins200Response> {
      return localVarFp.listCorsOrigins(options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the groups.
     * @summary List groups
     * @param {number} [userID]
     * @param {number} [apiKeyID]
     * @param {boolean} [assignable]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroups(
      userID?: number,
      apiKeyID?: number,
      assignable?: boolean,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListGroups200Response> {
      return localVarFp.listGroups(userID, apiKeyID, assignable, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the user invites.
     * @summary List invites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvites(options?: RawAxiosRequestConfig): AxiosPromise<ListInvites200Response> {
      return localVarFp.listInvites(options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the signers for a user.
     * @summary List user signers
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserSigners(userID: number, options?: RawAxiosRequestConfig): AxiosPromise<ListUserSigners200Response> {
      return localVarFp.listUserSigners(userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the users.
     * @summary List users
     * @param {number} [groupID]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(groupID?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListUsers200Response> {
      return localVarFp.listUsers(groupID, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes a CORS origin.
     * @summary Remove CORS Origin
     * @param {number} originID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCorsOrigin(originID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.removeCorsOrigin(originID, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes an API key from a group.
     * @summary Remove API key from group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupApiKey(groupID: number, apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.removeGroupApiKey(groupID, apiKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes a role from a group.
     * @summary Remove role from group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupRole(
      groupID: number,
      roleShortName: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp.removeGroupRole(groupID, roleShortName, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes a user from a group.
     * @summary Remove user from group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupUser(groupID: number, userID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.removeGroupUser(groupID, userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes a cloud wallet signer from a user.
     * @summary Remove user cloud wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserSignerCloudWallet(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .removeUserSignerCloudWallet(userID, walletAddress, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Removes a safe account signer from a user.
     * @summary Remove user safe account signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserSignerSafeAccount(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .removeUserSignerSafeAccount(userID, walletAddress, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Removes a web3 wallet signer from a user.
     * @summary Remove user web3 wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserSignerWeb3Wallet(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .removeUserSignerWeb3Wallet(userID, walletAddress, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds or updates a user\'s cloud wallet signer.
     * @summary Add or update user cloud wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserSignerCloudWallet(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setUserSignerCloudWallet(userID, walletAddress, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds or updates a user\'s safe account signer.
     * @summary Add or update user safe account signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {SignerLabel} signerLabel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserSignerSafeAccount(
      userID: number,
      walletAddress: string,
      signerLabel: SignerLabel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setUserSignerSafeAccount(userID, walletAddress, signerLabel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds or updates a user\'s web3 wallet signer.
     * @summary Add or update user web3 wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {SignerLabel} signerLabel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserSignerWeb3Wallet(
      userID: number,
      walletAddress: string,
      signerLabel: SignerLabel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setUserSignerWeb3Wallet(userID, walletAddress, signerLabel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates an API key.
     * @summary Update API key
     * @param {number} apiKeyID
     * @param {BaseAPIKey} baseAPIKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApiKey(
      apiKeyID: number,
      baseAPIKey: BaseAPIKey,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp.updateApiKey(apiKeyID, baseAPIKey, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * AdminApi - interface
 * @export
 * @interface AdminApi
 */
export interface AdminApiInterface {
  /**
   * Accepts a user invite.
   * @summary Accept invite
   * @param {string} inviteID
   * @param {AcceptInviteRequest} acceptInviteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  acceptInvite(
    inviteID: string,
    acceptInviteRequest: AcceptInviteRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<AcceptInvite200Response>;

  /**
   * Adds a CORS origin.
   * @summary Add CORS origin
   * @param {CORSOrigin} cORSOrigin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  addCorsOrigin(cORSOrigin: CORSOrigin, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Adds an API key to a group.
   * @summary Add API key to group
   * @param {number} groupID
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  addGroupApiKey(groupID: number, apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Adds a role to a group.
   * @summary Add role to group
   * @param {number} groupID
   * @param {string} roleShortName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  addGroupRole(groupID: number, roleShortName: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Adds a user to a group.
   * @summary Add user to group
   * @param {number} groupID
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  addGroupUser(groupID: number, userID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Checks if a user invite is valid.
   * @summary Check invite
   * @param {string} inviteID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  checkInvite(inviteID: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Creates an API key and adds it to group IDs.
   * @summary Create API key
   * @param {CreateApiKeyRequest} createApiKeyRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  createApiKey(
    createApiKeyRequest: CreateApiKeyRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<CreateApiKey200Response>;

  /**
   * Deletes an API key.
   * @summary Delete API key
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  deleteApiKey(apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Deletes a user invite.
   * @summary Delete invite
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  deleteInvite(email: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   * Deletes a user.
   * @summary Delete user
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  deleteUser(userID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Returns an API key.
   * @summary Get API Key
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  getApiKey(apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<GetApiKey200Response>;

  /**
   * Invites a new user.
   * @summary Invite user
   * @param {InviteRequest} inviteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  inviteUser(inviteRequest: InviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Returns all the API keys.
   * @summary List API keys
   * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  listApiKeys(all?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListApiKeys200Response>;

  /**
   * Returns the audit logs.
   * @summary List audit logs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  listAuditLogs(options?: RawAxiosRequestConfig): AxiosPromise<ListAuditLogs200Response>;

  /**
   * Returns a list of CORS origins.
   * @summary List CORS origins
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  listCorsOrigins(options?: RawAxiosRequestConfig): AxiosPromise<ListCorsOrigins200Response>;

  /**
   * Returns all the groups.
   * @summary List groups
   * @param {number} [userID]
   * @param {number} [apiKeyID]
   * @param {boolean} [assignable]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  listGroups(
    userID?: number,
    apiKeyID?: number,
    assignable?: boolean,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ListGroups200Response>;

  /**
   * Returns all the user invites.
   * @summary List invites
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  listInvites(options?: RawAxiosRequestConfig): AxiosPromise<ListInvites200Response>;

  /**
   * Returns all the signers for a user.
   * @summary List user signers
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  listUserSigners(userID: number, options?: RawAxiosRequestConfig): AxiosPromise<ListUserSigners200Response>;

  /**
   * Returns all the users.
   * @summary List users
   * @param {number} [groupID]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  listUsers(groupID?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListUsers200Response>;

  /**
   * Removes a CORS origin.
   * @summary Remove CORS Origin
   * @param {number} originID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  removeCorsOrigin(originID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Removes an API key from a group.
   * @summary Remove API key from group
   * @param {number} groupID
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  removeGroupApiKey(groupID: number, apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Removes a role from a group.
   * @summary Remove role from group
   * @param {number} groupID
   * @param {string} roleShortName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  removeGroupRole(groupID: number, roleShortName: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Removes a user from a group.
   * @summary Remove user from group
   * @param {number} groupID
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  removeGroupUser(groupID: number, userID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Removes a cloud wallet signer from a user.
   * @summary Remove user cloud wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  removeUserSignerCloudWallet(
    userID: number,
    walletAddress: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Removes a safe account signer from a user.
   * @summary Remove user safe account signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  removeUserSignerSafeAccount(
    userID: number,
    walletAddress: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Removes a web3 wallet signer from a user.
   * @summary Remove user web3 wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  removeUserSignerWeb3Wallet(
    userID: number,
    walletAddress: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Adds or updates a user\'s cloud wallet signer.
   * @summary Add or update user cloud wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  setUserSignerCloudWallet(
    userID: number,
    walletAddress: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Adds or updates a user\'s safe account signer.
   * @summary Add or update user safe account signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {SignerLabel} signerLabel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  setUserSignerSafeAccount(
    userID: number,
    walletAddress: string,
    signerLabel: SignerLabel,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Adds or updates a user\'s web3 wallet signer.
   * @summary Add or update user web3 wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {SignerLabel} signerLabel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  setUserSignerWeb3Wallet(
    userID: number,
    walletAddress: string,
    signerLabel: SignerLabel,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Updates an API key.
   * @summary Update API key
   * @param {number} apiKeyID
   * @param {BaseAPIKey} baseAPIKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApiInterface
   */
  updateApiKey(apiKeyID: number, baseAPIKey: BaseAPIKey, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;
}

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI implements AdminApiInterface {
  /**
   * Accepts a user invite.
   * @summary Accept invite
   * @param {string} inviteID
   * @param {AcceptInviteRequest} acceptInviteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public acceptInvite(inviteID: string, acceptInviteRequest: AcceptInviteRequest, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .acceptInvite(inviteID, acceptInviteRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a CORS origin.
   * @summary Add CORS origin
   * @param {CORSOrigin} cORSOrigin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addCorsOrigin(cORSOrigin: CORSOrigin, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .addCorsOrigin(cORSOrigin, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an API key to a group.
   * @summary Add API key to group
   * @param {number} groupID
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addGroupApiKey(groupID: number, apiKeyID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .addGroupApiKey(groupID, apiKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a role to a group.
   * @summary Add role to group
   * @param {number} groupID
   * @param {string} roleShortName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addGroupRole(groupID: number, roleShortName: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .addGroupRole(groupID, roleShortName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a user to a group.
   * @summary Add user to group
   * @param {number} groupID
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addGroupUser(groupID: number, userID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .addGroupUser(groupID, userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Checks if a user invite is valid.
   * @summary Check invite
   * @param {string} inviteID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public checkInvite(inviteID: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .checkInvite(inviteID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates an API key and adds it to group IDs.
   * @summary Create API key
   * @param {CreateApiKeyRequest} createApiKeyRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public createApiKey(createApiKeyRequest: CreateApiKeyRequest, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .createApiKey(createApiKeyRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes an API key.
   * @summary Delete API key
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteApiKey(apiKeyID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .deleteApiKey(apiKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a user invite.
   * @summary Delete invite
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteInvite(email: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .deleteInvite(email, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a user.
   * @summary Delete user
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteUser(userID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .deleteUser(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns an API key.
   * @summary Get API Key
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getApiKey(apiKeyID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .getApiKey(apiKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Invites a new user.
   * @summary Invite user
   * @param {InviteRequest} inviteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public inviteUser(inviteRequest: InviteRequest, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .inviteUser(inviteRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the API keys.
   * @summary List API keys
   * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public listApiKeys(all?: boolean, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listApiKeys(all, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the audit logs.
   * @summary List audit logs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public listAuditLogs(options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listAuditLogs(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of CORS origins.
   * @summary List CORS origins
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public listCorsOrigins(options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listCorsOrigins(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the groups.
   * @summary List groups
   * @param {number} [userID]
   * @param {number} [apiKeyID]
   * @param {boolean} [assignable]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public listGroups(userID?: number, apiKeyID?: number, assignable?: boolean, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listGroups(userID, apiKeyID, assignable, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the user invites.
   * @summary List invites
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public listInvites(options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listInvites(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the signers for a user.
   * @summary List user signers
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public listUserSigners(userID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listUserSigners(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the users.
   * @summary List users
   * @param {number} [groupID]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public listUsers(groupID?: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listUsers(groupID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a CORS origin.
   * @summary Remove CORS Origin
   * @param {number} originID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeCorsOrigin(originID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeCorsOrigin(originID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes an API key from a group.
   * @summary Remove API key from group
   * @param {number} groupID
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeGroupApiKey(groupID: number, apiKeyID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeGroupApiKey(groupID, apiKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a role from a group.
   * @summary Remove role from group
   * @param {number} groupID
   * @param {string} roleShortName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeGroupRole(groupID: number, roleShortName: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeGroupRole(groupID, roleShortName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a user from a group.
   * @summary Remove user from group
   * @param {number} groupID
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeGroupUser(groupID: number, userID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeGroupUser(groupID, userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a cloud wallet signer from a user.
   * @summary Remove user cloud wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeUserSignerCloudWallet(userID: number, walletAddress: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeUserSignerCloudWallet(userID, walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a safe account signer from a user.
   * @summary Remove user safe account signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeUserSignerSafeAccount(userID: number, walletAddress: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeUserSignerSafeAccount(userID, walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a web3 wallet signer from a user.
   * @summary Remove user web3 wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeUserSignerWeb3Wallet(userID: number, walletAddress: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeUserSignerWeb3Wallet(userID, walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds or updates a user\'s cloud wallet signer.
   * @summary Add or update user cloud wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public setUserSignerCloudWallet(userID: number, walletAddress: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .setUserSignerCloudWallet(userID, walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds or updates a user\'s safe account signer.
   * @summary Add or update user safe account signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {SignerLabel} signerLabel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public setUserSignerSafeAccount(
    userID: number,
    walletAddress: string,
    signerLabel: SignerLabel,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .setUserSignerSafeAccount(userID, walletAddress, signerLabel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds or updates a user\'s web3 wallet signer.
   * @summary Add or update user web3 wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {SignerLabel} signerLabel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public setUserSignerWeb3Wallet(
    userID: number,
    walletAddress: string,
    signerLabel: SignerLabel,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .setUserSignerWeb3Wallet(userID, walletAddress, signerLabel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates an API key.
   * @summary Update API key
   * @param {number} apiKeyID
   * @param {BaseAPIKey} baseAPIKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public updateApiKey(apiKeyID: number, baseAPIKey: BaseAPIKey, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .updateApiKey(apiKeyID, baseAPIKey, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ChainsApi - axios parameter creator
 * @export
 */
export const ChainsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns a block.
     * @summary Get a block
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlock: async (chain: ChainName, block: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getBlock', 'chain', chain);
      // verify required parameter 'block' is not null or undefined
      assertParamExists('getBlock', 'block', block);
      const localVarPath = `/chains/{chain}/blocks/{block}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'block'}}`, encodeURIComponent(String(block)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the chain status.
     * @summary Get chain status
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChainStatus: async (chain: ChainName, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getChainStatus', 'chain', chain);
      const localVarPath = `/chains/{chain}/status`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a transaction.
     * @summary Get transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash A transaction hash.
     * @param {GetTransactionIncludeEnum} [include] Include contract and method call details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction: async (
      chain: ChainName,
      hash: string,
      include?: GetTransactionIncludeEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getTransaction', 'chain', chain);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('getTransaction', 'hash', hash);
      const localVarPath = `/chains/{chain}/transactions/{hash}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'hash'}}`, encodeURIComponent(String(hash)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
     * @summary Get transaction receipt
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash A transaction hash.
     * @param {GetTransactionReceiptIncludeEnum} [include] Include contract and event details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionReceipt: async (
      chain: ChainName,
      hash: string,
      include?: GetTransactionReceiptIncludeEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getTransactionReceipt', 'chain', chain);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('getTransactionReceipt', 'hash', hash);
      const localVarPath = `/chains/{chain}/transactions/receipt/{hash}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'hash'}}`, encodeURIComponent(String(hash)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Receives a pre-signed raw transaction and submits it to the blockchain.
     * @summary Submit signed transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {SignedTransactionSubmission} signedTransactionSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitSignedTransaction: async (
      chain: ChainName,
      signedTransactionSubmission: SignedTransactionSubmission,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('submitSignedTransaction', 'chain', chain);
      // verify required parameter 'signedTransactionSubmission' is not null or undefined
      assertParamExists('submitSignedTransaction', 'signedTransactionSubmission', signedTransactionSubmission);
      const localVarPath = `/chains/{chain}/transactions/submit`.replace(
        `{${'chain'}}`,
        encodeURIComponent(String(chain))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signedTransactionSubmission,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a transaction for sending the native token between addresses.
     * @summary Transfer ETH
     * @param {ChainName} chain The blockchain chain label.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferEth: async (
      chain: ChainName,
      postMethodArgs: PostMethodArgs,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('transferEth', 'chain', chain);
      // verify required parameter 'postMethodArgs' is not null or undefined
      assertParamExists('transferEth', 'postMethodArgs', postMethodArgs);
      const localVarPath = `/chains/{chain}/transfers`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMethodArgs, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ChainsApi - functional programming interface
 * @export
 */
export const ChainsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ChainsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a block.
     * @summary Get a block
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlock(
      chain: ChainName,
      block: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBlock200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBlock(chain, block, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChainsApi.getBlock']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the chain status.
     * @summary Get chain status
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChainStatus(
      chain: ChainName,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChainStatus200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChainStatus(chain, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChainsApi.getChainStatus']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a transaction.
     * @summary Get transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash A transaction hash.
     * @param {GetTransactionIncludeEnum} [include] Include contract and method call details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransaction(
      chain: ChainName,
      hash: string,
      include?: GetTransactionIncludeEnum,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(chain, hash, include, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChainsApi.getTransaction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
     * @summary Get transaction receipt
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash A transaction hash.
     * @param {GetTransactionReceiptIncludeEnum} [include] Include contract and event details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionReceipt(
      chain: ChainName,
      hash: string,
      include?: GetTransactionReceiptIncludeEnum,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionReceipt200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionReceipt(chain, hash, include, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChainsApi.getTransactionReceipt']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Receives a pre-signed raw transaction and submits it to the blockchain.
     * @summary Submit signed transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {SignedTransactionSubmission} signedTransactionSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitSignedTransaction(
      chain: ChainName,
      signedTransactionSubmission: SignedTransactionSubmission,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.submitSignedTransaction(
        chain,
        signedTransactionSubmission,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChainsApi.submitSignedTransaction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a transaction for sending the native token between addresses.
     * @summary Transfer ETH
     * @param {ChainName} chain The blockchain chain label.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transferEth(
      chain: ChainName,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferEth200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.transferEth(chain, postMethodArgs, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChainsApi.transferEth']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * ChainsApi - factory interface
 * @export
 */
export const ChainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ChainsApiFp(configuration);
  return {
    /**
     * Returns a block.
     * @summary Get a block
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlock(chain: ChainName, block: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBlock200Response> {
      return localVarFp.getBlock(chain, block, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the chain status.
     * @summary Get chain status
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChainStatus(chain: ChainName, options?: RawAxiosRequestConfig): AxiosPromise<GetChainStatus200Response> {
      return localVarFp.getChainStatus(chain, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a transaction.
     * @summary Get transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash A transaction hash.
     * @param {GetTransactionIncludeEnum} [include] Include contract and method call details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(
      chain: ChainName,
      hash: string,
      include?: GetTransactionIncludeEnum,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetTransaction200Response> {
      return localVarFp.getTransaction(chain, hash, include, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
     * @summary Get transaction receipt
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash A transaction hash.
     * @param {GetTransactionReceiptIncludeEnum} [include] Include contract and event details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionReceipt(
      chain: ChainName,
      hash: string,
      include?: GetTransactionReceiptIncludeEnum,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetTransactionReceipt200Response> {
      return localVarFp
        .getTransactionReceipt(chain, hash, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Receives a pre-signed raw transaction and submits it to the blockchain.
     * @summary Submit signed transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {SignedTransactionSubmission} signedTransactionSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitSignedTransaction(
      chain: ChainName,
      signedTransactionSubmission: SignedTransactionSubmission,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp
        .submitSignedTransaction(chain, signedTransactionSubmission, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a transaction for sending the native token between addresses.
     * @summary Transfer ETH
     * @param {ChainName} chain The blockchain chain label.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferEth(
      chain: ChainName,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TransferEth200Response> {
      return localVarFp.transferEth(chain, postMethodArgs, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * ChainsApi - interface
 * @export
 * @interface ChainsApi
 */
export interface ChainsApiInterface {
  /**
   * Returns a block.
   * @summary Get a block
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApiInterface
   */
  getBlock(chain: ChainName, block: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBlock200Response>;

  /**
   * Returns the chain status.
   * @summary Get chain status
   * @param {ChainName} chain The blockchain chain label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApiInterface
   */
  getChainStatus(chain: ChainName, options?: RawAxiosRequestConfig): AxiosPromise<GetChainStatus200Response>;

  /**
   * Returns a transaction.
   * @summary Get transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} hash A transaction hash.
   * @param {GetTransactionIncludeEnum} [include] Include contract and method call details, if available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApiInterface
   */
  getTransaction(
    chain: ChainName,
    hash: string,
    include?: GetTransactionIncludeEnum,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetTransaction200Response>;

  /**
   * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
   * @summary Get transaction receipt
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} hash A transaction hash.
   * @param {GetTransactionReceiptIncludeEnum} [include] Include contract and event details, if available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApiInterface
   */
  getTransactionReceipt(
    chain: ChainName,
    hash: string,
    include?: GetTransactionReceiptIncludeEnum,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetTransactionReceipt200Response>;

  /**
   * Receives a pre-signed raw transaction and submits it to the blockchain.
   * @summary Submit signed transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {SignedTransactionSubmission} signedTransactionSubmission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApiInterface
   */
  submitSignedTransaction(
    chain: ChainName,
    signedTransactionSubmission: SignedTransactionSubmission,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Returns a transaction for sending the native token between addresses.
   * @summary Transfer ETH
   * @param {ChainName} chain The blockchain chain label.
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApiInterface
   */
  transferEth(
    chain: ChainName,
    postMethodArgs: PostMethodArgs,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<TransferEth200Response>;
}

/**
 * ChainsApi - object-oriented interface
 * @export
 * @class ChainsApi
 * @extends {BaseAPI}
 */
export class ChainsApi extends BaseAPI implements ChainsApiInterface {
  /**
   * Returns a block.
   * @summary Get a block
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApi
   */
  public getBlock(chain: ChainName, block: string, options?: RawAxiosRequestConfig) {
    return ChainsApiFp(this.configuration)
      .getBlock(chain, block, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the chain status.
   * @summary Get chain status
   * @param {ChainName} chain The blockchain chain label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApi
   */
  public getChainStatus(chain: ChainName, options?: RawAxiosRequestConfig) {
    return ChainsApiFp(this.configuration)
      .getChainStatus(chain, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transaction.
   * @summary Get transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} hash A transaction hash.
   * @param {GetTransactionIncludeEnum} [include] Include contract and method call details, if available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApi
   */
  public getTransaction(
    chain: ChainName,
    hash: string,
    include?: GetTransactionIncludeEnum,
    options?: RawAxiosRequestConfig
  ) {
    return ChainsApiFp(this.configuration)
      .getTransaction(chain, hash, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
   * @summary Get transaction receipt
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} hash A transaction hash.
   * @param {GetTransactionReceiptIncludeEnum} [include] Include contract and event details, if available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApi
   */
  public getTransactionReceipt(
    chain: ChainName,
    hash: string,
    include?: GetTransactionReceiptIncludeEnum,
    options?: RawAxiosRequestConfig
  ) {
    return ChainsApiFp(this.configuration)
      .getTransactionReceipt(chain, hash, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Receives a pre-signed raw transaction and submits it to the blockchain.
   * @summary Submit signed transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {SignedTransactionSubmission} signedTransactionSubmission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApi
   */
  public submitSignedTransaction(
    chain: ChainName,
    signedTransactionSubmission: SignedTransactionSubmission,
    options?: RawAxiosRequestConfig
  ) {
    return ChainsApiFp(this.configuration)
      .submitSignedTransaction(chain, signedTransactionSubmission, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transaction for sending the native token between addresses.
   * @summary Transfer ETH
   * @param {ChainName} chain The blockchain chain label.
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChainsApi
   */
  public transferEth(chain: ChainName, postMethodArgs: PostMethodArgs, options?: RawAxiosRequestConfig) {
    return ChainsApiFp(this.configuration)
      .transferEth(chain, postMethodArgs, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetTransactionIncludeEnum = {
  Contract: 'contract'
} as const;
export type GetTransactionIncludeEnum = typeof GetTransactionIncludeEnum[keyof typeof GetTransactionIncludeEnum];
/**
 * @export
 */
export const GetTransactionReceiptIncludeEnum = {
  Contract: 'contract'
} as const;
export type GetTransactionReceiptIncludeEnum =
  typeof GetTransactionReceiptIncludeEnum[keyof typeof GetTransactionReceiptIncludeEnum];

/**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
     * @summary Call a contract function
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {string} method Contract function.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callContractFunction: async (
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      method: string,
      postMethodArgs: PostMethodArgs,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('callContractFunction', 'chain', chain);
      // verify required parameter 'addressOrAlias' is not null or undefined
      assertParamExists('callContractFunction', 'addressOrAlias', addressOrAlias);
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('callContractFunction', 'contract', contract);
      // verify required parameter 'method' is not null or undefined
      assertParamExists('callContractFunction', 'method', method);
      // verify required parameter 'postMethodArgs' is not null or undefined
      assertParamExists('callContractFunction', 'postMethodArgs', postMethodArgs);
      const localVarPath = `/chains/{chain}/addresses/{address-or-alias}/contracts/{contract}/methods/{method}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-alias'}}`, encodeURIComponent(String(addressOrAlias)))
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'method'}}`, encodeURIComponent(String(method)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMethodArgs, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds a contract.
     * @summary Create a contract
     * @param {string} contract
     * @param {BaseContract} baseContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContract: async (
      contract: string,
      baseContract: BaseContract,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('createContract', 'contract', contract);
      // verify required parameter 'baseContract' is not null or undefined
      assertParamExists('createContract', 'baseContract', baseContract);
      const localVarPath = `/contracts/{contract}`.replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseContract, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds multiple contracts.
     * @summary Create multiple contracts
     * @param {Array<BaseContract>} baseContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContracts: async (
      baseContract: Array<BaseContract>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'baseContract' is not null or undefined
      assertParamExists('createContracts', 'baseContract', baseContract);
      const localVarPath = `/contracts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseContract, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a contract and all its versions.
     * @summary Delete a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContract: async (contract: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('deleteContract', 'contract', contract);
      const localVarPath = `/contracts/{contract}`.replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a specific contract version.
     * @summary Delete a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContractVersion: async (
      contract: string,
      version: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('deleteContractVersion', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('deleteContractVersion', 'version', version);
      const localVarPath = `/contracts/{contract}/{version}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a transaction to deploy the given contract to the blockchain.
     * @summary Deploy a contract
     * @param {string} contract
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployContract: async (
      contract: string,
      postMethodArgs: PostMethodArgs,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('deployContract', 'contract', contract);
      // verify required parameter 'postMethodArgs' is not null or undefined
      assertParamExists('deployContract', 'postMethodArgs', postMethodArgs);
      const localVarPath = `/contracts/{contract}/deploy`.replace(
        `{${'contract'}}`,
        encodeURIComponent(String(contract))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMethodArgs, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a transaction to deploy the given contract version to the blockchain.
     * @summary Deploy a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployContractVersion: async (
      contract: string,
      version: string,
      postMethodArgs: PostMethodArgs,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('deployContractVersion', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('deployContractVersion', 'version', version);
      // verify required parameter 'postMethodArgs' is not null or undefined
      assertParamExists('deployContractVersion', 'postMethodArgs', postMethodArgs);
      const localVarPath = `/contracts/{contract}/{version}/deploy`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMethodArgs, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the given contract.
     * @summary Get a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContract: async (contract: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getContract', 'contract', contract);
      const localVarPath = `/contracts/{contract}`.replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a specific contract version.
     * @summary Get a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractVersion: async (
      contract: string,
      version: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getContractVersion', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('getContractVersion', 'version', version);
      const localVarPath = `/contracts/{contract}/{version}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the versions of a contract.
     * @summary Get all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractVersions: async (contract: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getContractVersions', 'contract', contract);
      const localVarPath = `/contracts/{contract}/all`.replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the event monitor status for a given address and contract.
     * @summary Get event monitor status
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventMonitorStatus: async (
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getEventMonitorStatus', 'chain', chain);
      // verify required parameter 'addressOrAlias' is not null or undefined
      assertParamExists('getEventMonitorStatus', 'addressOrAlias', addressOrAlias);
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getEventMonitorStatus', 'contract', contract);
      const localVarPath = `/chains/{chain}/addresses/{address-or-alias}/contracts/{contract}/status`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-alias'}}`, encodeURIComponent(String(addressOrAlias)))
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the type conversion options for a given contract and event signature.
     * @summary Get event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventTypeConversions: async (
      contract: string,
      version: string,
      event: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getEventTypeConversions', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('getEventTypeConversions', 'version', version);
      // verify required parameter 'event' is not null or undefined
      assertParamExists('getEventTypeConversions', 'event', event);
      const localVarPath = `/contracts/{contract}/{version}/events/{event}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'event'}}`, encodeURIComponent(String(event)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the type conversion options for a given contract and function signature.
     * @summary Get function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctionTypeConversions: async (
      contract: string,
      version: string,
      method: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getFunctionTypeConversions', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('getFunctionTypeConversions', 'version', version);
      // verify required parameter 'method' is not null or undefined
      assertParamExists('getFunctionTypeConversions', 'method', method);
      const localVarPath = `/contracts/{contract}/{version}/methods/{method}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'method'}}`, encodeURIComponent(String(method)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Links an address to a contract.
     * @summary Link address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {LinkAddressContractRequest} linkAddressContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAddressContract: async (
      chain: ChainName,
      addressOrAlias: string,
      linkAddressContractRequest: LinkAddressContractRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('linkAddressContract', 'chain', chain);
      // verify required parameter 'addressOrAlias' is not null or undefined
      assertParamExists('linkAddressContract', 'addressOrAlias', addressOrAlias);
      // verify required parameter 'linkAddressContractRequest' is not null or undefined
      assertParamExists('linkAddressContract', 'linkAddressContractRequest', linkAddressContractRequest);
      const localVarPath = `/chains/{chain}/addresses/{address-or-alias}/contracts`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-alias'}}`, encodeURIComponent(String(addressOrAlias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        linkAddressContractRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of the versions of a contract.
     * @summary List all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContractVersions: async (contract: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('listContractVersions', 'contract', contract);
      const localVarPath = `/contracts/{contract}/versions`.replace(
        `{${'contract'}}`,
        encodeURIComponent(String(contract))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of contracts.
     * @summary List contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContracts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/contracts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sets the type conversion options for a given contract and event signature.
     * @summary Set event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {ContractEventOptions} contractEventOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEventTypeConversions: async (
      contract: string,
      version: string,
      event: string,
      contractEventOptions: ContractEventOptions,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('setEventTypeConversions', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('setEventTypeConversions', 'version', version);
      // verify required parameter 'event' is not null or undefined
      assertParamExists('setEventTypeConversions', 'event', event);
      // verify required parameter 'contractEventOptions' is not null or undefined
      assertParamExists('setEventTypeConversions', 'contractEventOptions', contractEventOptions);
      const localVarPath = `/contracts/{contract}/{version}/events/{event}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'event'}}`, encodeURIComponent(String(event)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(contractEventOptions, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sets the type conversion options for a given contract and function signature.
     * @summary Set function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {ContractMethodOptions} contractMethodOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFunctionTypeConversions: async (
      contract: string,
      version: string,
      method: string,
      contractMethodOptions: ContractMethodOptions,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('setFunctionTypeConversions', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('setFunctionTypeConversions', 'version', version);
      // verify required parameter 'method' is not null or undefined
      assertParamExists('setFunctionTypeConversions', 'method', method);
      // verify required parameter 'contractMethodOptions' is not null or undefined
      assertParamExists('setFunctionTypeConversions', 'contractMethodOptions', contractMethodOptions);
      const localVarPath = `/contracts/{contract}/{version}/methods/{method}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'method'}}`, encodeURIComponent(String(method)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(contractMethodOptions, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unlinks an address from a contract.
     * @summary Unlink address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkAddressContract: async (
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('unlinkAddressContract', 'chain', chain);
      // verify required parameter 'addressOrAlias' is not null or undefined
      assertParamExists('unlinkAddressContract', 'addressOrAlias', addressOrAlias);
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('unlinkAddressContract', 'contract', contract);
      const localVarPath = `/chains/{chain}/addresses/{address-or-alias}/contracts/{contract}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-alias'}}`, encodeURIComponent(String(addressOrAlias)))
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration);
  return {
    /**
     * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
     * @summary Call a contract function
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {string} method Contract function.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callContractFunction(
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      method: string,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CallContractFunction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.callContractFunction(
        chain,
        addressOrAlias,
        contract,
        method,
        postMethodArgs,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.callContractFunction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds a contract.
     * @summary Create a contract
     * @param {string} contract
     * @param {BaseContract} baseContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createContract(
      contract: string,
      baseContract: BaseContract,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createContract(contract, baseContract, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.createContract']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds multiple contracts.
     * @summary Create multiple contracts
     * @param {Array<BaseContract>} baseContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createContracts(
      baseContract: Array<BaseContract>,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createContracts(baseContract, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.createContracts']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes a contract and all its versions.
     * @summary Delete a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteContract(
      contract: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContract(contract, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.deleteContract']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes a specific contract version.
     * @summary Delete a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteContractVersion(
      contract: string,
      version: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContractVersion(contract, version, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.deleteContractVersion']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a transaction to deploy the given contract to the blockchain.
     * @summary Deploy a contract
     * @param {string} contract
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deployContract(
      contract: string,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deployContract(contract, postMethodArgs, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.deployContract']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a transaction to deploy the given contract version to the blockchain.
     * @summary Deploy a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deployContractVersion(
      contract: string,
      version: string,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deployContractVersion(
        contract,
        version,
        postMethodArgs,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.deployContractVersion']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the given contract.
     * @summary Get a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContract(
      contract: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContract(contract, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.getContract']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a specific contract version.
     * @summary Get a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContractVersion(
      contract: string,
      version: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContractVersion(contract, version, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.getContractVersion']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the versions of a contract.
     * @summary Get all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContractVersions(
      contract: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContractVersions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContractVersions(contract, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.getContractVersions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the event monitor status for a given address and contract.
     * @summary Get event monitor status
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventMonitorStatus(
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventMonitorStatus200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventMonitorStatus(
        chain,
        addressOrAlias,
        contract,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.getEventMonitorStatus']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the type conversion options for a given contract and event signature.
     * @summary Get event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventTypeConversions(
      contract: string,
      version: string,
      event: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventTypeConversions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventTypeConversions(
        contract,
        version,
        event,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.getEventTypeConversions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the type conversion options for a given contract and function signature.
     * @summary Get function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFunctionTypeConversions(
      contract: string,
      version: string,
      method: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFunctionTypeConversions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFunctionTypeConversions(
        contract,
        version,
        method,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.getFunctionTypeConversions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Links an address to a contract.
     * @summary Link address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {LinkAddressContractRequest} linkAddressContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async linkAddressContract(
      chain: ChainName,
      addressOrAlias: string,
      linkAddressContractRequest: LinkAddressContractRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetAddress201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.linkAddressContract(
        chain,
        addressOrAlias,
        linkAddressContractRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.linkAddressContract']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of the versions of a contract.
     * @summary List all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listContractVersions(
      contract: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContractVersions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listContractVersions(contract, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.listContractVersions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of contracts.
     * @summary List contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listContracts(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContracts200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listContracts(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.listContracts']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Sets the type conversion options for a given contract and event signature.
     * @summary Set event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {ContractEventOptions} contractEventOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setEventTypeConversions(
      contract: string,
      version: string,
      event: string,
      contractEventOptions: ContractEventOptions,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setEventTypeConversions(
        contract,
        version,
        event,
        contractEventOptions,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.setEventTypeConversions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Sets the type conversion options for a given contract and function signature.
     * @summary Set function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {ContractMethodOptions} contractMethodOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setFunctionTypeConversions(
      contract: string,
      version: string,
      method: string,
      contractMethodOptions: ContractMethodOptions,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setFunctionTypeConversions(
        contract,
        version,
        method,
        contractMethodOptions,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.setFunctionTypeConversions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Unlinks an address from a contract.
     * @summary Unlink address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unlinkAddressContract(
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetAddress201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkAddressContract(
        chain,
        addressOrAlias,
        contract,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.unlinkAddressContract']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ContractsApiFp(configuration);
  return {
    /**
     * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
     * @summary Call a contract function
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {string} method Contract function.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callContractFunction(
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      method: string,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CallContractFunction200Response> {
      return localVarFp
        .callContractFunction(chain, addressOrAlias, contract, method, postMethodArgs, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds a contract.
     * @summary Create a contract
     * @param {string} contract
     * @param {BaseContract} baseContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContract(
      contract: string,
      baseContract: BaseContract,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetContract200Response> {
      return localVarFp.createContract(contract, baseContract, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds multiple contracts.
     * @summary Create multiple contracts
     * @param {Array<BaseContract>} baseContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContracts(baseContract: Array<BaseContract>, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.createContracts(baseContract, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a contract and all its versions.
     * @summary Delete a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContract(contract: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.deleteContract(contract, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a specific contract version.
     * @summary Delete a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContractVersion(
      contract: string,
      version: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp.deleteContractVersion(contract, version, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a transaction to deploy the given contract to the blockchain.
     * @summary Deploy a contract
     * @param {string} contract
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployContract(
      contract: string,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<DeployContract200Response> {
      return localVarFp.deployContract(contract, postMethodArgs, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a transaction to deploy the given contract version to the blockchain.
     * @summary Deploy a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployContractVersion(
      contract: string,
      version: string,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<DeployContract200Response> {
      return localVarFp
        .deployContractVersion(contract, version, postMethodArgs, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the given contract.
     * @summary Get a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContract(contract: string, options?: RawAxiosRequestConfig): AxiosPromise<GetContract200Response> {
      return localVarFp.getContract(contract, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a specific contract version.
     * @summary Get a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractVersion(
      contract: string,
      version: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetContract200Response> {
      return localVarFp.getContractVersion(contract, version, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the versions of a contract.
     * @summary Get all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractVersions(
      contract: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetContractVersions200Response> {
      return localVarFp.getContractVersions(contract, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the event monitor status for a given address and contract.
     * @summary Get event monitor status
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventMonitorStatus(
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetEventMonitorStatus200Response> {
      return localVarFp
        .getEventMonitorStatus(chain, addressOrAlias, contract, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the type conversion options for a given contract and event signature.
     * @summary Get event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventTypeConversions(
      contract: string,
      version: string,
      event: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetEventTypeConversions200Response> {
      return localVarFp
        .getEventTypeConversions(contract, version, event, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the type conversion options for a given contract and function signature.
     * @summary Get function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctionTypeConversions(
      contract: string,
      version: string,
      method: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetFunctionTypeConversions200Response> {
      return localVarFp
        .getFunctionTypeConversions(contract, version, method, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Links an address to a contract.
     * @summary Link address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {LinkAddressContractRequest} linkAddressContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAddressContract(
      chain: ChainName,
      addressOrAlias: string,
      linkAddressContractRequest: LinkAddressContractRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SetAddress201Response> {
      return localVarFp
        .linkAddressContract(chain, addressOrAlias, linkAddressContractRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of the versions of a contract.
     * @summary List all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContractVersions(
      contract: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListContractVersions200Response> {
      return localVarFp.listContractVersions(contract, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of contracts.
     * @summary List contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContracts(options?: RawAxiosRequestConfig): AxiosPromise<ListContracts200Response> {
      return localVarFp.listContracts(options).then((request) => request(axios, basePath));
    },
    /**
     * Sets the type conversion options for a given contract and event signature.
     * @summary Set event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {ContractEventOptions} contractEventOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEventTypeConversions(
      contract: string,
      version: string,
      event: string,
      contractEventOptions: ContractEventOptions,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setEventTypeConversions(contract, version, event, contractEventOptions, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sets the type conversion options for a given contract and function signature.
     * @summary Set function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {ContractMethodOptions} contractMethodOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFunctionTypeConversions(
      contract: string,
      version: string,
      method: string,
      contractMethodOptions: ContractMethodOptions,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setFunctionTypeConversions(contract, version, method, contractMethodOptions, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Unlinks an address from a contract.
     * @summary Unlink address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkAddressContract(
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SetAddress201Response> {
      return localVarFp
        .unlinkAddressContract(chain, addressOrAlias, contract, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * ContractsApi - interface
 * @export
 * @interface ContractsApi
 */
export interface ContractsApiInterface {
  /**
   * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
   * @summary Call a contract function
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {string} contract
   * @param {string} method Contract function.
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  callContractFunction(
    chain: ChainName,
    addressOrAlias: string,
    contract: string,
    method: string,
    postMethodArgs: PostMethodArgs,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<CallContractFunction200Response>;

  /**
   * Adds a contract.
   * @summary Create a contract
   * @param {string} contract
   * @param {BaseContract} baseContract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  createContract(
    contract: string,
    baseContract: BaseContract,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetContract200Response>;

  /**
   * Adds multiple contracts.
   * @summary Create multiple contracts
   * @param {Array<BaseContract>} baseContract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  createContracts(baseContract: Array<BaseContract>, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Deletes a contract and all its versions.
   * @summary Delete a contract
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  deleteContract(contract: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Deletes a specific contract version.
   * @summary Delete a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  deleteContractVersion(contract: string, version: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Returns a transaction to deploy the given contract to the blockchain.
   * @summary Deploy a contract
   * @param {string} contract
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  deployContract(
    contract: string,
    postMethodArgs: PostMethodArgs,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<DeployContract200Response>;

  /**
   * Returns a transaction to deploy the given contract version to the blockchain.
   * @summary Deploy a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  deployContractVersion(
    contract: string,
    version: string,
    postMethodArgs: PostMethodArgs,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<DeployContract200Response>;

  /**
   * Returns the given contract.
   * @summary Get a contract
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  getContract(contract: string, options?: RawAxiosRequestConfig): AxiosPromise<GetContract200Response>;

  /**
   * Returns a specific contract version.
   * @summary Get a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  getContractVersion(
    contract: string,
    version: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetContract200Response>;

  /**
   * Returns all the versions of a contract.
   * @summary Get all contract versions
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  getContractVersions(contract: string, options?: RawAxiosRequestConfig): AxiosPromise<GetContractVersions200Response>;

  /**
   * Returns the event monitor status for a given address and contract.
   * @summary Get event monitor status
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  getEventMonitorStatus(
    chain: ChainName,
    addressOrAlias: string,
    contract: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetEventMonitorStatus200Response>;

  /**
   * Returns the type conversion options for a given contract and event signature.
   * @summary Get event type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} event Contract Event.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  getEventTypeConversions(
    contract: string,
    version: string,
    event: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetEventTypeConversions200Response>;

  /**
   * Returns the type conversion options for a given contract and function signature.
   * @summary Get function type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} method Contract function.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  getFunctionTypeConversions(
    contract: string,
    version: string,
    method: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetFunctionTypeConversions200Response>;

  /**
   * Links an address to a contract.
   * @summary Link address and contract
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {LinkAddressContractRequest} linkAddressContractRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  linkAddressContract(
    chain: ChainName,
    addressOrAlias: string,
    linkAddressContractRequest: LinkAddressContractRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<SetAddress201Response>;

  /**
   * Returns a list of the versions of a contract.
   * @summary List all contract versions
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  listContractVersions(
    contract: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ListContractVersions200Response>;

  /**
   * Returns a list of contracts.
   * @summary List contracts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  listContracts(options?: RawAxiosRequestConfig): AxiosPromise<ListContracts200Response>;

  /**
   * Sets the type conversion options for a given contract and event signature.
   * @summary Set event type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} event Contract Event.
   * @param {ContractEventOptions} contractEventOptions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  setEventTypeConversions(
    contract: string,
    version: string,
    event: string,
    contractEventOptions: ContractEventOptions,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Sets the type conversion options for a given contract and function signature.
   * @summary Set function type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} method Contract function.
   * @param {ContractMethodOptions} contractMethodOptions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  setFunctionTypeConversions(
    contract: string,
    version: string,
    method: string,
    contractMethodOptions: ContractMethodOptions,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Unlinks an address from a contract.
   * @summary Unlink address and contract
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApiInterface
   */
  unlinkAddressContract(
    chain: ChainName,
    addressOrAlias: string,
    contract: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<SetAddress201Response>;
}

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI implements ContractsApiInterface {
  /**
   * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
   * @summary Call a contract function
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {string} contract
   * @param {string} method Contract function.
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public callContractFunction(
    chain: ChainName,
    addressOrAlias: string,
    contract: string,
    method: string,
    postMethodArgs: PostMethodArgs,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .callContractFunction(chain, addressOrAlias, contract, method, postMethodArgs, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a contract.
   * @summary Create a contract
   * @param {string} contract
   * @param {BaseContract} baseContract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public createContract(contract: string, baseContract: BaseContract, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .createContract(contract, baseContract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds multiple contracts.
   * @summary Create multiple contracts
   * @param {Array<BaseContract>} baseContract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public createContracts(baseContract: Array<BaseContract>, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .createContracts(baseContract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a contract and all its versions.
   * @summary Delete a contract
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public deleteContract(contract: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .deleteContract(contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a specific contract version.
   * @summary Delete a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public deleteContractVersion(contract: string, version: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .deleteContractVersion(contract, version, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transaction to deploy the given contract to the blockchain.
   * @summary Deploy a contract
   * @param {string} contract
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public deployContract(contract: string, postMethodArgs: PostMethodArgs, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .deployContract(contract, postMethodArgs, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transaction to deploy the given contract version to the blockchain.
   * @summary Deploy a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public deployContractVersion(
    contract: string,
    version: string,
    postMethodArgs: PostMethodArgs,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .deployContractVersion(contract, version, postMethodArgs, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the given contract.
   * @summary Get a contract
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getContract(contract: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getContract(contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a specific contract version.
   * @summary Get a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getContractVersion(contract: string, version: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getContractVersion(contract, version, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the versions of a contract.
   * @summary Get all contract versions
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getContractVersions(contract: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getContractVersions(contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the event monitor status for a given address and contract.
   * @summary Get event monitor status
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getEventMonitorStatus(
    chain: ChainName,
    addressOrAlias: string,
    contract: string,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getEventMonitorStatus(chain, addressOrAlias, contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the type conversion options for a given contract and event signature.
   * @summary Get event type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} event Contract Event.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getEventTypeConversions(contract: string, version: string, event: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getEventTypeConversions(contract, version, event, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the type conversion options for a given contract and function signature.
   * @summary Get function type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} method Contract function.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getFunctionTypeConversions(
    contract: string,
    version: string,
    method: string,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getFunctionTypeConversions(contract, version, method, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Links an address to a contract.
   * @summary Link address and contract
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {LinkAddressContractRequest} linkAddressContractRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public linkAddressContract(
    chain: ChainName,
    addressOrAlias: string,
    linkAddressContractRequest: LinkAddressContractRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .linkAddressContract(chain, addressOrAlias, linkAddressContractRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of the versions of a contract.
   * @summary List all contract versions
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public listContractVersions(contract: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .listContractVersions(contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of contracts.
   * @summary List contracts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public listContracts(options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .listContracts(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the type conversion options for a given contract and event signature.
   * @summary Set event type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} event Contract Event.
   * @param {ContractEventOptions} contractEventOptions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public setEventTypeConversions(
    contract: string,
    version: string,
    event: string,
    contractEventOptions: ContractEventOptions,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .setEventTypeConversions(contract, version, event, contractEventOptions, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the type conversion options for a given contract and function signature.
   * @summary Set function type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} method Contract function.
   * @param {ContractMethodOptions} contractMethodOptions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public setFunctionTypeConversions(
    contract: string,
    version: string,
    method: string,
    contractMethodOptions: ContractMethodOptions,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .setFunctionTypeConversions(contract, version, method, contractMethodOptions, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Unlinks an address from a contract.
   * @summary Unlink address and contract
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public unlinkAddressContract(
    chain: ChainName,
    addressOrAlias: string,
    contract: string,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .unlinkAddressContract(chain, addressOrAlias, contract, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EventQueriesApi - axios parameter creator
 * @export
 */
export const EventQueriesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns the record count of the given saved event query.
     * @summary Count event query records
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countEventQueryRecords: async (eventQuery: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('countEventQueryRecords', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}/count`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the given saved event query.
     * @summary Delete event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventQuery: async (eventQuery: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('deleteEventQuery', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Executes an arbitrary event query.
     * @summary Execute arbitrary event query
     * @param {EventQuery} eventQuery
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeArbitraryEventQuery: async (
      eventQuery: EventQuery,
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('executeArbitraryEventQuery', 'eventQuery', eventQuery);
      const localVarPath = `/queries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(eventQuery, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Executes the given saved event query.
     * @summary Execute event query
     * @param {string} eventQuery An event query label.
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeEventQuery: async (
      eventQuery: string,
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('executeEventQuery', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}/results`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the given saved event query.
     * @summary Get event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventQuery: async (eventQuery: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('getEventQuery', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of saved event queries.
     * @summary List event queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventQueries: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/queries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates or updates the given saved event query.
     * @summary Create or update event query
     * @param {string} eventQuery An event query label.
     * @param {EventQuery} eventQuery2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEventQuery: async (
      eventQuery: string,
      eventQuery2: EventQuery,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('setEventQuery', 'eventQuery', eventQuery);
      // verify required parameter 'eventQuery2' is not null or undefined
      assertParamExists('setEventQuery', 'eventQuery2', eventQuery2);
      const localVarPath = `/queries/{event_query}`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(eventQuery2, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * EventQueriesApi - functional programming interface
 * @export
 */
export const EventQueriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EventQueriesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the record count of the given saved event query.
     * @summary Count event query records
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countEventQueryRecords(
      eventQuery: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountEventQueryRecords200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countEventQueryRecords(eventQuery, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.countEventQueryRecords']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes the given saved event query.
     * @summary Delete event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEventQuery(
      eventQuery: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventQuery(eventQuery, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.deleteEventQuery']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Executes an arbitrary event query.
     * @summary Execute arbitrary event query
     * @param {EventQuery} eventQuery
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeArbitraryEventQuery(
      eventQuery: EventQuery,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteArbitraryEventQuery200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeArbitraryEventQuery(
        eventQuery,
        offset,
        limit,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.executeArbitraryEventQuery']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Executes the given saved event query.
     * @summary Execute event query
     * @param {string} eventQuery An event query label.
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeEventQuery(
      eventQuery: string,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteArbitraryEventQuery200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeEventQuery(eventQuery, offset, limit, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.executeEventQuery']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the given saved event query.
     * @summary Get event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventQuery(
      eventQuery: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventQuery200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventQuery(eventQuery, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.getEventQuery']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of saved event queries.
     * @summary List event queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEventQueries(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEventQueries200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listEventQueries(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.listEventQueries']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates or updates the given saved event query.
     * @summary Create or update event query
     * @param {string} eventQuery An event query label.
     * @param {EventQuery} eventQuery2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setEventQuery(
      eventQuery: string,
      eventQuery2: EventQuery,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setEventQuery(eventQuery, eventQuery2, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.setEventQuery']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * EventQueriesApi - factory interface
 * @export
 */
export const EventQueriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EventQueriesApiFp(configuration);
  return {
    /**
     * Returns the record count of the given saved event query.
     * @summary Count event query records
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countEventQueryRecords(
      eventQuery: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CountEventQueryRecords200Response> {
      return localVarFp.countEventQueryRecords(eventQuery, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the given saved event query.
     * @summary Delete event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventQuery(eventQuery: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.deleteEventQuery(eventQuery, options).then((request) => request(axios, basePath));
    },
    /**
     * Executes an arbitrary event query.
     * @summary Execute arbitrary event query
     * @param {EventQuery} eventQuery
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeArbitraryEventQuery(
      eventQuery: EventQuery,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ExecuteArbitraryEventQuery200Response> {
      return localVarFp
        .executeArbitraryEventQuery(eventQuery, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Executes the given saved event query.
     * @summary Execute event query
     * @param {string} eventQuery An event query label.
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeEventQuery(
      eventQuery: string,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ExecuteArbitraryEventQuery200Response> {
      return localVarFp
        .executeEventQuery(eventQuery, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the given saved event query.
     * @summary Get event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventQuery(eventQuery: string, options?: RawAxiosRequestConfig): AxiosPromise<GetEventQuery200Response> {
      return localVarFp.getEventQuery(eventQuery, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of saved event queries.
     * @summary List event queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventQueries(options?: RawAxiosRequestConfig): AxiosPromise<ListEventQueries200Response> {
      return localVarFp.listEventQueries(options).then((request) => request(axios, basePath));
    },
    /**
     * Creates or updates the given saved event query.
     * @summary Create or update event query
     * @param {string} eventQuery An event query label.
     * @param {EventQuery} eventQuery2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEventQuery(
      eventQuery: string,
      eventQuery2: EventQuery,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp.setEventQuery(eventQuery, eventQuery2, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * EventQueriesApi - interface
 * @export
 * @interface EventQueriesApi
 */
export interface EventQueriesApiInterface {
  /**
   * Returns the record count of the given saved event query.
   * @summary Count event query records
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  countEventQueryRecords(
    eventQuery: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<CountEventQueryRecords200Response>;

  /**
   * Deletes the given saved event query.
   * @summary Delete event query
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  deleteEventQuery(eventQuery: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Executes an arbitrary event query.
   * @summary Execute arbitrary event query
   * @param {EventQuery} eventQuery
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  executeArbitraryEventQuery(
    eventQuery: EventQuery,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ExecuteArbitraryEventQuery200Response>;

  /**
   * Executes the given saved event query.
   * @summary Execute event query
   * @param {string} eventQuery An event query label.
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  executeEventQuery(
    eventQuery: string,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ExecuteArbitraryEventQuery200Response>;

  /**
   * Returns the given saved event query.
   * @summary Get event query
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  getEventQuery(eventQuery: string, options?: RawAxiosRequestConfig): AxiosPromise<GetEventQuery200Response>;

  /**
   * Returns a list of saved event queries.
   * @summary List event queries
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  listEventQueries(options?: RawAxiosRequestConfig): AxiosPromise<ListEventQueries200Response>;

  /**
   * Creates or updates the given saved event query.
   * @summary Create or update event query
   * @param {string} eventQuery An event query label.
   * @param {EventQuery} eventQuery2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApiInterface
   */
  setEventQuery(
    eventQuery: string,
    eventQuery2: EventQuery,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;
}

/**
 * EventQueriesApi - object-oriented interface
 * @export
 * @class EventQueriesApi
 * @extends {BaseAPI}
 */
export class EventQueriesApi extends BaseAPI implements EventQueriesApiInterface {
  /**
   * Returns the record count of the given saved event query.
   * @summary Count event query records
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public countEventQueryRecords(eventQuery: string, options?: RawAxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .countEventQueryRecords(eventQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the given saved event query.
   * @summary Delete event query
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public deleteEventQuery(eventQuery: string, options?: RawAxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .deleteEventQuery(eventQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Executes an arbitrary event query.
   * @summary Execute arbitrary event query
   * @param {EventQuery} eventQuery
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public executeArbitraryEventQuery(
    eventQuery: EventQuery,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig
  ) {
    return EventQueriesApiFp(this.configuration)
      .executeArbitraryEventQuery(eventQuery, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Executes the given saved event query.
   * @summary Execute event query
   * @param {string} eventQuery An event query label.
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public executeEventQuery(eventQuery: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .executeEventQuery(eventQuery, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the given saved event query.
   * @summary Get event query
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public getEventQuery(eventQuery: string, options?: RawAxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .getEventQuery(eventQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of saved event queries.
   * @summary List event queries
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public listEventQueries(options?: RawAxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .listEventQueries(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates or updates the given saved event query.
   * @summary Create or update event query
   * @param {string} eventQuery An event query label.
   * @param {EventQuery} eventQuery2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventQueriesApi
   */
  public setEventQuery(eventQuery: string, eventQuery2: EventQuery, options?: RawAxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .setEventQuery(eventQuery, eventQuery2, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Gets the number of events stored in the database.
     * @summary Get event count
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventCount: async (
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/events/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (blockHash !== undefined) {
        localVarQueryParameter['block_hash'] = blockHash;
      }

      if (blockNumber !== undefined) {
        localVarQueryParameter['block_number'] = blockNumber;
      }

      if (txIndexInBlock !== undefined) {
        localVarQueryParameter['tx_index_in_block'] = txIndexInBlock;
      }

      if (eventIndexInLog !== undefined) {
        localVarQueryParameter['event_index_in_log'] = eventIndexInLog;
      }

      if (txHash !== undefined) {
        localVarQueryParameter['tx_hash'] = txHash;
      }

      if (fromConstructor !== undefined) {
        localVarQueryParameter['from_constructor'] = fromConstructor;
      }

      if (chain !== undefined) {
        localVarQueryParameter['chain'] = chain;
      }

      if (contractAddress !== undefined) {
        localVarQueryParameter['contract_address'] = contractAddress;
      }

      if (contractLabel !== undefined) {
        localVarQueryParameter['contract_label'] = contractLabel;
      }

      if (eventSignature !== undefined) {
        localVarQueryParameter['event_signature'] = eventSignature;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all events stored in the database.
     * @summary List events
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEvents: async (
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/events`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (blockHash !== undefined) {
        localVarQueryParameter['block_hash'] = blockHash;
      }

      if (blockNumber !== undefined) {
        localVarQueryParameter['block_number'] = blockNumber;
      }

      if (txIndexInBlock !== undefined) {
        localVarQueryParameter['tx_index_in_block'] = txIndexInBlock;
      }

      if (eventIndexInLog !== undefined) {
        localVarQueryParameter['event_index_in_log'] = eventIndexInLog;
      }

      if (txHash !== undefined) {
        localVarQueryParameter['tx_hash'] = txHash;
      }

      if (fromConstructor !== undefined) {
        localVarQueryParameter['from_constructor'] = fromConstructor;
      }

      if (chain !== undefined) {
        localVarQueryParameter['chain'] = chain;
      }

      if (contractAddress !== undefined) {
        localVarQueryParameter['contract_address'] = contractAddress;
      }

      if (contractLabel !== undefined) {
        localVarQueryParameter['contract_label'] = contractLabel;
      }

      if (eventSignature !== undefined) {
        localVarQueryParameter['event_signature'] = eventSignature;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration);
  return {
    /**
     * Gets the number of events stored in the database.
     * @summary Get event count
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventCount(
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventCount200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventCount(
        blockHash,
        blockNumber,
        txIndexInBlock,
        eventIndexInLog,
        txHash,
        fromConstructor,
        chain,
        contractAddress,
        contractLabel,
        eventSignature,
        limit,
        offset,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventsApi.getEventCount']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all events stored in the database.
     * @summary List events
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEvents(
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEvents200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listEvents(
        blockHash,
        blockNumber,
        txIndexInBlock,
        eventIndexInLog,
        txHash,
        fromConstructor,
        chain,
        contractAddress,
        contractLabel,
        eventSignature,
        limit,
        offset,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventsApi.listEvents']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = EventsApiFp(configuration);
  return {
    /**
     * Gets the number of events stored in the database.
     * @summary Get event count
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventCount(
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetEventCount200Response> {
      return localVarFp
        .getEventCount(
          blockHash,
          blockNumber,
          txIndexInBlock,
          eventIndexInLog,
          txHash,
          fromConstructor,
          chain,
          contractAddress,
          contractLabel,
          eventSignature,
          limit,
          offset,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all events stored in the database.
     * @summary List events
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEvents(
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListEvents200Response> {
      return localVarFp
        .listEvents(
          blockHash,
          blockNumber,
          txIndexInBlock,
          eventIndexInLog,
          txHash,
          fromConstructor,
          chain,
          contractAddress,
          contractLabel,
          eventSignature,
          limit,
          offset,
          options
        )
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * EventsApi - interface
 * @export
 * @interface EventsApi
 */
export interface EventsApiInterface {
  /**
   * Gets the number of events stored in the database.
   * @summary Get event count
   * @param {string} [blockHash] Filter events by a block hash.
   * @param {number} [blockNumber] Filter events by a block number.
   * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
   * @param {number} [eventIndexInLog] Filter events by index in the log.
   * @param {string} [txHash] Filter events by a transaction hash.
   * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
   * @param {ChainName} [chain] Filter events by a chain name.
   * @param {string} [contractAddress] Filter events by a contract address.
   * @param {string} [contractLabel] Filter events by a contract label.
   * @param {string} [eventSignature] Filter events by the signature.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApiInterface
   */
  getEventCount(
    blockHash?: string,
    blockNumber?: number,
    txIndexInBlock?: number,
    eventIndexInLog?: number,
    txHash?: string,
    fromConstructor?: boolean,
    chain?: ChainName,
    contractAddress?: string,
    contractLabel?: string,
    eventSignature?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetEventCount200Response>;

  /**
   * Returns all events stored in the database.
   * @summary List events
   * @param {string} [blockHash] Filter events by a block hash.
   * @param {number} [blockNumber] Filter events by a block number.
   * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
   * @param {number} [eventIndexInLog] Filter events by index in the log.
   * @param {string} [txHash] Filter events by a transaction hash.
   * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
   * @param {ChainName} [chain] Filter events by a chain name.
   * @param {string} [contractAddress] Filter events by a contract address.
   * @param {string} [contractLabel] Filter events by a contract label.
   * @param {string} [eventSignature] Filter events by the signature.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApiInterface
   */
  listEvents(
    blockHash?: string,
    blockNumber?: number,
    txIndexInBlock?: number,
    eventIndexInLog?: number,
    txHash?: string,
    fromConstructor?: boolean,
    chain?: ChainName,
    contractAddress?: string,
    contractLabel?: string,
    eventSignature?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ListEvents200Response>;
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI implements EventsApiInterface {
  /**
   * Gets the number of events stored in the database.
   * @summary Get event count
   * @param {string} [blockHash] Filter events by a block hash.
   * @param {number} [blockNumber] Filter events by a block number.
   * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
   * @param {number} [eventIndexInLog] Filter events by index in the log.
   * @param {string} [txHash] Filter events by a transaction hash.
   * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
   * @param {ChainName} [chain] Filter events by a chain name.
   * @param {string} [contractAddress] Filter events by a contract address.
   * @param {string} [contractLabel] Filter events by a contract label.
   * @param {string} [eventSignature] Filter events by the signature.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApi
   */
  public getEventCount(
    blockHash?: string,
    blockNumber?: number,
    txIndexInBlock?: number,
    eventIndexInLog?: number,
    txHash?: string,
    fromConstructor?: boolean,
    chain?: ChainName,
    contractAddress?: string,
    contractLabel?: string,
    eventSignature?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ) {
    return EventsApiFp(this.configuration)
      .getEventCount(
        blockHash,
        blockNumber,
        txIndexInBlock,
        eventIndexInLog,
        txHash,
        fromConstructor,
        chain,
        contractAddress,
        contractLabel,
        eventSignature,
        limit,
        offset,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all events stored in the database.
   * @summary List events
   * @param {string} [blockHash] Filter events by a block hash.
   * @param {number} [blockNumber] Filter events by a block number.
   * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
   * @param {number} [eventIndexInLog] Filter events by index in the log.
   * @param {string} [txHash] Filter events by a transaction hash.
   * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
   * @param {ChainName} [chain] Filter events by a chain name.
   * @param {string} [contractAddress] Filter events by a contract address.
   * @param {string} [contractLabel] Filter events by a contract label.
   * @param {string} [eventSignature] Filter events by the signature.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApi
   */
  public listEvents(
    blockHash?: string,
    blockNumber?: number,
    txIndexInBlock?: number,
    eventIndexInLog?: number,
    txHash?: string,
    fromConstructor?: boolean,
    chain?: ChainName,
    contractAddress?: string,
    contractLabel?: string,
    eventSignature?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ) {
    return EventsApiFp(this.configuration)
      .listEvents(
        blockHash,
        blockNumber,
        txIndexInBlock,
        eventIndexInLog,
        txHash,
        fromConstructor,
        chain,
        contractAddress,
        contractLabel,
        eventSignature,
        limit,
        offset,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HsmApi - axios parameter creator
 * @export
 */
export const HsmApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Adds a new Azure account configuration.
     * @summary Add HSM config
     * @param {BaseAzureAccount} baseAzureAccount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addHsmConfig: async (
      baseAzureAccount: BaseAzureAccount,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'baseAzureAccount' is not null or undefined
      assertParamExists('addHsmConfig', 'baseAzureAccount', baseAzureAccount);
      const localVarPath = `/hsm/config`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseAzureAccount, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds an existing key configuration.
     * @summary Add HSM key
     * @param {AddKey} addKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addHsmKey: async (addKey: AddKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'addKey' is not null or undefined
      assertParamExists('addHsmKey', 'addKey', addKey);
      const localVarPath = `/hsm/key`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(addKey, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new key in the Azure KeyVault.
     * @summary Create HSM key
     * @param {CreateKey} createKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHsmKey: async (createKey: CreateKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createKey' is not null or undefined
      assertParamExists('createHsmKey', 'createKey', createKey);
      const localVarPath = `/hsm/key/new`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createKey, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of HSM configs and their associated wallets.
     * @summary List HSM configs and wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHsm: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/hsm`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of HSM wallets.
     * @summary List HSM wallets
     * @param {string} [keyName] Filter wallets by a key name.
     * @param {string} [keyVersion] Filter wallets by a key version.
     * @param {string} [vaultName] Filter wallets by a vault name.
     * @param {string} [baseGroupName] Filter wallets by a base group name.
     * @param {string} [clientId] Filter wallets by a client ID.
     * @param {string} [publicAddress] Filter wallets by a public address.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHsmWallets: async (
      keyName?: string,
      keyVersion?: string,
      vaultName?: string,
      baseGroupName?: string,
      clientId?: string,
      publicAddress?: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/hsm/wallets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (keyName !== undefined) {
        localVarQueryParameter['key_name'] = keyName;
      }

      if (keyVersion !== undefined) {
        localVarQueryParameter['key_version'] = keyVersion;
      }

      if (vaultName !== undefined) {
        localVarQueryParameter['vault_name'] = vaultName;
      }

      if (baseGroupName !== undefined) {
        localVarQueryParameter['base_group_name'] = baseGroupName;
      }

      if (clientId !== undefined) {
        localVarQueryParameter['client_id'] = clientId;
      }

      if (publicAddress !== undefined) {
        localVarQueryParameter['public_address'] = publicAddress;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes the specified Azure account configuration and its associated keys.
     * @summary Remove HSM config
     * @param {string} clientId The HSM client ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeHsmConfig: async (clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('removeHsmConfig', 'clientId', clientId);
      const localVarPath = `/hsm/config/{client_id}`.replace(`{${'client_id'}}`, encodeURIComponent(String(clientId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes the specified key configuration.
     * @summary Remove HSM key
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeHsmKey: async (walletAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('removeHsmKey', 'walletAddress', walletAddress);
      const localVarPath = `/hsm/key/{wallet_address}`.replace(
        `{${'wallet_address'}}`,
        encodeURIComponent(String(walletAddress))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
     * @summary Set local nonce
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {SetNonceRequest} setNonceRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLocalNonce: async (
      chain: ChainName,
      walletAddress: string,
      setNonceRequest: SetNonceRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('setLocalNonce', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('setLocalNonce', 'walletAddress', walletAddress);
      // verify required parameter 'setNonceRequest' is not null or undefined
      assertParamExists('setLocalNonce', 'setNonceRequest', setNonceRequest);
      const localVarPath = `/chains/{chain}/hsm/nonce/{wallet_address}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(setNonceRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Signs and submits the given transaction using an HSM address.
     * @summary Sign and submit transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {CloudWalletTXToSign} cloudWalletTXToSign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signAndSubmitTransaction: async (
      chain: ChainName,
      cloudWalletTXToSign: CloudWalletTXToSign,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('signAndSubmitTransaction', 'chain', chain);
      // verify required parameter 'cloudWalletTXToSign' is not null or undefined
      assertParamExists('signAndSubmitTransaction', 'cloudWalletTXToSign', cloudWalletTXToSign);
      const localVarPath = `/chains/{chain}/hsm/submit`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cloudWalletTXToSign, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Signs the given data using the given HSM address.
     * @summary Sign data
     * @param {ChainName} chain The blockchain chain label.
     * @param {HSMSignRequest} hSMSignRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signData: async (
      chain: ChainName,
      hSMSignRequest: HSMSignRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('signData', 'chain', chain);
      // verify required parameter 'hSMSignRequest' is not null or undefined
      assertParamExists('signData', 'hSMSignRequest', hSMSignRequest);
      const localVarPath = `/chains/{chain}/hsm/sign`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(hSMSignRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * HsmApi - functional programming interface
 * @export
 */
export const HsmApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HsmApiAxiosParamCreator(configuration);
  return {
    /**
     * Adds a new Azure account configuration.
     * @summary Add HSM config
     * @param {BaseAzureAccount} baseAzureAccount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addHsmConfig(
      baseAzureAccount: BaseAzureAccount,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addHsmConfig(baseAzureAccount, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.addHsmConfig']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds an existing key configuration.
     * @summary Add HSM key
     * @param {AddKey} addKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addHsmKey(
      addKey: AddKey,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addHsmKey(addKey, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.addHsmKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates a new key in the Azure KeyVault.
     * @summary Create HSM key
     * @param {CreateKey} createKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createHsmKey(
      createKey: CreateKey,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateHsmKey200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createHsmKey(createKey, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.createHsmKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of HSM configs and their associated wallets.
     * @summary List HSM configs and wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listHsm(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListHsm200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listHsm(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap['HsmApi.listHsm']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of HSM wallets.
     * @summary List HSM wallets
     * @param {string} [keyName] Filter wallets by a key name.
     * @param {string} [keyVersion] Filter wallets by a key version.
     * @param {string} [vaultName] Filter wallets by a vault name.
     * @param {string} [baseGroupName] Filter wallets by a base group name.
     * @param {string} [clientId] Filter wallets by a client ID.
     * @param {string} [publicAddress] Filter wallets by a public address.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listHsmWallets(
      keyName?: string,
      keyVersion?: string,
      vaultName?: string,
      baseGroupName?: string,
      clientId?: string,
      publicAddress?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListHsmWallets200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listHsmWallets(
        keyName,
        keyVersion,
        vaultName,
        baseGroupName,
        clientId,
        publicAddress,
        limit,
        offset,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.listHsmWallets']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes the specified Azure account configuration and its associated keys.
     * @summary Remove HSM config
     * @param {string} clientId The HSM client ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeHsmConfig(
      clientId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeHsmConfig(clientId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.removeHsmConfig']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes the specified key configuration.
     * @summary Remove HSM key
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeHsmKey(
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeHsmKey(walletAddress, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.removeHsmKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
     * @summary Set local nonce
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {SetNonceRequest} setNonceRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setLocalNonce(
      chain: ChainName,
      walletAddress: string,
      setNonceRequest: SetNonceRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setLocalNonce(
        chain,
        walletAddress,
        setNonceRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.setLocalNonce']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Signs and submits the given transaction using an HSM address.
     * @summary Sign and submit transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {CloudWalletTXToSign} cloudWalletTXToSign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signAndSubmitTransaction(
      chain: ChainName,
      cloudWalletTXToSign: CloudWalletTXToSign,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferEth200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signAndSubmitTransaction(
        chain,
        cloudWalletTXToSign,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.signAndSubmitTransaction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Signs the given data using the given HSM address.
     * @summary Sign data
     * @param {ChainName} chain The blockchain chain label.
     * @param {HSMSignRequest} hSMSignRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signData(
      chain: ChainName,
      hSMSignRequest: HSMSignRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignData200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signData(chain, hSMSignRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.signData']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * HsmApi - factory interface
 * @export
 */
export const HsmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = HsmApiFp(configuration);
  return {
    /**
     * Adds a new Azure account configuration.
     * @summary Add HSM config
     * @param {BaseAzureAccount} baseAzureAccount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addHsmConfig(baseAzureAccount: BaseAzureAccount, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.addHsmConfig(baseAzureAccount, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds an existing key configuration.
     * @summary Add HSM key
     * @param {AddKey} addKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addHsmKey(addKey: AddKey, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.addHsmKey(addKey, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new key in the Azure KeyVault.
     * @summary Create HSM key
     * @param {CreateKey} createKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHsmKey(createKey: CreateKey, options?: RawAxiosRequestConfig): AxiosPromise<CreateHsmKey200Response> {
      return localVarFp.createHsmKey(createKey, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of HSM configs and their associated wallets.
     * @summary List HSM configs and wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHsm(options?: RawAxiosRequestConfig): AxiosPromise<ListHsm200Response> {
      return localVarFp.listHsm(options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of HSM wallets.
     * @summary List HSM wallets
     * @param {string} [keyName] Filter wallets by a key name.
     * @param {string} [keyVersion] Filter wallets by a key version.
     * @param {string} [vaultName] Filter wallets by a vault name.
     * @param {string} [baseGroupName] Filter wallets by a base group name.
     * @param {string} [clientId] Filter wallets by a client ID.
     * @param {string} [publicAddress] Filter wallets by a public address.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHsmWallets(
      keyName?: string,
      keyVersion?: string,
      vaultName?: string,
      baseGroupName?: string,
      clientId?: string,
      publicAddress?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListHsmWallets200Response> {
      return localVarFp
        .listHsmWallets(keyName, keyVersion, vaultName, baseGroupName, clientId, publicAddress, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Removes the specified Azure account configuration and its associated keys.
     * @summary Remove HSM config
     * @param {string} clientId The HSM client ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeHsmConfig(clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.removeHsmConfig(clientId, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes the specified key configuration.
     * @summary Remove HSM key
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeHsmKey(walletAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.removeHsmKey(walletAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
     * @summary Set local nonce
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {SetNonceRequest} setNonceRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLocalNonce(
      chain: ChainName,
      walletAddress: string,
      setNonceRequest: SetNonceRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setLocalNonce(chain, walletAddress, setNonceRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Signs and submits the given transaction using an HSM address.
     * @summary Sign and submit transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {CloudWalletTXToSign} cloudWalletTXToSign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signAndSubmitTransaction(
      chain: ChainName,
      cloudWalletTXToSign: CloudWalletTXToSign,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TransferEth200Response> {
      return localVarFp
        .signAndSubmitTransaction(chain, cloudWalletTXToSign, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Signs the given data using the given HSM address.
     * @summary Sign data
     * @param {ChainName} chain The blockchain chain label.
     * @param {HSMSignRequest} hSMSignRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signData(
      chain: ChainName,
      hSMSignRequest: HSMSignRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SignData200Response> {
      return localVarFp.signData(chain, hSMSignRequest, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * HsmApi - interface
 * @export
 * @interface HsmApi
 */
export interface HsmApiInterface {
  /**
   * Adds a new Azure account configuration.
   * @summary Add HSM config
   * @param {BaseAzureAccount} baseAzureAccount
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  addHsmConfig(baseAzureAccount: BaseAzureAccount, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Adds an existing key configuration.
   * @summary Add HSM key
   * @param {AddKey} addKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  addHsmKey(addKey: AddKey, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Creates a new key in the Azure KeyVault.
   * @summary Create HSM key
   * @param {CreateKey} createKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  createHsmKey(createKey: CreateKey, options?: RawAxiosRequestConfig): AxiosPromise<CreateHsmKey200Response>;

  /**
   * Returns a list of HSM configs and their associated wallets.
   * @summary List HSM configs and wallets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  listHsm(options?: RawAxiosRequestConfig): AxiosPromise<ListHsm200Response>;

  /**
   * Returns a list of HSM wallets.
   * @summary List HSM wallets
   * @param {string} [keyName] Filter wallets by a key name.
   * @param {string} [keyVersion] Filter wallets by a key version.
   * @param {string} [vaultName] Filter wallets by a vault name.
   * @param {string} [baseGroupName] Filter wallets by a base group name.
   * @param {string} [clientId] Filter wallets by a client ID.
   * @param {string} [publicAddress] Filter wallets by a public address.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  listHsmWallets(
    keyName?: string,
    keyVersion?: string,
    vaultName?: string,
    baseGroupName?: string,
    clientId?: string,
    publicAddress?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ListHsmWallets200Response>;

  /**
   * Removes the specified Azure account configuration and its associated keys.
   * @summary Remove HSM config
   * @param {string} clientId The HSM client ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  removeHsmConfig(clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Removes the specified key configuration.
   * @summary Remove HSM key
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  removeHsmKey(walletAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
   * @summary Set local nonce
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {SetNonceRequest} setNonceRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  setLocalNonce(
    chain: ChainName,
    walletAddress: string,
    setNonceRequest: SetNonceRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Signs and submits the given transaction using an HSM address.
   * @summary Sign and submit transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {CloudWalletTXToSign} cloudWalletTXToSign
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  signAndSubmitTransaction(
    chain: ChainName,
    cloudWalletTXToSign: CloudWalletTXToSign,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<TransferEth200Response>;

  /**
   * Signs the given data using the given HSM address.
   * @summary Sign data
   * @param {ChainName} chain The blockchain chain label.
   * @param {HSMSignRequest} hSMSignRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApiInterface
   */
  signData(
    chain: ChainName,
    hSMSignRequest: HSMSignRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<SignData200Response>;
}

/**
 * HsmApi - object-oriented interface
 * @export
 * @class HsmApi
 * @extends {BaseAPI}
 */
export class HsmApi extends BaseAPI implements HsmApiInterface {
  /**
   * Adds a new Azure account configuration.
   * @summary Add HSM config
   * @param {BaseAzureAccount} baseAzureAccount
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public addHsmConfig(baseAzureAccount: BaseAzureAccount, options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .addHsmConfig(baseAzureAccount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an existing key configuration.
   * @summary Add HSM key
   * @param {AddKey} addKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public addHsmKey(addKey: AddKey, options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .addHsmKey(addKey, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new key in the Azure KeyVault.
   * @summary Create HSM key
   * @param {CreateKey} createKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public createHsmKey(createKey: CreateKey, options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .createHsmKey(createKey, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of HSM configs and their associated wallets.
   * @summary List HSM configs and wallets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public listHsm(options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .listHsm(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of HSM wallets.
   * @summary List HSM wallets
   * @param {string} [keyName] Filter wallets by a key name.
   * @param {string} [keyVersion] Filter wallets by a key version.
   * @param {string} [vaultName] Filter wallets by a vault name.
   * @param {string} [baseGroupName] Filter wallets by a base group name.
   * @param {string} [clientId] Filter wallets by a client ID.
   * @param {string} [publicAddress] Filter wallets by a public address.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public listHsmWallets(
    keyName?: string,
    keyVersion?: string,
    vaultName?: string,
    baseGroupName?: string,
    clientId?: string,
    publicAddress?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ) {
    return HsmApiFp(this.configuration)
      .listHsmWallets(keyName, keyVersion, vaultName, baseGroupName, clientId, publicAddress, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes the specified Azure account configuration and its associated keys.
   * @summary Remove HSM config
   * @param {string} clientId The HSM client ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public removeHsmConfig(clientId: string, options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .removeHsmConfig(clientId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes the specified key configuration.
   * @summary Remove HSM key
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public removeHsmKey(walletAddress: string, options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .removeHsmKey(walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
   * @summary Set local nonce
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {SetNonceRequest} setNonceRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public setLocalNonce(
    chain: ChainName,
    walletAddress: string,
    setNonceRequest: SetNonceRequest,
    options?: RawAxiosRequestConfig
  ) {
    return HsmApiFp(this.configuration)
      .setLocalNonce(chain, walletAddress, setNonceRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Signs and submits the given transaction using an HSM address.
   * @summary Sign and submit transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {CloudWalletTXToSign} cloudWalletTXToSign
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public signAndSubmitTransaction(
    chain: ChainName,
    cloudWalletTXToSign: CloudWalletTXToSign,
    options?: RawAxiosRequestConfig
  ) {
    return HsmApiFp(this.configuration)
      .signAndSubmitTransaction(chain, cloudWalletTXToSign, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Signs the given data using the given HSM address.
   * @summary Sign data
   * @param {ChainName} chain The blockchain chain label.
   * @param {HSMSignRequest} hSMSignRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HsmApi
   */
  public signData(chain: ChainName, hSMSignRequest: HSMSignRequest, options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .signData(chain, hSMSignRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TxmApi - axios parameter creator
 * @export
 */
export const TxmApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
     * @summary Cancel transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} gasParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelTransaction: async (
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams: GasParams,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('cancelTransaction', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('cancelTransaction', 'walletAddress', walletAddress);
      // verify required parameter 'nonce' is not null or undefined
      assertParamExists('cancelTransaction', 'nonce', nonce);
      // verify required parameter 'gasParams' is not null or undefined
      assertParamExists('cancelTransaction', 'gasParams', gasParams);
      const localVarPath = `/chains/{chain}/txm/{wallet_address}/nonce/{nonce}/cancel`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)))
        .replace(`{${'nonce'}}`, encodeURIComponent(String(nonce)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(gasParams, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Count all transactions for the given wallet address.
     * @summary Count all transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWalletTransactions: async (
      chain: ChainName,
      walletAddress: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('countWalletTransactions', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('countWalletTransactions', 'walletAddress', walletAddress);
      const localVarPath = `/chains/{chain}/txm/{wallet_address}/count`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List the transactions submitted by the given wallet address.
     * @summary List transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
     * @param {number} [nonce] Filter transactions by nonce
     * @param {TransactionStatus} [status] Filter transactions by status
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWalletTransactions: async (
      chain: ChainName,
      walletAddress: string,
      hash?: string,
      nonce?: number,
      status?: TransactionStatus,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('listWalletTransactions', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('listWalletTransactions', 'walletAddress', walletAddress);
      const localVarPath = `/chains/{chain}/txm/{wallet_address}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (hash !== undefined) {
        localVarQueryParameter['hash'] = hash;
      }

      if (nonce !== undefined) {
        localVarQueryParameter['nonce'] = nonce;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Speeds up a transaction by resubmitting it with a higher gas price.
     * @summary Speed up transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} gasParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speedUpTransaction: async (
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams: GasParams,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('speedUpTransaction', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('speedUpTransaction', 'walletAddress', walletAddress);
      // verify required parameter 'nonce' is not null or undefined
      assertParamExists('speedUpTransaction', 'nonce', nonce);
      // verify required parameter 'gasParams' is not null or undefined
      assertParamExists('speedUpTransaction', 'gasParams', gasParams);
      const localVarPath = `/chains/{chain}/txm/{wallet_address}/nonce/{nonce}/speed_up`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)))
        .replace(`{${'nonce'}}`, encodeURIComponent(String(nonce)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(gasParams, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * TxmApi - functional programming interface
 * @export
 */
export const TxmApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TxmApiAxiosParamCreator(configuration);
  return {
    /**
     * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
     * @summary Cancel transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} gasParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelTransaction(
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams: GasParams,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferEth200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransaction(
        chain,
        walletAddress,
        nonce,
        gasParams,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TxmApi.cancelTransaction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Count all transactions for the given wallet address.
     * @summary Count all transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countWalletTransactions(
      chain: ChainName,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountWalletTransactions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countWalletTransactions(chain, walletAddress, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TxmApi.countWalletTransactions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List the transactions submitted by the given wallet address.
     * @summary List transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
     * @param {number} [nonce] Filter transactions by nonce
     * @param {TransactionStatus} [status] Filter transactions by status
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWalletTransactions(
      chain: ChainName,
      walletAddress: string,
      hash?: string,
      nonce?: number,
      status?: TransactionStatus,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWalletTransactions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWalletTransactions(
        chain,
        walletAddress,
        hash,
        nonce,
        status,
        limit,
        offset,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TxmApi.listWalletTransactions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Speeds up a transaction by resubmitting it with a higher gas price.
     * @summary Speed up transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} gasParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async speedUpTransaction(
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams: GasParams,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferEth200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.speedUpTransaction(
        chain,
        walletAddress,
        nonce,
        gasParams,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TxmApi.speedUpTransaction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * TxmApi - factory interface
 * @export
 */
export const TxmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TxmApiFp(configuration);
  return {
    /**
     * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
     * @summary Cancel transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} gasParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelTransaction(
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams: GasParams,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TransferEth200Response> {
      return localVarFp
        .cancelTransaction(chain, walletAddress, nonce, gasParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Count all transactions for the given wallet address.
     * @summary Count all transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWalletTransactions(
      chain: ChainName,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CountWalletTransactions200Response> {
      return localVarFp
        .countWalletTransactions(chain, walletAddress, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List the transactions submitted by the given wallet address.
     * @summary List transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
     * @param {number} [nonce] Filter transactions by nonce
     * @param {TransactionStatus} [status] Filter transactions by status
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWalletTransactions(
      chain: ChainName,
      walletAddress: string,
      hash?: string,
      nonce?: number,
      status?: TransactionStatus,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListWalletTransactions200Response> {
      return localVarFp
        .listWalletTransactions(chain, walletAddress, hash, nonce, status, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Speeds up a transaction by resubmitting it with a higher gas price.
     * @summary Speed up transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} gasParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speedUpTransaction(
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams: GasParams,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TransferEth200Response> {
      return localVarFp
        .speedUpTransaction(chain, walletAddress, nonce, gasParams, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * TxmApi - interface
 * @export
 * @interface TxmApi
 */
export interface TxmApiInterface {
  /**
   * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
   * @summary Cancel transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {number} nonce Transaction nonce.
   * @param {GasParams} gasParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApiInterface
   */
  cancelTransaction(
    chain: ChainName,
    walletAddress: string,
    nonce: number,
    gasParams: GasParams,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<TransferEth200Response>;

  /**
   * Count all transactions for the given wallet address.
   * @summary Count all transactions for a wallet
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApiInterface
   */
  countWalletTransactions(
    chain: ChainName,
    walletAddress: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<CountWalletTransactions200Response>;

  /**
   * List the transactions submitted by the given wallet address.
   * @summary List transactions for a wallet
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
   * @param {number} [nonce] Filter transactions by nonce
   * @param {TransactionStatus} [status] Filter transactions by status
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApiInterface
   */
  listWalletTransactions(
    chain: ChainName,
    walletAddress: string,
    hash?: string,
    nonce?: number,
    status?: TransactionStatus,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ListWalletTransactions200Response>;

  /**
   * Speeds up a transaction by resubmitting it with a higher gas price.
   * @summary Speed up transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {number} nonce Transaction nonce.
   * @param {GasParams} gasParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApiInterface
   */
  speedUpTransaction(
    chain: ChainName,
    walletAddress: string,
    nonce: number,
    gasParams: GasParams,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<TransferEth200Response>;
}

/**
 * TxmApi - object-oriented interface
 * @export
 * @class TxmApi
 * @extends {BaseAPI}
 */
export class TxmApi extends BaseAPI implements TxmApiInterface {
  /**
   * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
   * @summary Cancel transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {number} nonce Transaction nonce.
   * @param {GasParams} gasParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApi
   */
  public cancelTransaction(
    chain: ChainName,
    walletAddress: string,
    nonce: number,
    gasParams: GasParams,
    options?: RawAxiosRequestConfig
  ) {
    return TxmApiFp(this.configuration)
      .cancelTransaction(chain, walletAddress, nonce, gasParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Count all transactions for the given wallet address.
   * @summary Count all transactions for a wallet
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApi
   */
  public countWalletTransactions(chain: ChainName, walletAddress: string, options?: RawAxiosRequestConfig) {
    return TxmApiFp(this.configuration)
      .countWalletTransactions(chain, walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List the transactions submitted by the given wallet address.
   * @summary List transactions for a wallet
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
   * @param {number} [nonce] Filter transactions by nonce
   * @param {TransactionStatus} [status] Filter transactions by status
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApi
   */
  public listWalletTransactions(
    chain: ChainName,
    walletAddress: string,
    hash?: string,
    nonce?: number,
    status?: TransactionStatus,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ) {
    return TxmApiFp(this.configuration)
      .listWalletTransactions(chain, walletAddress, hash, nonce, status, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Speeds up a transaction by resubmitting it with a higher gas price.
   * @summary Speed up transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {number} nonce Transaction nonce.
   * @param {GasParams} gasParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TxmApi
   */
  public speedUpTransaction(
    chain: ChainName,
    walletAddress: string,
    nonce: number,
    gasParams: GasParams,
    options?: RawAxiosRequestConfig
  ) {
    return TxmApiFp(this.configuration)
      .speedUpTransaction(chain, walletAddress, nonce, gasParams, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Count the events for the given webhook endpoint.
     * @summary Count webhook events
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWebhookEvents: async (webhookID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'webhookID' is not null or undefined
      assertParamExists('countWebhookEvents', 'webhookID', webhookID);
      const localVarPath = `/webhooks/{webhookID}/events/count`.replace(
        `{${'webhookID'}}`,
        encodeURIComponent(String(webhookID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Count all webhook endpoints.
     * @summary Count webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWebhooks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/webhooks/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a webhook.
     * @summary Create webhook
     * @param {BaseWebhookEndpoint} baseWebhookEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook: async (
      baseWebhookEndpoint: BaseWebhookEndpoint,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'baseWebhookEndpoint' is not null or undefined
      assertParamExists('createWebhook', 'baseWebhookEndpoint', baseWebhookEndpoint);
      const localVarPath = `/webhooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseWebhookEndpoint, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a webhook endpoint.
     * @summary Delete webhook
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook: async (webhookID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'webhookID' is not null or undefined
      assertParamExists('deleteWebhook', 'webhookID', webhookID);
      const localVarPath = `/webhooks/{webhookID}`.replace(`{${'webhookID'}}`, encodeURIComponent(String(webhookID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a webhook endpoint.
     * @summary Get webhook
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook: async (webhookID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'webhookID' is not null or undefined
      assertParamExists('getWebhook', 'webhookID', webhookID);
      const localVarPath = `/webhooks/{webhookID}`.replace(`{${'webhookID'}}`, encodeURIComponent(String(webhookID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List events for the given webhook endpoint.
     * @summary List webhook events
     * @param {number} webhookID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhookEvents: async (
      webhookID: number,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookID' is not null or undefined
      assertParamExists('listWebhookEvents', 'webhookID', webhookID);
      const localVarPath = `/webhooks/{webhookID}/events`.replace(
        `{${'webhookID'}}`,
        encodeURIComponent(String(webhookID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List all webhook endpoints.
     * @summary List webhooks
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks: async (
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/webhooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update a webhook endpoint.
     * @summary Update webhook
     * @param {number} webhookID
     * @param {BaseWebhookEndpoint} baseWebhookEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook: async (
      webhookID: number,
      baseWebhookEndpoint: BaseWebhookEndpoint,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookID' is not null or undefined
      assertParamExists('updateWebhook', 'webhookID', webhookID);
      // verify required parameter 'baseWebhookEndpoint' is not null or undefined
      assertParamExists('updateWebhook', 'baseWebhookEndpoint', baseWebhookEndpoint);
      const localVarPath = `/webhooks/{webhookID}`.replace(`{${'webhookID'}}`, encodeURIComponent(String(webhookID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseWebhookEndpoint, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration);
  return {
    /**
     * Count the events for the given webhook endpoint.
     * @summary Count webhook events
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countWebhookEvents(
      webhookID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountWebhookEvents200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countWebhookEvents(webhookID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.countWebhookEvents']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Count all webhook endpoints.
     * @summary Count webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countWebhooks(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountWebhooks200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countWebhooks(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.countWebhooks']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a webhook.
     * @summary Create webhook
     * @param {BaseWebhookEndpoint} baseWebhookEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createWebhook(
      baseWebhookEndpoint: BaseWebhookEndpoint,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhook200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(baseWebhookEndpoint, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.createWebhook']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete a webhook endpoint.
     * @summary Delete webhook
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteWebhook(
      webhookID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a webhook endpoint.
     * @summary Get webhook
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWebhook(
      webhookID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhook200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(webhookID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.getWebhook']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List events for the given webhook endpoint.
     * @summary List webhook events
     * @param {number} webhookID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWebhookEvents(
      webhookID: number,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWebhookEvents200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhookEvents(webhookID, limit, offset, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.listWebhookEvents']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List all webhook endpoints.
     * @summary List webhooks
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWebhooks(
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWebhooks200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(limit, offset, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.listWebhooks']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update a webhook endpoint.
     * @summary Update webhook
     * @param {number} webhookID
     * @param {BaseWebhookEndpoint} baseWebhookEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateWebhook(
      webhookID: number,
      baseWebhookEndpoint: BaseWebhookEndpoint,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhook200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookID, baseWebhookEndpoint, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = WebhooksApiFp(configuration);
  return {
    /**
     * Count the events for the given webhook endpoint.
     * @summary Count webhook events
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWebhookEvents(
      webhookID: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CountWebhookEvents200Response> {
      return localVarFp.countWebhookEvents(webhookID, options).then((request) => request(axios, basePath));
    },
    /**
     * Count all webhook endpoints.
     * @summary Count webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWebhooks(options?: RawAxiosRequestConfig): AxiosPromise<CountWebhooks200Response> {
      return localVarFp.countWebhooks(options).then((request) => request(axios, basePath));
    },
    /**
     * Create a webhook.
     * @summary Create webhook
     * @param {BaseWebhookEndpoint} baseWebhookEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(
      baseWebhookEndpoint: BaseWebhookEndpoint,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CreateWebhook200Response> {
      return localVarFp.createWebhook(baseWebhookEndpoint, options).then((request) => request(axios, basePath));
    },
    /**
     * Delete a webhook endpoint.
     * @summary Delete webhook
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(webhookID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.deleteWebhook(webhookID, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a webhook endpoint.
     * @summary Get webhook
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook(webhookID: number, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhook200Response> {
      return localVarFp.getWebhook(webhookID, options).then((request) => request(axios, basePath));
    },
    /**
     * List events for the given webhook endpoint.
     * @summary List webhook events
     * @param {number} webhookID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhookEvents(
      webhookID: number,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListWebhookEvents200Response> {
      return localVarFp
        .listWebhookEvents(webhookID, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List all webhook endpoints.
     * @summary List webhooks
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks(
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListWebhooks200Response> {
      return localVarFp.listWebhooks(limit, offset, options).then((request) => request(axios, basePath));
    },
    /**
     * Update a webhook endpoint.
     * @summary Update webhook
     * @param {number} webhookID
     * @param {BaseWebhookEndpoint} baseWebhookEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook(
      webhookID: number,
      baseWebhookEndpoint: BaseWebhookEndpoint,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CreateWebhook200Response> {
      return localVarFp
        .updateWebhook(webhookID, baseWebhookEndpoint, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * WebhooksApi - interface
 * @export
 * @interface WebhooksApi
 */
export interface WebhooksApiInterface {
  /**
   * Count the events for the given webhook endpoint.
   * @summary Count webhook events
   * @param {number} webhookID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApiInterface
   */
  countWebhookEvents(webhookID: number, options?: RawAxiosRequestConfig): AxiosPromise<CountWebhookEvents200Response>;

  /**
   * Count all webhook endpoints.
   * @summary Count webhooks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApiInterface
   */
  countWebhooks(options?: RawAxiosRequestConfig): AxiosPromise<CountWebhooks200Response>;

  /**
   * Create a webhook.
   * @summary Create webhook
   * @param {BaseWebhookEndpoint} baseWebhookEndpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApiInterface
   */
  createWebhook(
    baseWebhookEndpoint: BaseWebhookEndpoint,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<CreateWebhook200Response>;

  /**
   * Delete a webhook endpoint.
   * @summary Delete webhook
   * @param {number} webhookID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApiInterface
   */
  deleteWebhook(webhookID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Get a webhook endpoint.
   * @summary Get webhook
   * @param {number} webhookID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApiInterface
   */
  getWebhook(webhookID: number, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhook200Response>;

  /**
   * List events for the given webhook endpoint.
   * @summary List webhook events
   * @param {number} webhookID
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApiInterface
   */
  listWebhookEvents(
    webhookID: number,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ListWebhookEvents200Response>;

  /**
   * List all webhook endpoints.
   * @summary List webhooks
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApiInterface
   */
  listWebhooks(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListWebhooks200Response>;

  /**
   * Update a webhook endpoint.
   * @summary Update webhook
   * @param {number} webhookID
   * @param {BaseWebhookEndpoint} baseWebhookEndpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApiInterface
   */
  updateWebhook(
    webhookID: number,
    baseWebhookEndpoint: BaseWebhookEndpoint,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<CreateWebhook200Response>;
}

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI implements WebhooksApiInterface {
  /**
   * Count the events for the given webhook endpoint.
   * @summary Count webhook events
   * @param {number} webhookID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public countWebhookEvents(webhookID: number, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .countWebhookEvents(webhookID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Count all webhook endpoints.
   * @summary Count webhooks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public countWebhooks(options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .countWebhooks(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a webhook.
   * @summary Create webhook
   * @param {BaseWebhookEndpoint} baseWebhookEndpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public createWebhook(baseWebhookEndpoint: BaseWebhookEndpoint, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .createWebhook(baseWebhookEndpoint, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a webhook endpoint.
   * @summary Delete webhook
   * @param {number} webhookID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public deleteWebhook(webhookID: number, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .deleteWebhook(webhookID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a webhook endpoint.
   * @summary Get webhook
   * @param {number} webhookID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public getWebhook(webhookID: number, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .getWebhook(webhookID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List events for the given webhook endpoint.
   * @summary List webhook events
   * @param {number} webhookID
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public listWebhookEvents(webhookID: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .listWebhookEvents(webhookID, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List all webhook endpoints.
   * @summary List webhooks
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public listWebhooks(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .listWebhooks(limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a webhook endpoint.
   * @summary Update webhook
   * @param {number} webhookID
   * @param {BaseWebhookEndpoint} baseWebhookEndpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public updateWebhook(webhookID: number, baseWebhookEndpoint: BaseWebhookEndpoint, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .updateWebhook(webhookID, baseWebhookEndpoint, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
