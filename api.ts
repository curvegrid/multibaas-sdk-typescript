/* tslint:disable */
/* eslint-disable */
/**
 * MultiBaas API
 * MultiBaas API provides a unified interface for interacting with blockchain networks. It enables applications to deploy and manage smart contracts, call contract methods, and query blockchain data through standard REST endpoints. The API also includes features for authentication, role-based access control, and integration with existing systems, allowing developers to build blockchain-powered applications without needing deep protocol-level expertise.
 *
 * The version of the OpenAPI document: 0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * An API key.
 */
export interface APIKey {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  id: number;
  /**
   * The time the API key was created.
   */
  createdAt: string;
  /**
   * The time the API key was last used.
   */
  lastUsedAt?: string;
  /**
   * The ID of the user that created the API key.
   */
  createdBy: number;
  /**
   * The signature of the API key.
   */
  signature: string;
}
/**
 * A freshly created API key with its secret.
 */
export interface APIKeyWithSecret {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  id: number;
  /**
   * The time the API key was created.
   */
  createdAt: string;
  /**
   * The time the API key was last used.
   */
  lastUsedAt?: string;
  /**
   * The ID of the user that created the API key.
   */
  createdBy: number;
  /**
   * The signature of the API key.
   */
  signature: string;
  /**
   * The secret key of the API key.
   */
  key: string;
}
export interface AcceptInvite200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: User;
}
export interface AcceptInviteRequest {
  /**
   * The user ID Token
   */
  idToken?: string;
}
/**
 * An access tuple representing an address and its storage keys.
 */
export interface AccessTuple {
  /**
   * An ethereum address.
   */
  address: string | null;
  storageKeys: Array<string>;
}
/**
 * Add key request data.
 */
export interface AddKey {
  /**
   * The Application ID that will be accessing the Key Vault.
   */
  clientID: string;
  /**
   * The name of the key.
   */
  keyName: string;
  /**
   * The version of the key.
   */
  keyVersion: string;
  /**
   * The name given to the vault your key is stored in.
   */
  vaultName: string;
}
/**
 * An address details.
 */
export interface Address {
  /**
   * An alias to easily identify and reference addresses.
   */
  alias: string;
  /**
   * An ethereum address.
   */
  address: string;
  balance?: string;
  chain: string;
  /**
   * The next transaction nonce for this address (obtained from the blockchain node).
   */
  nonce?: number;
  /**
   * The next transaction nonce for this address when using the nonce management feature.
   */
  localNonce?: number;
  codeAt?: string;
  contracts: Array<ContractMetadata>;
  contractLookup?: Array<ContractLookup>;
}
/**
 * An address and it\'s alias.
 */
export interface AddressAlias {
  /**
   * An alias to easily identify and reference addresses.
   */
  alias: string;
  /**
   * An ethereum address.
   */
  address: string;
}
/**
 * An audit log entry.
 */
export interface AuditLog {
  /**
   * The ID of the user who performed the action.
   */
  actionByID: number;
  /**
   * The ID of the user who was acted upon.
   */
  actionOnID?: number;
  /**
   * The email of the user who performed the action.
   */
  actionByUserEmail: string;
  /**
   * The email of the user who was acted upon.
   */
  actionOnUserEmail?: string;
  /**
   * The type of action that was performed.
   */
  type: string;
  /**
   * The time the action was performed.
   */
  createdAt: string;
  /**
   * The data associated with the action.
   */
  activityData: object;
}
/**
 * Additional information about any EIP-7702 authorizations.
 */
export interface AuthorizationExtraInfo {
  /**
   * An ethereum address.
   */
  authority: string;
  /**
   * Indicates whether the format of the authorization is valid.
   */
  formatValid: boolean;
  /**
   * Additional notes about the validity of the authorization.
   */
  notes: string;
}
/**
 * An Azure account.
 */
export interface AzureAccount {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  /**
   * The Application ID that will be accessing the Key Vault.
   */
  clientID: string;
  /**
   * The application’s secret key that you generate when you first register the application in Azure.
   */
  clientSecret: string;
  /**
   * Also known as Directory ID.
   */
  tenantID: string;
  /**
   * The ID linked to your subscription to Azure services.
   */
  subscriptionID: string;
  /**
   * The Resource Group Name for the resource being accessed.
   */
  baseGroupName: string;
  id: number;
}
/**
 * An HSM Wallet
 */
export interface AzureHardwareWallet {
  id: number;
  azureAccountID: number;
  /**
   * The name given to the vault your key is stored in.
   */
  vaultName: string;
  /**
   * The name of the key.
   */
  keyName: string;
  /**
   * The version of the key.
   */
  keyVersion: string;
  /**
   * An ethereum address.
   */
  publicAddress: string;
}
/**
 * An HSM Wallet returned when a new key is created
 */
export interface AzureWallet {
  /**
   * The name of the key.
   */
  keyName: string;
  /**
   * The version of the key.
   */
  keyVersion: string;
  /**
   * An ethereum address.
   */
  publicAddress: string;
}
/**
 * An API key.
 */
export interface BaseAPIKey {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
}
/**
 * An Azure account.
 */
export interface BaseAzureAccount {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  /**
   * The Application ID that will be accessing the Key Vault.
   */
  clientID: string;
  /**
   * The application’s secret key that you generate when you first register the application in Azure.
   */
  clientSecret: string;
  /**
   * Also known as Directory ID.
   */
  tenantID: string;
  /**
   * The ID linked to your subscription to Azure services.
   */
  subscriptionID: string;
  /**
   * The Resource Group Name for the resource being accessed.
   */
  baseGroupName: string;
}
/**
 * A contract.
 */
export interface BaseContract {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  /**
   * The name of the contract.
   */
  contractName: string;
  /**
   * The contract version.
   */
  version: string;
  /**
   * The smart-contract bytecode.
   */
  bin?: string;
  /**
   * The contract raw ABI JSON string.
   */
  rawAbi: string;
  /**
   * The user documentation JSON string.
   */
  userDoc?: string;
  /**
   * The developer documentation JSON string.
   */
  developerDoc?: string;
  /**
   * The contract metadata JSON string.
   */
  metadata?: string;
  isFavorite?: boolean;
}
/**
 * Standard response.
 */
export interface BaseResponse {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
}
/**
 * A user.
 */
export interface BaseUser {
  /**
   * The user\'s email address.
   */
  email: string;
  /**
   * The user\'s name.
   */
  name: string;
}
export interface BaseWebhookEndpoint {
  /**
   * The URL to send the webhook to.
   */
  url: string;
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  /**
   * The events to subscribe to.
   */
  subscriptions: Array<WebhookEventsType>;
}
/**
 * A block in the Ethereum blockchain.
 */
export interface Block {
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  hash: string;
  difficulty: string;
  gasLimit: number;
  number: string;
  timestamp: number;
  transactions: Array<Transaction>;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  receiptsRoot: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  parentHash: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  sha3Uncles: string;
  /**
   * An ethereum address.
   */
  miner: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  stateRoot: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  transactionsRoot: string;
  /**
   * A hex string.
   */
  logsBloom: string;
  gasUsed: number;
  /**
   * A hex string.
   */
  nonce: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  mixHash: string;
  extraData: string;
  baseFeePerGas?: string;
}
/**
 * CORS Origin
 */
export interface CORSOrigin {
  id?: number;
  /**
   * The CORS Origin
   */
  origin?: string;
}
export interface CallContractFunction200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: CallContractFunction200ResponseAllOfResult;
}
/**
 * @type CallContractFunction200ResponseAllOfResult
 */
export type CallContractFunction200ResponseAllOfResult =
  | ({ kind: 'MethodCallResponse' } & MethodCallResponse)
  | ({ kind: 'TransactionToSignResponse' } & TransactionToSignResponse);

/**
 * A blockchain chain name.
 */

export const ChainName = {
  Ethereum: 'ethereum'
} as const;

export type ChainName = typeof ChainName[keyof typeof ChainName];

/**
 * The status of the Chain
 */
export interface ChainStatus {
  blockNumber: number;
  /**
   * The client version for this chain node.
   */
  version: string;
  chainID: number;
  networkID: number;
  /**
   * The current base fee (only available for chains that support EIP-1559).
   */
  baseFee?: string;
}
/**
 * A Cloud Wallet transaction to be signed.
 */
export interface CloudWalletTXToSign {
  tx: CloudWalletTXToSignTx;
}
/**
 * An Ethereum transaction.
 */
export interface CloudWalletTXToSignTx {
  /**
   * Sender account nonce of the transaction
   */
  nonce?: number;
  /**
   * Gas price of the transaction
   */
  gasPrice?: string;
  /**
   * Fee cap per gas of the transaction
   */
  gasFeeCap?: string;
  /**
   * GasTipCap per gas of the transaction
   */
  gasTipCap?: string;
  /**
   * Gas limit of the transaction
   */
  gas: number;
  /**
   * An ethereum address.
   */
  from: string;
  /**
   * An ethereum address.
   */
  to?: string | null;
  /**
   * Amount (in wei) to send with the transaction.
   */
  value: string;
  /**
   * A hex string.
   */
  data: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  hash?: string;
  /**
   * Transaction type
   */
  type: number;
}
/**
 * A returned contract.
 */
export interface Contract {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  /**
   * The name of the contract.
   */
  contractName: string;
  /**
   * The contract version.
   */
  version: string;
  /**
   * The smart-contract bytecode.
   */
  bin?: string;
  /**
   * The contract raw ABI JSON string.
   */
  rawAbi: string;
  /**
   * The user documentation JSON string.
   */
  userDoc?: string;
  /**
   * The developer documentation JSON string.
   */
  developerDoc?: string;
  /**
   * The contract metadata JSON string.
   */
  metadata?: string;
  isFavorite?: boolean;
  abi: ContractABI;
  /**
   * List of the contract instances.
   */
  instances?: Array<ContractInstance>;
}
/**
 * The contract ABI.
 */
export interface ContractABI {
  constructor: ContractABIMethod1 | null;
  methods: { [key: string]: ContractABIMethod };
  events: { [key: string]: ContractABIEvent };
  errors?: { [key: string]: ContractABIError };
  fallback: ContractABIMethod | null;
  receive: ContractABIMethod | null;
}
/**
 * A contract error.
 */
export interface ContractABIError {
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  id: string;
  name: string;
  signature: string;
  /**
   * List of contract event\'s input arguments.
   */
  inputs: Array<ContractABIErrorArgument>;
  /**
   * The developer documentation.
   */
  notes?: string;
  /**
   * The user documentation.
   */
  description?: string;
}
/**
 * A contract error argument.
 */
export interface ContractABIErrorArgument {
  name: string;
  type: ContractABIType;
  typeName: string;
  indexed: boolean;
  /**
   * The developer documentation.
   */
  notes: string;
}
/**
 * A contract event.
 */
export interface ContractABIEvent {
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  id: string;
  name: string;
  signature: string;
  anonymous: boolean;
  /**
   * List of contract event\'s input arguments.
   */
  inputs: Array<ContractABIEventArgument>;
  /**
   * The developer documentation.
   */
  notes: string;
  /**
   * The user documentation.
   */
  description: string;
}
/**
 * A contract event argument.
 */
export interface ContractABIEventArgument {
  name: string;
  type: ContractABIType;
  typeName: string;
  indexed: boolean;
  typeConversion: ContractABITypeConversion | null;
  /**
   * The developer documentation.
   */
  notes: string;
}
/**
 * A contract function.
 */
export interface ContractABIMethod {
  /**
   * A hex string.
   */
  id: string;
  /**
   * Name of the function.
   */
  name: string;
  /**
   * The function signature.
   */
  signature: string;
  const: boolean;
  payable: boolean;
  /**
   * List of function arguments.
   */
  inputs: Array<ContractABIMethodArgument>;
  /**
   * List of function outputs.
   */
  outputs: Array<ContractABIMethodArgument>;
  author: string;
  notes: string;
  /**
   * The function description.
   */
  description: string;
}
/**
 * A contract function.
 */
export interface ContractABIMethod1 {
  /**
   * A hex string.
   */
  id: string;
  /**
   * Name of the function.
   */
  name: string;
  /**
   * The function signature.
   */
  signature: string;
  const: boolean;
  payable: boolean;
  /**
   * List of function arguments.
   */
  inputs: Array<ContractABIMethodArgument>;
  /**
   * List of function outputs.
   */
  outputs: Array<ContractABIMethodArgument>;
  author: string;
  notes: string;
  /**
   * The function description.
   */
  description: string;
}
/**
 * A contract function argument.
 */
export interface ContractABIMethodArgument {
  name: string;
  type: ContractABIType;
  typeName: string;
  typeConversion: ContractABITypeConversion | null;
  notes: string;
}
/**
 * A contract function or event argument type.
 */
export interface ContractABIType {
  type: string;
  size?: number;
  tupleElems?: Array<ContractABIType>;
  tupleRawNames?: Array<string>;
  elem?: ContractABIType;
}
/**
 * Holds JSON-compatible type conversion information.
 */
export interface ContractABITypeConversion {
  mode: string;
  decimalsAbsolute: number | null;
  decimalsFunction: string | null;
}
/**
 * Type conversion options for an event.
 */
export interface ContractEventOptions {
  signature?: string;
  inputs: Array<ContractParameter>;
}
/**
 * The contract information within the event or transaction.
 */
export interface ContractInformation {
  /**
   * An ethereum address.
   */
  address: string;
  /**
   * An alias to easily identify and reference addresses.
   */
  addressAlias: string;
  /**
   * The name of the contract.
   */
  name: string;
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
}
/**
 * A contract instance
 */
export interface ContractInstance {
  alias: string;
  /**
   * An ethereum address.
   */
  address: string;
}
/**
 * The contract lookup item.
 */
export interface ContractLookup {
  /**
   * An ethereum address.
   */
  address: string;
  /**
   * The name of the contract.
   */
  name?: string;
  /**
   * The contract ABI JSON string.
   */
  abi: string;
  /**
   * The smart-contract bytecode.
   */
  bytecode?: string;
  /**
   * The contract\'s source code.
   */
  source?: string;
  /**
   * The user documentation JSON string.
   */
  userdoc?: string;
  /**
   * The developer documentation JSON string.
   */
  devdoc?: string;
  /**
   * Indicates whether the contract has been verified.
   */
  verified: boolean;
  /**
   * The name of the service that provided the contract verification.
   */
  verifiedSource?: string;
  /**
   * The URL to the contract\'s verification details on the verification service.
   */
  verifiedLink?: string;
  /**
   * Indicates whether the contract is a proxy contract.
   */
  proxy: boolean;
}
export interface ContractMetadata {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  /**
   * The name of the contract.
   */
  name: string;
  /**
   * The contract version.
   */
  version: string;
}
/**
 * The contract method\'s information returned within the event or transaction.
 */
export interface ContractMethodInformation {
  /**
   * The name of the method.
   */
  name: string;
  /**
   * The method signature.
   */
  signature: string;
  inputs: Array<MethodArg>;
}
/**
 * Type conversion options for a function.
 */
export interface ContractMethodOptions {
  /**
   * The function signature.
   */
  signature?: string;
  /**
   * List of function input parameters.
   */
  inputs: Array<ContractParameter>;
  /**
   * List of function output parameters.
   */
  outputs?: Array<ContractParameter>;
}
/**
 * A contract overview.
 */
export interface ContractOverview {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  /**
   * The name of the contract.
   */
  contractName: string;
  /**
   * The contract version.
   */
  version: string;
  isFavorite?: boolean;
  deployable: boolean;
  /**
   * List of contract instances.
   */
  instances: Array<ContractInstance>;
}
/**
 * Type conversion options for an input or an output of a function or an event.
 */
export interface ContractParameter {
  typeConversion: ContractABITypeConversion | null;
}
export interface CountEventQueryRecords200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  /**
   * The record count.
   */
  result: number;
}
export interface CountWalletTransactions200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  /**
   * The transaction count.
   */
  result: number;
}
export interface CountWebhookEvents200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  /**
   * The number of webhook events.
   */
  result: number;
}
export interface CountWebhooks200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  /**
   * The webhook count.
   */
  result: number;
}
export interface CreateApiKey200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: APIKeyWithSecret;
}
export interface CreateApiKeyRequest {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  groupIDs?: Array<number>;
}
export interface CreateHsmKey200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: AzureWallet;
}
/**
 * Create Key request data.
 */
export interface CreateKey {
  /**
   * The Application ID that will be accessing the Key Vault.
   */
  clientID: string;
  /**
   * The name of the key.
   */
  keyName: string;
  /**
   * The name given to the vault your key is stored in.
   */
  vaultName: string;
  useHardwareModule: boolean;
}
export interface CreateWebhook200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: WebhookEndpoint;
}
export interface DeployContract200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: DeployContractTransaction;
}
/**
 * The transaction returned when you deploy a contracts.
 */
export interface DeployContractTransaction {
  tx: TransactionToSignTx;
  submitted: boolean;
  deployAt?: string;
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label?: string;
}
/**
 * The domain fields for EIP-712. All fields are optional per the specification.
 */
export interface EIP712Domain {
  /**
   * Human-readable name of the signing domain.
   */
  name?: string;
  /**
   * Current major version of the signing domain.
   */
  version?: string;
  chainId?: EIP712DomainChainId;
  /**
   * An ethereum address.
   */
  verifyingContract?: string;
  /**
   * A hex string.
   */
  salt?: string;
}
/**
 * @type EIP712DomainChainId
 * The EIP-155 chain ID of the application using the typed data.
 */
export type EIP712DomainChainId = number | string;

export interface EIP712TypeEntry {
  name: string;
  type: string;
}
/**
 * EIP-712 structured typed data object.
 */
export interface EIP712TypedData {
  types: EIP712Types;
  /**
   * The root type of the message object. Must correspond to a key in the `types` object.
   */
  primaryType: string;
  domain: EIP712Domain;
  /**
   * The actual data, conforming to the `primaryType` definition in `types`.
   */
  message: object;
}
/**
 * A mapping of type names to arrays of fields.
 */
export interface EIP712Types {
  [key: string]: Array<EIP712TypeEntry> | any;

  EIP712Domain: Array<EIP712TypeEntry>;
}
/**
 * An event returned by the API call.
 */
export interface Event {
  /**
   * The time at which the event was triggered.
   */
  triggeredAt: string;
  event: EventInformation;
  transaction: TransactionInformation;
}
/**
 * Holds a field in the event\'s data.
 */
export interface EventField {
  /**
   * The input name.
   */
  name: string;
  /**
   * The input value.
   */
  value: any;
  /**
   * Has the value been hashed into a keccak256 string?
   */
  hashed: boolean;
  /**
   * The type of the argument.
   */
  type: string;
}
/**
 * The event information returned as part of an event.
 */
export interface EventInformation {
  /**
   * The name of the event.
   */
  name: string;
  /**
   * The event signature.
   */
  signature: string;
  /**
   * The list of input arguments for the event.
   */
  inputs: Array<EventField>;
  /**
   * The raw output from an event. Omitted when returned as part of a transaction receipt.
   */
  rawFields?: string;
  contract: ContractInformation;
  /**
   * The event\'s index in the log.
   */
  indexInLog: number;
}
/**
 * Status of an Event Monitor
 */
export interface EventMonitorStatus {
  contractId?: number;
  addressId?: number;
  isProcessingPastLogs: boolean;
  idealBlockRange?: number;
  latestBlockNumber: number;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  latestBlockHash: string;
  startBlockNumber: number;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  startBlockHash: string;
  updatedAt: string;
}
/**
 * An event query.
 */
export interface EventQuery {
  events: Array<EventQueryEvent>;
  /**
   * The results will be grouped according to this field. An aggregator for non Group By fields must be specified if groupBy is specified.
   */
  groupBy?: string;
  /**
   * The results will be ordered according to this field.
   */
  orderBy?: string;
  /**
   * Specify ascending or descending order, the default is \"ASC\".
   */
  order?: EventQueryOrderEnum;
}

export const EventQueryOrderEnum = {
  Asc: 'ASC',
  Desc: 'DESC'
} as const;

export type EventQueryOrderEnum = typeof EventQueryOrderEnum[keyof typeof EventQueryOrderEnum];

/**
 * A query on a single event.
 */
export interface EventQueryEvent {
  /**
   * The name of an event.
   */
  eventName: string;
  /**
   * The query information about all the fields to select from an event.
   */
  select: Array<EventQueryField>;
  filter?: EventQueryFilter;
}
/**
 * A single event field\'s query information.
 */
export interface EventQueryField {
  type: FieldType;
  /**
   * The field name. Either `name` or `inputIndex` is required if `fieldType == \"input\"`.
   */
  name?: string;
  /**
   * The field\'s index, can be used in place of `name`.
   */
  inputIndex?: number | null;
  /**
   * The name that will be used to return the field.
   */
  alias?: string;
  /**
   * The type of aggregation to perform on the field.
   */
  aggregator?: EventQueryFieldAggregatorEnum | null;
}

export const EventQueryFieldAggregatorEnum = {
  Add: 'add',
  Subtract: 'subtract',
  Last: 'last',
  First: 'first',
  Min: 'min',
  Max: 'max'
} as const;

export type EventQueryFieldAggregatorEnum =
  typeof EventQueryFieldAggregatorEnum[keyof typeof EventQueryFieldAggregatorEnum];

/**
 * A event query filter.
 */
export interface EventQueryFilter {
  /**
   * The rule type, can be omitted if this is the last filter to be applied.
   */
  rule?: EventQueryFilterRuleEnum;
  fieldType?: FieldType;
  /**
   * The field\'s index, can be used in place of `name`.
   */
  inputIndex?: number | null;
  /**
   * The operator on the filter.
   */
  operator?: EventQueryFilterOperatorEnum;
  /**
   * The value to be compared with.
   */
  value?: string;
  /**
   * Other filters to be applied in succession with the rule specified.
   */
  children?: Array<EventQueryFilter>;
}

export const EventQueryFilterRuleEnum = {
  And: 'and',
  Or: 'or'
} as const;

export type EventQueryFilterRuleEnum = typeof EventQueryFilterRuleEnum[keyof typeof EventQueryFilterRuleEnum];
export const EventQueryFilterOperatorEnum = {
  Equal: 'equal',
  Notequal: 'notequal',
  Lessthan: 'lessthan',
  Greaterthan: 'greaterthan',
  Lessthanorequal: 'lessthanorequal',
  Greaterthanorequal: 'greaterthanorequal'
} as const;

export type EventQueryFilterOperatorEnum =
  typeof EventQueryFilterOperatorEnum[keyof typeof EventQueryFilterOperatorEnum];

/**
 * Results of an executed event query.
 */
export interface EventQueryResults {
  rows: Array<{ [key: string]: any }>;
}
/**
 * Type conversion options for each of the inputs of an event.
 */
export interface EventTypeConversionOptions {
  /**
   * List of event\'s input parameters.
   */
  inputs: Array<TypeConversionOptions>;
}
export interface ExecuteArbitraryEventQuery200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: EventQueryResults;
}
/**
 * The field type in a select or filter.
 */

export const FieldType = {
  Input: 'input',
  ContractLabel: 'contract_label',
  ContractName: 'contract_name',
  ContractAddress: 'contract_address',
  ContractAddressAlias: 'contract_address_alias',
  BlockNumber: 'block_number',
  TriggeredAt: 'triggered_at',
  EventSignature: 'event_signature',
  BlockHash: 'block_hash',
  TxHash: 'tx_hash',
  TxFrom: 'tx_from'
} as const;

export type FieldType = typeof FieldType[keyof typeof FieldType];

/**
 * Specify custom gas parameters
 */
export interface GasParams {
  /**
   * Gas price to use for the cancel/resubmit.
   */
  gasPrice?: string;
  /**
   * Gas fee cap to use for the EIP-1559 cancel/resubmit.
   */
  gasFeeCap?: string;
  /**
   * Gas priority fee cap to use for the EIP-1559 cancel/resubmit.
   */
  gasTipCap?: string;
  /**
   * Gas limit to set for the cancel/resubmit.
   */
  gas?: number;
}
export interface GetApiKey200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: APIKey;
}
export interface GetBlock200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Block;
}
export interface GetChainStatus200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: ChainStatus;
}
export interface GetContract200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Contract;
}
export interface GetContractVersions200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<Contract>;
}
export interface GetEventCount200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  /**
   * The number of events.
   */
  result: number;
}
export interface GetEventMonitorStatus200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: EventMonitorStatus;
}
export interface GetEventQuery200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: EventQuery;
}
export interface GetEventTypeConversions200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: EventTypeConversionOptions;
}
export interface GetFunctionTypeConversions200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: MethodTypeConversionOptions;
}
export interface GetPlan200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Plan;
}
export interface GetTransaction200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: TransactionData;
}
export interface GetTransactionReceipt200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: TransactionReceipt;
}
/**
 * A group.
 */
export interface Group {
  /**
   * The group ID.
   */
  id: number;
  /**
   * The group name.
   */
  name: string;
  /**
   * The group short name.
   */
  shortName: string;
  /**
   * The group description.
   */
  description: string;
  /**
   * The group roles.
   */
  roles: Array<Role>;
}
/**
 * Response body for returning HSM Data.
 */
export interface HSMData {
  configuration: AzureAccount;
  /**
   * An array of Azure Hardware Wallets.
   */
  wallets: Array<AzureHardwareWallet>;
}
/**
 * @type HSMSignRequest
 */
export type HSMSignRequest =
  | ({ method: 'eth_signTypedData_v4' } & HSMSignRequestTypedData)
  | ({ method: 'personal_sign' } & HSMSignRequestPersonalSign);

/**
 * Request to sign a message using a cloud wallet.
 */
export interface HSMSignRequestPersonalSign {
  /**
   * The signing method to use.
   */
  method: string;
  /**
   * An ethereum address.
   */
  address: string;
  /**
   * A hex string.
   */
  data: string;
  chainId?: HSMSignRequestPersonalSignChainId;
}
/**
 * @type HSMSignRequestPersonalSignChainId
 * Optionally lock the message to a specific chain by encoding the chain ID in the signature per EIP-155.
 */
export type HSMSignRequestPersonalSignChainId = number | string;

/**
 * Request to sign typed data using a cloud wallet.
 */
export interface HSMSignRequestTypedData {
  /**
   * The signing method to use.
   */
  method: string;
  /**
   * An ethereum address.
   */
  address: string;
  data: EIP712TypedData;
}
/**
 * Response body representing a sign-data response.
 */
export interface HSMSignResponse {
  publicKey: string;
  signature: string;
}
/**
 * A user invitation to MultiBaas.
 */
export interface Invite {
  /**
   * The invitee\'s email address.
   */
  email: string;
  /**
   * The time the invite was created.
   */
  createdAt: string;
  /**
   * The time the invite expires.
   */
  expiresAt: string;
}
/**
 * An invite request with groups.
 */
export interface InviteRequest {
  /**
   * The invitee\'s email address.
   */
  email: string;
  groupIDs?: Array<number>;
}
export interface LinkAddressContractRequest {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  /**
   * The contract version.
   */
  version?: string;
  /**
   * The block number from which to start syncing events. The value can be `latest` for the latest block number, an absolute block number (e.g. `123` for the block number 123), or a relative block number (e.g. `-100` for 100 blocks before the latest block). If absent, the event monitor will be disabled for this contract and events won\'t be synced.
   */
  startingBlock?: string;
}
export interface ListAddresses200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<AddressAlias>;
}
export interface ListApiKeys200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<APIKey>;
}
export interface ListAuditLogs200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<AuditLog>;
}
export interface ListContractVersions200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: ListContractVersions200ResponseAllOfResult;
}
export interface ListContractVersions200ResponseAllOfResult {
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  versions: Array<string>;
}
export interface ListContracts200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<ContractOverview>;
}
export interface ListCorsOrigins200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<CORSOrigin>;
}
export interface ListEventQueries200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<SavedEventQuery>;
}
export interface ListEvents200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<Event>;
}
export interface ListGroups200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<Group>;
}
export interface ListHsm200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<HSMData>;
}
export interface ListHsmWallets200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<StandaloneWallet>;
}
export interface ListInvites200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<Invite>;
}
export interface ListUserSigners200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<SignerWallet>;
}
export interface ListUsers200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<User>;
}
export interface ListWalletTransactions200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<WalletTransaction>;
}
export interface ListWebhookEvents200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<WebhookEvent>;
}
export interface ListWebhooks200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Array<WebhookEndpoint>;
}
/**
 * A contract log event.
 */
export interface Log {
  /**
   * An ethereum address.
   */
  address: string;
  /**
   * A list of topics provided by the contract.
   */
  topics: Array<string>;
  /**
   * A hex string.
   */
  data: string;
  /**
   * A hex string.
   */
  blockNumber: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  transactionHash: string;
  /**
   * A hex string.
   */
  transactionIndex: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  blockHash: string;
  /**
   * A hex string.
   */
  logIndex: string;
  /**
   * True if this log was reverted due to a chain reorganization.
   */
  removed: boolean;
}
/**
 * An argument passed to a method call.
 */
export interface MethodArg {
  /**
   * The input name.
   */
  name: string;
  /**
   * The input value.
   */
  value: any;
  /**
   * The type of the argument.
   */
  type: string;
}
/**
 * The result of a function call.
 */
export interface MethodCallResponse extends PostMethodResponse {
  /**
   * The function call output.
   */
  output: any;
}
/**
 * Type conversion options for each of the inputs and outputs of a function.
 */
export interface MethodTypeConversionOptions {
  inputs: Array<TypeConversionOptions>;
  outputs: Array<TypeConversionOptions>;
}
/**
 * An error response.
 */
export interface ModelError {
  /**
   * The unique error code.
   */
  status: number;
  /**
   * The human-readable error message.
   */
  message: string;
}
/**
 * A plan containing limits and features.
 */
export interface Plan {
  /**
   * The name of the plan.
   */
  name: string;
  /**
   * When the plan was last updated.
   */
  updatedAt: string;
  /**
   * The limits associated with the plan.
   */
  limits: Array<PlanLimit>;
  /**
   * The features associated with the plan.
   */
  features: Array<PlanFeature>;
}
/**
 * A feature flag in a plan.
 */
export interface PlanFeature {
  /**
   * The name of the feature.
   */
  name: PlanFeatureNameEnum;
  /**
   * Whether the feature is enabled.
   */
  enabled: boolean;
}

export const PlanFeatureNameEnum = {
  EventLoggingFeature: 'event_logging_feature',
  EventMonitorFeature: 'event_monitor_feature',
  EventQueriesFeature: 'event_queries_feature',
  FaucetFeature: 'faucet_feature',
  HistoricalBlocksFeature: 'historical_blocks_feature',
  HsmFeature: 'hsm_feature'
} as const;

export type PlanFeatureNameEnum = typeof PlanFeatureNameEnum[keyof typeof PlanFeatureNameEnum];

/**
 * A limit on plan usage.
 */
export interface PlanLimit {
  /**
   * The name of the limit.
   */
  name: PlanLimitNameEnum;
  /**
   * The limit value. Null means unlimited.
   */
  limit: number | null;
  /**
   * The current count for this limit.
   */
  count?: number;
}

export const PlanLimitNameEnum = {
  ApiCallsPerSec: 'api_calls_per_sec',
  ApiCallsPerDay: 'api_calls_per_day',
  ApiCallsPerMonth: 'api_calls_per_month',
  EventsPerSec: 'events_per_sec',
  Users: 'users',
  Contracts: 'contracts',
  LinkedContracts: 'linked_contracts',
  EventQueryMaxResults: 'event_query_max_results',
  EventLoggingRetentionHours: 'event_logging_retention_hours',
  PastLogsMaxConcurrency: 'past_logs_max_concurrency',
  PastLogsMaxDepth: 'past_logs_max_depth',
  CloudWallets: 'cloud_wallets'
} as const;

export type PlanLimitNameEnum = typeof PlanLimitNameEnum[keyof typeof PlanLimitNameEnum];

/**
 * Arguments to be passed into a contract function.
 */
export interface PostMethodArgs {
  signature?: string;
  /**
   * List of the function arguments.
   */
  args?: Array<any>;
  /**
   * An Ethereum address (0x prefixed hex) or an address alias.
   */
  from?: string;
  /**
   * Nonce to use for the transaction execution.
   */
  nonce?: number;
  /**
   * Gas price to use for the transaction execution.
   */
  gasPrice?: number;
  /**
   * Gas fee cap to use for the 1559 transaction execution.
   */
  gasFeeCap?: number;
  /**
   * Gas priority fee cap to use for the 1559 transaction execution.
   */
  gasTipCap?: number;
  /**
   * Gas limit to set for the transaction execution.
   */
  gas?: number;
  /**
   * An Ethereum address (0x prefixed hex) or an address alias.
   */
  to?: string;
  /**
   * Amount (in wei) to send with the transaction.
   */
  value?: string;
  /**
   * If the `from` address is an HSM address and this flag is set to `true`, the transaction will be automatically signed and submitted to the blockchain.
   */
  signAndSubmit?: boolean;
  /**
   * If the `from` address is an HSM address and this flag is set to `true`, MultiBaas will keep track of the nonce and set it accordingly. This is particularly useful when submitting multiple transactions concurrently or in a very short period of time. If this flag is set to `true` and a `nonce` is provided, it will reset the nonce tracker to the given nonce (useful if the nonce tracker is out of sync).
   */
  nonceManagement?: boolean;
  /**
   * If set to `true`, forces a legacy type transaction. Otherwise an EIP-1559 transaction will created if the network supports it.
   */
  preEIP1559?: boolean;
  /**
   * An Ethereum address (0x prefixed hex) or an address alias.
   */
  signer?: string;
  /**
   * Mode to format integer outputs in the function call\'s responses. There are 3 possible modes:   - `auto` (the default option), where number format is decided by its type:     - If the type has size at most 32 bits, then the number is returned verbatim.     - If the type has size larger than 32 bits, then the number is returned as a string.   - `as_numbers`, where all numbers are returned verbatim.   - `as_strings`, where all numbers are returned as strings.
   */
  formatInts?: string;
  /**
   * Call the function at a specific timestamp. Only available for read functions calls and if the `historical_blocks_feature` is enabled (see the plan endpoint). Mutually exclusive with the `blockNumber` parameter.
   */
  timestamp?: string;
  /**
   * Call the function at a specific block. Only available for read functions calls and if the `historical_blocks_feature` is enabled (see the plan endpoint). Mutually exclusive with the `timestamp` parameter.
   */
  blockNumber?: string;
  /**
   * If set to true the given address and contract don\'t need to be linked for the function to be called.
   */
  contractOverride?: boolean;
}
export interface PostMethodResponse {
  /**
   * The response object type (discriminator).
   */
  kind: string;
}
/**
 * A role.
 */
export interface Role {
  /**
   * The role ID.
   */
  id: number;
  /**
   * The role name.
   */
  name: string;
  /**
   * The role short name.
   */
  shortName: string;
  /**
   * The role description.
   */
  description: string;
}
/**
 * A saved event query.
 */
export interface SavedEventQuery {
  id: number;
  /**
   * An event query label.
   */
  label: string;
  query: EventQuery;
  /**
   * Specifies if this a system-generated query which is not modifiable by the user.
   */
  isSystem: boolean;
}
export interface SetAddress201Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: Address;
}
/**
 * Authorization data for setCode operations.
 */
export interface SetCodeAuthorization {
  /**
   * A hex string.
   */
  chainId: string;
  /**
   * An ethereum address.
   */
  address: string;
  /**
   * A hex string.
   */
  nonce: string;
  /**
   * A hex string.
   */
  yParity: string;
  /**
   * A hex string.
   */
  r: string;
  /**
   * A hex string.
   */
  s: string;
}
/**
 * Request body representing a set local nonce request.
 */
export interface SetNonceRequest {
  /**
   * If nonce is specified the provided value is set, otherwise the value is read from the blockchain.
   */
  nonce?: number;
}
export interface SignData200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: HSMSignResponse;
}
/**
 * A transaction that was signed externally and submitted.
 */
export interface SignedTransactionResponse {
  tx: Transaction;
}
/**
 * The object used to receive a pre-signed raw transaction.
 */
export interface SignedTransactionSubmission {
  /**
   * The pre-signed raw transaction.
   */
  signedTx: string;
}
/**
 * A signer label.
 */
export interface SignerLabel {
  /**
   * The label of the signer.
   */
  label: string;
}
/**
 * A signer wallet.
 */
export interface SignerWallet {
  /**
   * The type of the signer.
   */
  type: SignerWalletTypeEnum;
  /**
   * An ethereum address.
   */
  wallet: string;
  /**
   * An ethereum address.
   */
  signer: string;
  /**
   * The label of the signer.
   */
  label: string;
}

export const SignerWalletTypeEnum = {
  Web3: 'web3',
  Cloud: 'cloud',
  Multisig: 'multisig',
  Safe: 'safe'
} as const;

export type SignerWalletTypeEnum = typeof SignerWalletTypeEnum[keyof typeof SignerWalletTypeEnum];

/**
 * An object containing an HSM wallet\'s details.
 */
export interface StandaloneWallet {
  /**
   * The Application ID that accesses the Key Vault.
   */
  clientID?: string;
  /**
   * The Resource Group Name for the resource being accessed.
   */
  baseGroupName: string;
  /**
   * The name given to the vault your key is stored in.
   */
  vaultName?: string;
  /**
   * The name of the key.
   */
  keyName: string;
  /**
   * The version of the key.
   */
  keyVersion?: string;
  /**
   * An ethereum address.
   */
  publicAddress: string;
}
export interface SubmitSignedTransaction200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: SignedTransactionResponse;
}
/**
 * A transaction from the Ethereum Blockchain.
 */
export interface Transaction {
  /**
   * A hex string.
   */
  type: string;
  /**
   * A hex string or null.
   */
  chainId?: string | null;
  /**
   * A hex string.
   */
  nonce: string;
  /**
   * An ethereum address.
   */
  to: string | null;
  /**
   * An ethereum address.
   */
  from?: string | null;
  /**
   * A hex string.
   */
  gas: string;
  /**
   * A hex string or null.
   */
  gasPrice?: string | null;
  /**
   * A hex string or null.
   */
  maxPriorityFeePerGas?: string | null;
  /**
   * A hex string or null.
   */
  maxFeePerGas?: string | null;
  /**
   * A hex string or null.
   */
  maxFeePerBlobGas?: string | null;
  /**
   * A hex string or null.
   */
  value: string | null;
  /**
   * A hex string.
   */
  input: string;
  accessList?: Array<AccessTuple> | null;
  blobVersionedHashes?: Array<string> | null;
  authorizationList?: Array<SetCodeAuthorization> | null;
  /**
   * A hex string.
   */
  v: string;
  /**
   * A hex string.
   */
  r: string;
  /**
   * A hex string.
   */
  s: string;
  /**
   * A hex string or null.
   */
  yParity?: string | null;
  blobs?: Array<string> | null;
  commitments?: Array<string> | null;
  proofs?: Array<string> | null;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  hash: string;
}
/**
 * The transaction data returned from a call to get transaction by hash.
 */
export interface TransactionData {
  data: Transaction;
  /**
   * Whether the transaction has been included yet.
   */
  isPending: boolean;
  /**
   * An ethereum address.
   */
  from: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  blockHash?: string;
  /**
   * The transaction block number.
   */
  blockNumber?: string;
  contract?: ContractInformation;
  method?: ContractMethodInformation;
  authorizationExtraInfo?: Array<AuthorizationExtraInfo> | null;
}
/**
 * The transaction information returned as part of an event.
 */
export interface TransactionInformation {
  /**
   * An ethereum address.
   */
  from: string;
  /**
   * A hex string.
   */
  txData: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  txHash: string;
  /**
   * The location of the transaction in the block.
   */
  txIndexInBlock: number;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  blockHash: string;
  /**
   * The transaction block number.
   */
  blockNumber: number;
  contract: ContractInformation;
  method: ContractMethodInformation;
}
/**
 * Record of the transaction\'s outcome.
 */
export interface TransactionReceipt {
  data: TransactionReceiptData;
  events?: Array<EventInformation>;
}
export interface TransactionReceiptData {
  /**
   * A hex string.
   */
  type?: string;
  /**
   * A hex string.
   */
  root: string;
  /**
   * A hex string.
   */
  status: string;
  /**
   * A hex string.
   */
  cumulativeGasUsed: string;
  /**
   * A hex string.
   */
  logsBloom: string;
  logs: Array<Log>;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  transactionHash: string;
  /**
   * An ethereum address.
   */
  contractAddress: string;
  /**
   * A hex string.
   */
  gasUsed: string;
  /**
   * A hex string.
   */
  effectiveGasPrice: string;
  /**
   * A hex string.
   */
  blockNumber: string;
  /**
   * A hex string.
   */
  transactionIndex: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  blockHash: string;
}
/**
 * The status of a TXM transaction.
 */

export const TransactionStatus = {
  Pending: 'pending',
  Included: 'included',
  Replaced: 'replaced',
  Cancelled: 'cancelled',
  Rejected: 'rejected',
  ExceededRetryLimit: 'exceeded retry limit'
} as const;

export type TransactionStatus = typeof TransactionStatus[keyof typeof TransactionStatus];

/**
 * A transaction to be signed.
 */
export interface TransactionToSign {
  tx: TransactionToSignTx;
  submitted: boolean;
}
export interface TransactionToSignResponse extends PostMethodResponse {
  tx: TransactionToSignTx;
  submitted: boolean;
}
/**
 * An Ethereum transaction.
 */
export interface TransactionToSignTx {
  /**
   * Sender account nonce of the transaction
   */
  nonce: number;
  /**
   * Gas price of the transaction
   */
  gasPrice?: string;
  /**
   * Fee cap per gas of the transaction
   */
  gasFeeCap?: string;
  /**
   * GasTipCap per gas of the transaction
   */
  gasTipCap?: string;
  /**
   * Gas limit of the transaction
   */
  gas: number;
  /**
   * An ethereum address.
   */
  from: string;
  /**
   * An ethereum address.
   */
  to?: string | null;
  /**
   * Amount (in wei) to send with the transaction.
   */
  value: string;
  /**
   * A hex string.
   */
  data: string;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  hash?: string;
  /**
   * Transaction type
   */
  type: number;
}
export interface TransferEth200Response {
  /**
   * The status code.
   */
  status: number;
  /**
   * The human-readable status message.
   */
  message: string;
  result: TransactionToSign;
}
/**
 * Represents the set of type conversions allowed for a particular input or output of a function (how it may be \"cast\").
 */
export interface TypeConversionOptions {
  types?: Array<string> | null;
}
/**
 * A user.
 */
export interface User {
  /**
   * The user\'s email address.
   */
  email: string;
  /**
   * The user\'s name.
   */
  name: string;
  /**
   * The user ID.
   */
  id: number;
}
export interface WalletTransaction {
  tx: Transaction;
  status: TransactionStatus;
  /**
   * An ethereum address.
   */
  from: string;
  /**
   * The total number of resubmission attempts.
   */
  resubmissionAttempts: number;
  /**
   * The total number of successful resubmission (added into the transaction pool).
   */
  successfulResubmissions: number;
  /**
   * The time the transaction was created.
   */
  createdAt: string;
  /**
   * The time the transaction was last updated.
   */
  updatedAt: string;
  /**
   * Whether the transaction failed when it was included in a block.
   */
  failed?: boolean;
  /**
   * The block number that the transaction was included in.
   */
  blockNumber?: number;
  /**
   * The keccak256 hash as a hex string of 256 bits.
   */
  blockHash?: string;
}

export interface WebhookEndpoint {
  /**
   * The URL to send the webhook to.
   */
  url: string;
  /**
   * An alias to easily identify and reference the entity in subsequent requests.
   */
  label: string;
  /**
   * The events to subscribe to.
   */
  subscriptions: Array<WebhookEventsType>;
  id: number;
  /**
   * The time the next attempt will be made.
   */
  nextAttempt?: string;
  /**
   * The time the last attempt was made.
   */
  lastAttempt?: string;
  /**
   * The number of failed webhook endpoint calls since the last successful call.
   */
  failedCalls: number;
  /**
   * The last error received from the webhook endpoint.
   */
  lastError?: string;
  /**
   * The time the webhook was created.
   */
  createdAt: string;
  /**
   * The time the webhook was last updated.
   */
  updatedAt: string;
  /**
   * The secret key used to sign the webhook.
   */
  secret: string;
}
export interface WebhookEvent {
  /**
   * The ID of the webhook event.
   */
  id: number;
  eventType: WebhookEventsType;
  /**
   * The data associated with the event.
   */
  data: object;
  /**
   * The time the webhook event was created.
   */
  createdAt: string;
  /**
   * The time the webhook event was last updated.
   */
  deliveredAt?: string;
}

/**
 * The type of the webhook event.
 */

export const WebhookEventsType = {
  TransactionIncluded: 'transaction.included',
  EventEmitted: 'event.emitted'
} as const;

export type WebhookEventsType = typeof WebhookEventsType[keyof typeof WebhookEventsType];

/**
 * AddressesApi - axios parameter creator
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Deletes an address alias.
     * @summary Delete address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAddress: async (
      chain: ChainName,
      addressOrAlias: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('deleteAddress', 'chain', chain);
      // verify required parameter 'addressOrAlias' is not null or undefined
      assertParamExists('deleteAddress', 'addressOrAlias', addressOrAlias);
      const localVarPath = `/chains/{chain}/addresses/{address-or-alias}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-alias'}}`, encodeURIComponent(String(addressOrAlias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns details about an address.
     * @summary Get address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {Array<GetAddressIncludeEnum>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address. - &#x60;contractLookup&#x60; to get the contract(s) details for this address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress: async (
      chain: ChainName,
      addressOrAlias: string,
      include?: Array<GetAddressIncludeEnum>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getAddress', 'chain', chain);
      // verify required parameter 'addressOrAlias' is not null or undefined
      assertParamExists('getAddress', 'addressOrAlias', addressOrAlias);
      const localVarPath = `/chains/{chain}/addresses/{address-or-alias}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-alias'}}`, encodeURIComponent(String(addressOrAlias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (include) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the aliased addresses.
     * @summary List addresses
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses: async (chain: ChainName, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('listAddresses', 'chain', chain);
      const localVarPath = `/chains/{chain}/addresses`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Associates an address with an alias.
     * @summary Create or update address
     * @param {ChainName} chain The blockchain chain label.
     * @param {AddressAlias} addressAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAddress: async (
      chain: ChainName,
      addressAlias: AddressAlias,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('setAddress', 'chain', chain);
      // verify required parameter 'addressAlias' is not null or undefined
      assertParamExists('setAddress', 'addressAlias', addressAlias);
      const localVarPath = `/chains/{chain}/addresses`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(addressAlias, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AddressesApi - functional programming interface
 */
export const AddressesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration);
  return {
    /**
     * Deletes an address alias.
     * @summary Delete address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAddress(
      chain: ChainName,
      addressOrAlias: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAddress(chain, addressOrAlias, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AddressesApi.deleteAddress']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns details about an address.
     * @summary Get address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {Array<GetAddressIncludeEnum>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address. - &#x60;contractLookup&#x60; to get the contract(s) details for this address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAddress(
      chain: ChainName,
      addressOrAlias: string,
      include?: Array<GetAddressIncludeEnum>,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetAddress201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(chain, addressOrAlias, include, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AddressesApi.getAddress']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the aliased addresses.
     * @summary List addresses
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAddresses(
      chain: ChainName,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAddresses200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(chain, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AddressesApi.listAddresses']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Associates an address with an alias.
     * @summary Create or update address
     * @param {ChainName} chain The blockchain chain label.
     * @param {AddressAlias} addressAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setAddress(
      chain: ChainName,
      addressAlias: AddressAlias,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetAddress201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setAddress(chain, addressAlias, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AddressesApi.setAddress']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * AddressesApi - factory interface
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AddressesApiFp(configuration);
  return {
    /**
     * Deletes an address alias.
     * @summary Delete address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAddress(
      chain: ChainName,
      addressOrAlias: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp.deleteAddress(chain, addressOrAlias, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns details about an address.
     * @summary Get address
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {Array<GetAddressIncludeEnum>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address. - &#x60;contractLookup&#x60; to get the contract(s) details for this address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress(
      chain: ChainName,
      addressOrAlias: string,
      include?: Array<GetAddressIncludeEnum>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SetAddress201Response> {
      return localVarFp.getAddress(chain, addressOrAlias, include, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the aliased addresses.
     * @summary List addresses
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses(chain: ChainName, options?: RawAxiosRequestConfig): AxiosPromise<ListAddresses200Response> {
      return localVarFp.listAddresses(chain, options).then((request) => request(axios, basePath));
    },
    /**
     * Associates an address with an alias.
     * @summary Create or update address
     * @param {ChainName} chain The blockchain chain label.
     * @param {AddressAlias} addressAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAddress(
      chain: ChainName,
      addressAlias: AddressAlias,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SetAddress201Response> {
      return localVarFp.setAddress(chain, addressAlias, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * AddressesApi - interface
 */
export interface AddressesApiInterface {
  /**
   * Deletes an address alias.
   * @summary Delete address
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  deleteAddress(chain: ChainName, addressOrAlias: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Returns details about an address.
   * @summary Get address
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {Array<GetAddressIncludeEnum>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address. - &#x60;contractLookup&#x60; to get the contract(s) details for this address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getAddress(
    chain: ChainName,
    addressOrAlias: string,
    include?: Array<GetAddressIncludeEnum>,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<SetAddress201Response>;

  /**
   * Returns all the aliased addresses.
   * @summary List addresses
   * @param {ChainName} chain The blockchain chain label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listAddresses(chain: ChainName, options?: RawAxiosRequestConfig): AxiosPromise<ListAddresses200Response>;

  /**
   * Associates an address with an alias.
   * @summary Create or update address
   * @param {ChainName} chain The blockchain chain label.
   * @param {AddressAlias} addressAlias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  setAddress(
    chain: ChainName,
    addressAlias: AddressAlias,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<SetAddress201Response>;
}

/**
 * AddressesApi - object-oriented interface
 */
export class AddressesApi extends BaseAPI implements AddressesApiInterface {
  /**
   * Deletes an address alias.
   * @summary Delete address
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteAddress(chain: ChainName, addressOrAlias: string, options?: RawAxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .deleteAddress(chain, addressOrAlias, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns details about an address.
   * @summary Get address
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {Array<GetAddressIncludeEnum>} [include] Optional data to fetch from the blockchain: - &#x60;balance&#x60; to get the balance of this address. - &#x60;code&#x60; to get the code at this address. - &#x60;nonce&#x60; to get the next available transaction nonce for this address. - &#x60;contractLookup&#x60; to get the contract(s) details for this address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getAddress(
    chain: ChainName,
    addressOrAlias: string,
    include?: Array<GetAddressIncludeEnum>,
    options?: RawAxiosRequestConfig
  ) {
    return AddressesApiFp(this.configuration)
      .getAddress(chain, addressOrAlias, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the aliased addresses.
   * @summary List addresses
   * @param {ChainName} chain The blockchain chain label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listAddresses(chain: ChainName, options?: RawAxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .listAddresses(chain, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Associates an address with an alias.
   * @summary Create or update address
   * @param {ChainName} chain The blockchain chain label.
   * @param {AddressAlias} addressAlias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public setAddress(chain: ChainName, addressAlias: AddressAlias, options?: RawAxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .setAddress(chain, addressAlias, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

export const GetAddressIncludeEnum = {
  Balance: 'balance',
  Code: 'code',
  Nonce: 'nonce',
  ContractLookup: 'contractLookup'
} as const;
export type GetAddressIncludeEnum = typeof GetAddressIncludeEnum[keyof typeof GetAddressIncludeEnum];

/**
 * AdminApi - axios parameter creator
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Accepts a user invite.
     * @summary Accept invite
     * @param {string} inviteID
     * @param {AcceptInviteRequest} acceptInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInvite: async (
      inviteID: string,
      acceptInviteRequest: AcceptInviteRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'inviteID' is not null or undefined
      assertParamExists('acceptInvite', 'inviteID', inviteID);
      // verify required parameter 'acceptInviteRequest' is not null or undefined
      assertParamExists('acceptInvite', 'acceptInviteRequest', acceptInviteRequest);
      const localVarPath = `/invites/{inviteID}`.replace(`{${'inviteID'}}`, encodeURIComponent(String(inviteID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds a CORS origin.
     * @summary Add CORS origin
     * @param {CORSOrigin} cORSOrigin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCorsOrigin: async (cORSOrigin: CORSOrigin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'cORSOrigin' is not null or undefined
      assertParamExists('addCorsOrigin', 'cORSOrigin', cORSOrigin);
      const localVarPath = `/cors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cORSOrigin, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds an API key to a group.
     * @summary Add API key to group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupApiKey: async (
      groupID: number,
      apiKeyID: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('addGroupApiKey', 'groupID', groupID);
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('addGroupApiKey', 'apiKeyID', apiKeyID);
      const localVarPath = `/groups/{groupID}/api_keys/{apiKeyID}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds a role to a group.
     * @summary Add role to group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupRole: async (
      groupID: number,
      roleShortName: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('addGroupRole', 'groupID', groupID);
      // verify required parameter 'roleShortName' is not null or undefined
      assertParamExists('addGroupRole', 'roleShortName', roleShortName);
      const localVarPath = `/groups/{groupID}/roles/{roleShortName}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'roleShortName'}}`, encodeURIComponent(String(roleShortName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds a user to a group.
     * @summary Add user to group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupUser: async (
      groupID: number,
      userID: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('addGroupUser', 'groupID', groupID);
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('addGroupUser', 'userID', userID);
      const localVarPath = `/groups/{groupID}/users/{userID}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Checks if a user invite is valid.
     * @summary Check invite
     * @param {string} inviteID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkInvite: async (inviteID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'inviteID' is not null or undefined
      assertParamExists('checkInvite', 'inviteID', inviteID);
      const localVarPath = `/invites/{inviteID}`.replace(`{${'inviteID'}}`, encodeURIComponent(String(inviteID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates an API key and adds it to group IDs.
     * @summary Create API key
     * @param {CreateApiKeyRequest} createApiKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey: async (
      createApiKeyRequest: CreateApiKeyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createApiKeyRequest' is not null or undefined
      assertParamExists('createApiKey', 'createApiKeyRequest', createApiKeyRequest);
      const localVarPath = `/api_keys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createApiKeyRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an API key.
     * @summary Delete API key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey: async (apiKeyID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('deleteApiKey', 'apiKeyID', apiKeyID);
      const localVarPath = `/api_keys/{apiKeyID}`.replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a user invite.
     * @summary Delete invite
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvite: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('deleteInvite', 'email', email);
      const localVarPath = `/invites/{email}/delete`.replace(`{${'email'}}`, encodeURIComponent(String(email)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a user.
     * @summary Delete user
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (userID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('deleteUser', 'userID', userID);
      const localVarPath = `/users/{userID}`.replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns an API key.
     * @summary Get API Key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey: async (apiKeyID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('getApiKey', 'apiKeyID', apiKeyID);
      const localVarPath = `/api_keys/{apiKeyID}`.replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the current plan with limits and features.
     * @summary Get plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlan: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/plan`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Invites a new user.
     * @summary Invite user
     * @param {InviteRequest} inviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteUser: async (inviteRequest: InviteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'inviteRequest' is not null or undefined
      assertParamExists('inviteUser', 'inviteRequest', inviteRequest);
      const localVarPath = `/invites`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(inviteRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the API keys.
     * @summary List API keys
     * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys: async (all?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api_keys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (all !== undefined) {
        localVarQueryParameter['all'] = all;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the audit logs.
     * @summary List audit logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAuditLogs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/systemactivities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of CORS origins.
     * @summary List CORS origins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCorsOrigins: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/cors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the groups.
     * @summary List groups
     * @param {number} [userID]
     * @param {number} [apiKeyID]
     * @param {boolean} [assignable]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroups: async (
      userID?: number,
      apiKeyID?: number,
      assignable?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/groups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (userID !== undefined) {
        localVarQueryParameter['userID'] = userID;
      }

      if (apiKeyID !== undefined) {
        localVarQueryParameter['apiKeyID'] = apiKeyID;
      }

      if (assignable !== undefined) {
        localVarQueryParameter['assignable'] = assignable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the user invites.
     * @summary List invites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvites: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/invites`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the signers for a user.
     * @summary List user signers
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserSigners: async (userID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('listUserSigners', 'userID', userID);
      const localVarPath = `/users/{userID}/signers`.replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the users.
     * @summary List users
     * @param {number} [groupID]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers: async (groupID?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (groupID !== undefined) {
        localVarQueryParameter['groupID'] = groupID;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a CORS origin.
     * @summary Remove CORS Origin
     * @param {number} originID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCorsOrigin: async (originID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'originID' is not null or undefined
      assertParamExists('removeCorsOrigin', 'originID', originID);
      const localVarPath = `/cors/{originID}`.replace(`{${'originID'}}`, encodeURIComponent(String(originID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes an API key from a group.
     * @summary Remove API key from group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupApiKey: async (
      groupID: number,
      apiKeyID: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('removeGroupApiKey', 'groupID', groupID);
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('removeGroupApiKey', 'apiKeyID', apiKeyID);
      const localVarPath = `/groups/{groupID}/api_keys/{apiKeyID}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a role from a group.
     * @summary Remove role from group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupRole: async (
      groupID: number,
      roleShortName: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('removeGroupRole', 'groupID', groupID);
      // verify required parameter 'roleShortName' is not null or undefined
      assertParamExists('removeGroupRole', 'roleShortName', roleShortName);
      const localVarPath = `/groups/{groupID}/roles/{roleShortName}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'roleShortName'}}`, encodeURIComponent(String(roleShortName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a user from a group.
     * @summary Remove user from group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupUser: async (
      groupID: number,
      userID: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupID' is not null or undefined
      assertParamExists('removeGroupUser', 'groupID', groupID);
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('removeGroupUser', 'userID', userID);
      const localVarPath = `/groups/{groupID}/users/{userID}`
        .replace(`{${'groupID'}}`, encodeURIComponent(String(groupID)))
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a cloud wallet signer from a user.
     * @summary Remove user cloud wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserSignerCloudWallet: async (
      userID: number,
      walletAddress: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('removeUserSignerCloudWallet', 'userID', userID);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('removeUserSignerCloudWallet', 'walletAddress', walletAddress);
      const localVarPath = `/users/{userID}/cloudwallets/{wallet_address}`
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a safe account signer from a user.
     * @summary Remove user safe account signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserSignerSafeAccount: async (
      userID: number,
      walletAddress: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('removeUserSignerSafeAccount', 'userID', userID);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('removeUserSignerSafeAccount', 'walletAddress', walletAddress);
      const localVarPath = `/users/{userID}/safeaccounts/{wallet_address}`
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes a web3 wallet signer from a user.
     * @summary Remove user web3 wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserSignerWeb3Wallet: async (
      userID: number,
      walletAddress: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('removeUserSignerWeb3Wallet', 'userID', userID);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('removeUserSignerWeb3Wallet', 'walletAddress', walletAddress);
      const localVarPath = `/users/{userID}/web3wallets/{wallet_address}`
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds or updates a user\'s cloud wallet signer.
     * @summary Add or update user cloud wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserSignerCloudWallet: async (
      userID: number,
      walletAddress: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('setUserSignerCloudWallet', 'userID', userID);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('setUserSignerCloudWallet', 'walletAddress', walletAddress);
      const localVarPath = `/users/{userID}/cloudwallets/{wallet_address}`
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds or updates a user\'s safe account signer.
     * @summary Add or update user safe account signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {SignerLabel} signerLabel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserSignerSafeAccount: async (
      userID: number,
      walletAddress: string,
      signerLabel: SignerLabel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('setUserSignerSafeAccount', 'userID', userID);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('setUserSignerSafeAccount', 'walletAddress', walletAddress);
      // verify required parameter 'signerLabel' is not null or undefined
      assertParamExists('setUserSignerSafeAccount', 'signerLabel', signerLabel);
      const localVarPath = `/users/{userID}/safeaccounts/{wallet_address}`
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(signerLabel, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds or updates a user\'s web3 wallet signer.
     * @summary Add or update user web3 wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {SignerLabel} signerLabel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserSignerWeb3Wallet: async (
      userID: number,
      walletAddress: string,
      signerLabel: SignerLabel,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('setUserSignerWeb3Wallet', 'userID', userID);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('setUserSignerWeb3Wallet', 'walletAddress', walletAddress);
      // verify required parameter 'signerLabel' is not null or undefined
      assertParamExists('setUserSignerWeb3Wallet', 'signerLabel', signerLabel);
      const localVarPath = `/users/{userID}/web3wallets/{wallet_address}`
        .replace(`{${'userID'}}`, encodeURIComponent(String(userID)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(signerLabel, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates an API key.
     * @summary Update API key
     * @param {number} apiKeyID
     * @param {BaseAPIKey} baseAPIKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApiKey: async (
      apiKeyID: number,
      baseAPIKey: BaseAPIKey,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiKeyID' is not null or undefined
      assertParamExists('updateApiKey', 'apiKeyID', apiKeyID);
      // verify required parameter 'baseAPIKey' is not null or undefined
      assertParamExists('updateApiKey', 'baseAPIKey', baseAPIKey);
      const localVarPath = `/api_keys/{apiKeyID}`.replace(`{${'apiKeyID'}}`, encodeURIComponent(String(apiKeyID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseAPIKey, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AdminApi - functional programming interface
 */
export const AdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration);
  return {
    /**
     * Accepts a user invite.
     * @summary Accept invite
     * @param {string} inviteID
     * @param {AcceptInviteRequest} acceptInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async acceptInvite(
      inviteID: string,
      acceptInviteRequest: AcceptInviteRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcceptInvite200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(inviteID, acceptInviteRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.acceptInvite']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds a CORS origin.
     * @summary Add CORS origin
     * @param {CORSOrigin} cORSOrigin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addCorsOrigin(
      cORSOrigin: CORSOrigin,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addCorsOrigin(cORSOrigin, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.addCorsOrigin']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds an API key to a group.
     * @summary Add API key to group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGroupApiKey(
      groupID: number,
      apiKeyID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupApiKey(groupID, apiKeyID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.addGroupApiKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds a role to a group.
     * @summary Add role to group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGroupRole(
      groupID: number,
      roleShortName: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupRole(groupID, roleShortName, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.addGroupRole']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds a user to a group.
     * @summary Add user to group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGroupUser(
      groupID: number,
      userID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupUser(groupID, userID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.addGroupUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Checks if a user invite is valid.
     * @summary Check invite
     * @param {string} inviteID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkInvite(
      inviteID: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkInvite(inviteID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.checkInvite']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates an API key and adds it to group IDs.
     * @summary Create API key
     * @param {CreateApiKeyRequest} createApiKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApiKey(
      createApiKeyRequest: CreateApiKeyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateApiKey200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(createApiKeyRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.createApiKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes an API key.
     * @summary Delete API key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApiKey(
      apiKeyID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(apiKeyID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.deleteApiKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes a user invite.
     * @summary Delete invite
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteInvite(
      email: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvite(email, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.deleteInvite']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes a user.
     * @summary Delete user
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.deleteUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns an API key.
     * @summary Get API Key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKey(
      apiKeyID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApiKey200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKey(apiKeyID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.getApiKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the current plan with limits and features.
     * @summary Get plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlan(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPlan200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPlan(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.getPlan']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Invites a new user.
     * @summary Invite user
     * @param {InviteRequest} inviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async inviteUser(
      inviteRequest: InviteRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUser(inviteRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.inviteUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the API keys.
     * @summary List API keys
     * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listApiKeys(
      all?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApiKeys200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeys(all, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listApiKeys']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the audit logs.
     * @summary List audit logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAuditLogs(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAuditLogs200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAuditLogs(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listAuditLogs']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of CORS origins.
     * @summary List CORS origins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCorsOrigins(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCorsOrigins200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listCorsOrigins(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listCorsOrigins']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the groups.
     * @summary List groups
     * @param {number} [userID]
     * @param {number} [apiKeyID]
     * @param {boolean} [assignable]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGroups(
      userID?: number,
      apiKeyID?: number,
      assignable?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListGroups200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(userID, apiKeyID, assignable, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listGroups']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the user invites.
     * @summary List invites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInvites(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListInvites200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listInvites(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listInvites']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the signers for a user.
     * @summary List user signers
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUserSigners(
      userID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUserSigners200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUserSigners(userID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listUserSigners']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the users.
     * @summary List users
     * @param {number} [groupID]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUsers(
      groupID?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsers200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(groupID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.listUsers']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes a CORS origin.
     * @summary Remove CORS Origin
     * @param {number} originID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeCorsOrigin(
      originID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeCorsOrigin(originID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeCorsOrigin']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes an API key from a group.
     * @summary Remove API key from group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeGroupApiKey(
      groupID: number,
      apiKeyID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeGroupApiKey(groupID, apiKeyID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeGroupApiKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes a role from a group.
     * @summary Remove role from group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeGroupRole(
      groupID: number,
      roleShortName: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeGroupRole(groupID, roleShortName, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeGroupRole']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes a user from a group.
     * @summary Remove user from group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeGroupUser(
      groupID: number,
      userID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeGroupUser(groupID, userID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeGroupUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes a cloud wallet signer from a user.
     * @summary Remove user cloud wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeUserSignerCloudWallet(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserSignerCloudWallet(
        userID,
        walletAddress,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeUserSignerCloudWallet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes a safe account signer from a user.
     * @summary Remove user safe account signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeUserSignerSafeAccount(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserSignerSafeAccount(
        userID,
        walletAddress,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeUserSignerSafeAccount']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes a web3 wallet signer from a user.
     * @summary Remove user web3 wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeUserSignerWeb3Wallet(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserSignerWeb3Wallet(
        userID,
        walletAddress,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeUserSignerWeb3Wallet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds or updates a user\'s cloud wallet signer.
     * @summary Add or update user cloud wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserSignerCloudWallet(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserSignerCloudWallet(
        userID,
        walletAddress,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.setUserSignerCloudWallet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds or updates a user\'s safe account signer.
     * @summary Add or update user safe account signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {SignerLabel} signerLabel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserSignerSafeAccount(
      userID: number,
      walletAddress: string,
      signerLabel: SignerLabel,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserSignerSafeAccount(
        userID,
        walletAddress,
        signerLabel,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.setUserSignerSafeAccount']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds or updates a user\'s web3 wallet signer.
     * @summary Add or update user web3 wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {SignerLabel} signerLabel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserSignerWeb3Wallet(
      userID: number,
      walletAddress: string,
      signerLabel: SignerLabel,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserSignerWeb3Wallet(
        userID,
        walletAddress,
        signerLabel,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.setUserSignerWeb3Wallet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Updates an API key.
     * @summary Update API key
     * @param {number} apiKeyID
     * @param {BaseAPIKey} baseAPIKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateApiKey(
      apiKeyID: number,
      baseAPIKey: BaseAPIKey,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateApiKey(apiKeyID, baseAPIKey, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.updateApiKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * AdminApi - factory interface
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AdminApiFp(configuration);
  return {
    /**
     * Accepts a user invite.
     * @summary Accept invite
     * @param {string} inviteID
     * @param {AcceptInviteRequest} acceptInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInvite(
      inviteID: string,
      acceptInviteRequest: AcceptInviteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AcceptInvite200Response> {
      return localVarFp
        .acceptInvite(inviteID, acceptInviteRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds a CORS origin.
     * @summary Add CORS origin
     * @param {CORSOrigin} cORSOrigin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCorsOrigin(cORSOrigin: CORSOrigin, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.addCorsOrigin(cORSOrigin, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds an API key to a group.
     * @summary Add API key to group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupApiKey(groupID: number, apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.addGroupApiKey(groupID, apiKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds a role to a group.
     * @summary Add role to group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupRole(groupID: number, roleShortName: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.addGroupRole(groupID, roleShortName, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds a user to a group.
     * @summary Add user to group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupUser(groupID: number, userID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.addGroupUser(groupID, userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Checks if a user invite is valid.
     * @summary Check invite
     * @param {string} inviteID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkInvite(inviteID: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.checkInvite(inviteID, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates an API key and adds it to group IDs.
     * @summary Create API key
     * @param {CreateApiKeyRequest} createApiKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(
      createApiKeyRequest: CreateApiKeyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CreateApiKey200Response> {
      return localVarFp.createApiKey(createApiKeyRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes an API key.
     * @summary Delete API key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey(apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.deleteApiKey(apiKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a user invite.
     * @summary Delete invite
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvite(email: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.deleteInvite(email, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a user.
     * @summary Delete user
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.deleteUser(userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns an API key.
     * @summary Get API Key
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey(apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<GetApiKey200Response> {
      return localVarFp.getApiKey(apiKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the current plan with limits and features.
     * @summary Get plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlan(options?: RawAxiosRequestConfig): AxiosPromise<GetPlan200Response> {
      return localVarFp.getPlan(options).then((request) => request(axios, basePath));
    },
    /**
     * Invites a new user.
     * @summary Invite user
     * @param {InviteRequest} inviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteUser(inviteRequest: InviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.inviteUser(inviteRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the API keys.
     * @summary List API keys
     * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys(all?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListApiKeys200Response> {
      return localVarFp.listApiKeys(all, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the audit logs.
     * @summary List audit logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAuditLogs(options?: RawAxiosRequestConfig): AxiosPromise<ListAuditLogs200Response> {
      return localVarFp.listAuditLogs(options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of CORS origins.
     * @summary List CORS origins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCorsOrigins(options?: RawAxiosRequestConfig): AxiosPromise<ListCorsOrigins200Response> {
      return localVarFp.listCorsOrigins(options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the groups.
     * @summary List groups
     * @param {number} [userID]
     * @param {number} [apiKeyID]
     * @param {boolean} [assignable]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroups(
      userID?: number,
      apiKeyID?: number,
      assignable?: boolean,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListGroups200Response> {
      return localVarFp.listGroups(userID, apiKeyID, assignable, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the user invites.
     * @summary List invites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvites(options?: RawAxiosRequestConfig): AxiosPromise<ListInvites200Response> {
      return localVarFp.listInvites(options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the signers for a user.
     * @summary List user signers
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserSigners(userID: number, options?: RawAxiosRequestConfig): AxiosPromise<ListUserSigners200Response> {
      return localVarFp.listUserSigners(userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the users.
     * @summary List users
     * @param {number} [groupID]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(groupID?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListUsers200Response> {
      return localVarFp.listUsers(groupID, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes a CORS origin.
     * @summary Remove CORS Origin
     * @param {number} originID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCorsOrigin(originID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.removeCorsOrigin(originID, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes an API key from a group.
     * @summary Remove API key from group
     * @param {number} groupID
     * @param {number} apiKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupApiKey(groupID: number, apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.removeGroupApiKey(groupID, apiKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes a role from a group.
     * @summary Remove role from group
     * @param {number} groupID
     * @param {string} roleShortName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupRole(
      groupID: number,
      roleShortName: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp.removeGroupRole(groupID, roleShortName, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes a user from a group.
     * @summary Remove user from group
     * @param {number} groupID
     * @param {number} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupUser(groupID: number, userID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.removeGroupUser(groupID, userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes a cloud wallet signer from a user.
     * @summary Remove user cloud wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserSignerCloudWallet(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .removeUserSignerCloudWallet(userID, walletAddress, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Removes a safe account signer from a user.
     * @summary Remove user safe account signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserSignerSafeAccount(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .removeUserSignerSafeAccount(userID, walletAddress, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Removes a web3 wallet signer from a user.
     * @summary Remove user web3 wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserSignerWeb3Wallet(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .removeUserSignerWeb3Wallet(userID, walletAddress, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds or updates a user\'s cloud wallet signer.
     * @summary Add or update user cloud wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserSignerCloudWallet(
      userID: number,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setUserSignerCloudWallet(userID, walletAddress, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds or updates a user\'s safe account signer.
     * @summary Add or update user safe account signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {SignerLabel} signerLabel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserSignerSafeAccount(
      userID: number,
      walletAddress: string,
      signerLabel: SignerLabel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setUserSignerSafeAccount(userID, walletAddress, signerLabel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds or updates a user\'s web3 wallet signer.
     * @summary Add or update user web3 wallet signer
     * @param {number} userID
     * @param {string} walletAddress An Ethereum address.
     * @param {SignerLabel} signerLabel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserSignerWeb3Wallet(
      userID: number,
      walletAddress: string,
      signerLabel: SignerLabel,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setUserSignerWeb3Wallet(userID, walletAddress, signerLabel, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates an API key.
     * @summary Update API key
     * @param {number} apiKeyID
     * @param {BaseAPIKey} baseAPIKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApiKey(
      apiKeyID: number,
      baseAPIKey: BaseAPIKey,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp.updateApiKey(apiKeyID, baseAPIKey, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * AdminApi - interface
 */
export interface AdminApiInterface {
  /**
   * Accepts a user invite.
   * @summary Accept invite
   * @param {string} inviteID
   * @param {AcceptInviteRequest} acceptInviteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  acceptInvite(
    inviteID: string,
    acceptInviteRequest: AcceptInviteRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<AcceptInvite200Response>;

  /**
   * Adds a CORS origin.
   * @summary Add CORS origin
   * @param {CORSOrigin} cORSOrigin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  addCorsOrigin(cORSOrigin: CORSOrigin, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Adds an API key to a group.
   * @summary Add API key to group
   * @param {number} groupID
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  addGroupApiKey(groupID: number, apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Adds a role to a group.
   * @summary Add role to group
   * @param {number} groupID
   * @param {string} roleShortName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  addGroupRole(groupID: number, roleShortName: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Adds a user to a group.
   * @summary Add user to group
   * @param {number} groupID
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  addGroupUser(groupID: number, userID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Checks if a user invite is valid.
   * @summary Check invite
   * @param {string} inviteID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  checkInvite(inviteID: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Creates an API key and adds it to group IDs.
   * @summary Create API key
   * @param {CreateApiKeyRequest} createApiKeyRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  createApiKey(
    createApiKeyRequest: CreateApiKeyRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<CreateApiKey200Response>;

  /**
   * Deletes an API key.
   * @summary Delete API key
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  deleteApiKey(apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Deletes a user invite.
   * @summary Delete invite
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  deleteInvite(email: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   * Deletes a user.
   * @summary Delete user
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  deleteUser(userID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Returns an API key.
   * @summary Get API Key
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getApiKey(apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<GetApiKey200Response>;

  /**
   * Returns the current plan with limits and features.
   * @summary Get plan
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getPlan(options?: RawAxiosRequestConfig): AxiosPromise<GetPlan200Response>;

  /**
   * Invites a new user.
   * @summary Invite user
   * @param {InviteRequest} inviteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  inviteUser(inviteRequest: InviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Returns all the API keys.
   * @summary List API keys
   * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listApiKeys(all?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListApiKeys200Response>;

  /**
   * Returns the audit logs.
   * @summary List audit logs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listAuditLogs(options?: RawAxiosRequestConfig): AxiosPromise<ListAuditLogs200Response>;

  /**
   * Returns a list of CORS origins.
   * @summary List CORS origins
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listCorsOrigins(options?: RawAxiosRequestConfig): AxiosPromise<ListCorsOrigins200Response>;

  /**
   * Returns all the groups.
   * @summary List groups
   * @param {number} [userID]
   * @param {number} [apiKeyID]
   * @param {boolean} [assignable]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listGroups(
    userID?: number,
    apiKeyID?: number,
    assignable?: boolean,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ListGroups200Response>;

  /**
   * Returns all the user invites.
   * @summary List invites
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listInvites(options?: RawAxiosRequestConfig): AxiosPromise<ListInvites200Response>;

  /**
   * Returns all the signers for a user.
   * @summary List user signers
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listUserSigners(userID: number, options?: RawAxiosRequestConfig): AxiosPromise<ListUserSigners200Response>;

  /**
   * Returns all the users.
   * @summary List users
   * @param {number} [groupID]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listUsers(groupID?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListUsers200Response>;

  /**
   * Removes a CORS origin.
   * @summary Remove CORS Origin
   * @param {number} originID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  removeCorsOrigin(originID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Removes an API key from a group.
   * @summary Remove API key from group
   * @param {number} groupID
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  removeGroupApiKey(groupID: number, apiKeyID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Removes a role from a group.
   * @summary Remove role from group
   * @param {number} groupID
   * @param {string} roleShortName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  removeGroupRole(groupID: number, roleShortName: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Removes a user from a group.
   * @summary Remove user from group
   * @param {number} groupID
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  removeGroupUser(groupID: number, userID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Removes a cloud wallet signer from a user.
   * @summary Remove user cloud wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  removeUserSignerCloudWallet(
    userID: number,
    walletAddress: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Removes a safe account signer from a user.
   * @summary Remove user safe account signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  removeUserSignerSafeAccount(
    userID: number,
    walletAddress: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Removes a web3 wallet signer from a user.
   * @summary Remove user web3 wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  removeUserSignerWeb3Wallet(
    userID: number,
    walletAddress: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Adds or updates a user\'s cloud wallet signer.
   * @summary Add or update user cloud wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  setUserSignerCloudWallet(
    userID: number,
    walletAddress: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Adds or updates a user\'s safe account signer.
   * @summary Add or update user safe account signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {SignerLabel} signerLabel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  setUserSignerSafeAccount(
    userID: number,
    walletAddress: string,
    signerLabel: SignerLabel,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Adds or updates a user\'s web3 wallet signer.
   * @summary Add or update user web3 wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {SignerLabel} signerLabel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  setUserSignerWeb3Wallet(
    userID: number,
    walletAddress: string,
    signerLabel: SignerLabel,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Updates an API key.
   * @summary Update API key
   * @param {number} apiKeyID
   * @param {BaseAPIKey} baseAPIKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  updateApiKey(apiKeyID: number, baseAPIKey: BaseAPIKey, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;
}

/**
 * AdminApi - object-oriented interface
 */
export class AdminApi extends BaseAPI implements AdminApiInterface {
  /**
   * Accepts a user invite.
   * @summary Accept invite
   * @param {string} inviteID
   * @param {AcceptInviteRequest} acceptInviteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public acceptInvite(inviteID: string, acceptInviteRequest: AcceptInviteRequest, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .acceptInvite(inviteID, acceptInviteRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a CORS origin.
   * @summary Add CORS origin
   * @param {CORSOrigin} cORSOrigin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public addCorsOrigin(cORSOrigin: CORSOrigin, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .addCorsOrigin(cORSOrigin, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an API key to a group.
   * @summary Add API key to group
   * @param {number} groupID
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public addGroupApiKey(groupID: number, apiKeyID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .addGroupApiKey(groupID, apiKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a role to a group.
   * @summary Add role to group
   * @param {number} groupID
   * @param {string} roleShortName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public addGroupRole(groupID: number, roleShortName: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .addGroupRole(groupID, roleShortName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a user to a group.
   * @summary Add user to group
   * @param {number} groupID
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public addGroupUser(groupID: number, userID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .addGroupUser(groupID, userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Checks if a user invite is valid.
   * @summary Check invite
   * @param {string} inviteID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public checkInvite(inviteID: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .checkInvite(inviteID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates an API key and adds it to group IDs.
   * @summary Create API key
   * @param {CreateApiKeyRequest} createApiKeyRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createApiKey(createApiKeyRequest: CreateApiKeyRequest, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .createApiKey(createApiKeyRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes an API key.
   * @summary Delete API key
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteApiKey(apiKeyID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .deleteApiKey(apiKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a user invite.
   * @summary Delete invite
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteInvite(email: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .deleteInvite(email, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a user.
   * @summary Delete user
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteUser(userID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .deleteUser(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns an API key.
   * @summary Get API Key
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getApiKey(apiKeyID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .getApiKey(apiKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the current plan with limits and features.
   * @summary Get plan
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getPlan(options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .getPlan(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Invites a new user.
   * @summary Invite user
   * @param {InviteRequest} inviteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public inviteUser(inviteRequest: InviteRequest, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .inviteUser(inviteRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the API keys.
   * @summary List API keys
   * @param {boolean} [all] If true, returns all API keys on the system, otherwise, returns only the API keys owned by the calling user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listApiKeys(all?: boolean, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listApiKeys(all, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the audit logs.
   * @summary List audit logs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listAuditLogs(options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listAuditLogs(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of CORS origins.
   * @summary List CORS origins
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listCorsOrigins(options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listCorsOrigins(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the groups.
   * @summary List groups
   * @param {number} [userID]
   * @param {number} [apiKeyID]
   * @param {boolean} [assignable]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listGroups(userID?: number, apiKeyID?: number, assignable?: boolean, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listGroups(userID, apiKeyID, assignable, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the user invites.
   * @summary List invites
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listInvites(options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listInvites(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the signers for a user.
   * @summary List user signers
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listUserSigners(userID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listUserSigners(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the users.
   * @summary List users
   * @param {number} [groupID]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listUsers(groupID?: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .listUsers(groupID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a CORS origin.
   * @summary Remove CORS Origin
   * @param {number} originID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public removeCorsOrigin(originID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeCorsOrigin(originID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes an API key from a group.
   * @summary Remove API key from group
   * @param {number} groupID
   * @param {number} apiKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public removeGroupApiKey(groupID: number, apiKeyID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeGroupApiKey(groupID, apiKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a role from a group.
   * @summary Remove role from group
   * @param {number} groupID
   * @param {string} roleShortName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public removeGroupRole(groupID: number, roleShortName: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeGroupRole(groupID, roleShortName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a user from a group.
   * @summary Remove user from group
   * @param {number} groupID
   * @param {number} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public removeGroupUser(groupID: number, userID: number, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeGroupUser(groupID, userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a cloud wallet signer from a user.
   * @summary Remove user cloud wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public removeUserSignerCloudWallet(userID: number, walletAddress: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeUserSignerCloudWallet(userID, walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a safe account signer from a user.
   * @summary Remove user safe account signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public removeUserSignerSafeAccount(userID: number, walletAddress: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeUserSignerSafeAccount(userID, walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes a web3 wallet signer from a user.
   * @summary Remove user web3 wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public removeUserSignerWeb3Wallet(userID: number, walletAddress: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .removeUserSignerWeb3Wallet(userID, walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds or updates a user\'s cloud wallet signer.
   * @summary Add or update user cloud wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public setUserSignerCloudWallet(userID: number, walletAddress: string, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .setUserSignerCloudWallet(userID, walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds or updates a user\'s safe account signer.
   * @summary Add or update user safe account signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {SignerLabel} signerLabel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public setUserSignerSafeAccount(
    userID: number,
    walletAddress: string,
    signerLabel: SignerLabel,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .setUserSignerSafeAccount(userID, walletAddress, signerLabel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds or updates a user\'s web3 wallet signer.
   * @summary Add or update user web3 wallet signer
   * @param {number} userID
   * @param {string} walletAddress An Ethereum address.
   * @param {SignerLabel} signerLabel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public setUserSignerWeb3Wallet(
    userID: number,
    walletAddress: string,
    signerLabel: SignerLabel,
    options?: RawAxiosRequestConfig
  ) {
    return AdminApiFp(this.configuration)
      .setUserSignerWeb3Wallet(userID, walletAddress, signerLabel, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates an API key.
   * @summary Update API key
   * @param {number} apiKeyID
   * @param {BaseAPIKey} baseAPIKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public updateApiKey(apiKeyID: number, baseAPIKey: BaseAPIKey, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .updateApiKey(apiKeyID, baseAPIKey, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ChainsApi - axios parameter creator
 */
export const ChainsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns a block.
     * @summary Get a block
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlock: async (chain: ChainName, block: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getBlock', 'chain', chain);
      // verify required parameter 'block' is not null or undefined
      assertParamExists('getBlock', 'block', block);
      const localVarPath = `/chains/{chain}/blocks/{block}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'block'}}`, encodeURIComponent(String(block)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the chain status.
     * @summary Get chain status
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChainStatus: async (chain: ChainName, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getChainStatus', 'chain', chain);
      const localVarPath = `/chains/{chain}/status`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a transaction.
     * @summary Get transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash A transaction hash.
     * @param {GetTransactionIncludeEnum} [include] Include contract and method call details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction: async (
      chain: ChainName,
      hash: string,
      include?: GetTransactionIncludeEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getTransaction', 'chain', chain);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('getTransaction', 'hash', hash);
      const localVarPath = `/chains/{chain}/transactions/{hash}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'hash'}}`, encodeURIComponent(String(hash)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
     * @summary Get transaction receipt
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash A transaction hash.
     * @param {GetTransactionReceiptIncludeEnum} [include] Include contract and event details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionReceipt: async (
      chain: ChainName,
      hash: string,
      include?: GetTransactionReceiptIncludeEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getTransactionReceipt', 'chain', chain);
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('getTransactionReceipt', 'hash', hash);
      const localVarPath = `/chains/{chain}/transactions/receipt/{hash}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'hash'}}`, encodeURIComponent(String(hash)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Receives a pre-signed raw transaction and submits it to the blockchain.
     * @summary Submit signed transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {SignedTransactionSubmission} signedTransactionSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitSignedTransaction: async (
      chain: ChainName,
      signedTransactionSubmission: SignedTransactionSubmission,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('submitSignedTransaction', 'chain', chain);
      // verify required parameter 'signedTransactionSubmission' is not null or undefined
      assertParamExists('submitSignedTransaction', 'signedTransactionSubmission', signedTransactionSubmission);
      const localVarPath = `/chains/{chain}/transactions/submit`.replace(
        `{${'chain'}}`,
        encodeURIComponent(String(chain))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signedTransactionSubmission,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a transaction for sending the native token between addresses.
     * @summary Transfer ETH
     * @param {ChainName} chain The blockchain chain label.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferEth: async (
      chain: ChainName,
      postMethodArgs: PostMethodArgs,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('transferEth', 'chain', chain);
      // verify required parameter 'postMethodArgs' is not null or undefined
      assertParamExists('transferEth', 'postMethodArgs', postMethodArgs);
      const localVarPath = `/chains/{chain}/transfers`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMethodArgs, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ChainsApi - functional programming interface
 */
export const ChainsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ChainsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a block.
     * @summary Get a block
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlock(
      chain: ChainName,
      block: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBlock200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBlock(chain, block, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChainsApi.getBlock']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the chain status.
     * @summary Get chain status
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChainStatus(
      chain: ChainName,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChainStatus200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChainStatus(chain, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChainsApi.getChainStatus']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a transaction.
     * @summary Get transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash A transaction hash.
     * @param {GetTransactionIncludeEnum} [include] Include contract and method call details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransaction(
      chain: ChainName,
      hash: string,
      include?: GetTransactionIncludeEnum,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(chain, hash, include, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChainsApi.getTransaction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
     * @summary Get transaction receipt
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash A transaction hash.
     * @param {GetTransactionReceiptIncludeEnum} [include] Include contract and event details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionReceipt(
      chain: ChainName,
      hash: string,
      include?: GetTransactionReceiptIncludeEnum,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionReceipt200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionReceipt(chain, hash, include, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChainsApi.getTransactionReceipt']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Receives a pre-signed raw transaction and submits it to the blockchain.
     * @summary Submit signed transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {SignedTransactionSubmission} signedTransactionSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitSignedTransaction(
      chain: ChainName,
      signedTransactionSubmission: SignedTransactionSubmission,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitSignedTransaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.submitSignedTransaction(
        chain,
        signedTransactionSubmission,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChainsApi.submitSignedTransaction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a transaction for sending the native token between addresses.
     * @summary Transfer ETH
     * @param {ChainName} chain The blockchain chain label.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transferEth(
      chain: ChainName,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferEth200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.transferEth(chain, postMethodArgs, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChainsApi.transferEth']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * ChainsApi - factory interface
 */
export const ChainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ChainsApiFp(configuration);
  return {
    /**
     * Returns a block.
     * @summary Get a block
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlock(chain: ChainName, block: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBlock200Response> {
      return localVarFp.getBlock(chain, block, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the chain status.
     * @summary Get chain status
     * @param {ChainName} chain The blockchain chain label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChainStatus(chain: ChainName, options?: RawAxiosRequestConfig): AxiosPromise<GetChainStatus200Response> {
      return localVarFp.getChainStatus(chain, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a transaction.
     * @summary Get transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash A transaction hash.
     * @param {GetTransactionIncludeEnum} [include] Include contract and method call details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(
      chain: ChainName,
      hash: string,
      include?: GetTransactionIncludeEnum,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetTransaction200Response> {
      return localVarFp.getTransaction(chain, hash, include, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
     * @summary Get transaction receipt
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} hash A transaction hash.
     * @param {GetTransactionReceiptIncludeEnum} [include] Include contract and event details, if available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionReceipt(
      chain: ChainName,
      hash: string,
      include?: GetTransactionReceiptIncludeEnum,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetTransactionReceipt200Response> {
      return localVarFp
        .getTransactionReceipt(chain, hash, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Receives a pre-signed raw transaction and submits it to the blockchain.
     * @summary Submit signed transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {SignedTransactionSubmission} signedTransactionSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitSignedTransaction(
      chain: ChainName,
      signedTransactionSubmission: SignedTransactionSubmission,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SubmitSignedTransaction200Response> {
      return localVarFp
        .submitSignedTransaction(chain, signedTransactionSubmission, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a transaction for sending the native token between addresses.
     * @summary Transfer ETH
     * @param {ChainName} chain The blockchain chain label.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferEth(
      chain: ChainName,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TransferEth200Response> {
      return localVarFp.transferEth(chain, postMethodArgs, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * ChainsApi - interface
 */
export interface ChainsApiInterface {
  /**
   * Returns a block.
   * @summary Get a block
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getBlock(chain: ChainName, block: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBlock200Response>;

  /**
   * Returns the chain status.
   * @summary Get chain status
   * @param {ChainName} chain The blockchain chain label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getChainStatus(chain: ChainName, options?: RawAxiosRequestConfig): AxiosPromise<GetChainStatus200Response>;

  /**
   * Returns a transaction.
   * @summary Get transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} hash A transaction hash.
   * @param {GetTransactionIncludeEnum} [include] Include contract and method call details, if available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getTransaction(
    chain: ChainName,
    hash: string,
    include?: GetTransactionIncludeEnum,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetTransaction200Response>;

  /**
   * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
   * @summary Get transaction receipt
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} hash A transaction hash.
   * @param {GetTransactionReceiptIncludeEnum} [include] Include contract and event details, if available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getTransactionReceipt(
    chain: ChainName,
    hash: string,
    include?: GetTransactionReceiptIncludeEnum,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetTransactionReceipt200Response>;

  /**
   * Receives a pre-signed raw transaction and submits it to the blockchain.
   * @summary Submit signed transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {SignedTransactionSubmission} signedTransactionSubmission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  submitSignedTransaction(
    chain: ChainName,
    signedTransactionSubmission: SignedTransactionSubmission,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<SubmitSignedTransaction200Response>;

  /**
   * Returns a transaction for sending the native token between addresses.
   * @summary Transfer ETH
   * @param {ChainName} chain The blockchain chain label.
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  transferEth(
    chain: ChainName,
    postMethodArgs: PostMethodArgs,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<TransferEth200Response>;
}

/**
 * ChainsApi - object-oriented interface
 */
export class ChainsApi extends BaseAPI implements ChainsApiInterface {
  /**
   * Returns a block.
   * @summary Get a block
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} block A block number, hash or \&#39;latest\&#39; for the latest block.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getBlock(chain: ChainName, block: string, options?: RawAxiosRequestConfig) {
    return ChainsApiFp(this.configuration)
      .getBlock(chain, block, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the chain status.
   * @summary Get chain status
   * @param {ChainName} chain The blockchain chain label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getChainStatus(chain: ChainName, options?: RawAxiosRequestConfig) {
    return ChainsApiFp(this.configuration)
      .getChainStatus(chain, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transaction.
   * @summary Get transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} hash A transaction hash.
   * @param {GetTransactionIncludeEnum} [include] Include contract and method call details, if available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getTransaction(
    chain: ChainName,
    hash: string,
    include?: GetTransactionIncludeEnum,
    options?: RawAxiosRequestConfig
  ) {
    return ChainsApiFp(this.configuration)
      .getTransaction(chain, hash, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the receipt of a transaction that\'s been successfully added to the blockchain.
   * @summary Get transaction receipt
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} hash A transaction hash.
   * @param {GetTransactionReceiptIncludeEnum} [include] Include contract and event details, if available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getTransactionReceipt(
    chain: ChainName,
    hash: string,
    include?: GetTransactionReceiptIncludeEnum,
    options?: RawAxiosRequestConfig
  ) {
    return ChainsApiFp(this.configuration)
      .getTransactionReceipt(chain, hash, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Receives a pre-signed raw transaction and submits it to the blockchain.
   * @summary Submit signed transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {SignedTransactionSubmission} signedTransactionSubmission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public submitSignedTransaction(
    chain: ChainName,
    signedTransactionSubmission: SignedTransactionSubmission,
    options?: RawAxiosRequestConfig
  ) {
    return ChainsApiFp(this.configuration)
      .submitSignedTransaction(chain, signedTransactionSubmission, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transaction for sending the native token between addresses.
   * @summary Transfer ETH
   * @param {ChainName} chain The blockchain chain label.
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public transferEth(chain: ChainName, postMethodArgs: PostMethodArgs, options?: RawAxiosRequestConfig) {
    return ChainsApiFp(this.configuration)
      .transferEth(chain, postMethodArgs, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

export const GetTransactionIncludeEnum = {
  Contract: 'contract'
} as const;
export type GetTransactionIncludeEnum = typeof GetTransactionIncludeEnum[keyof typeof GetTransactionIncludeEnum];
export const GetTransactionReceiptIncludeEnum = {
  Contract: 'contract'
} as const;
export type GetTransactionReceiptIncludeEnum =
  typeof GetTransactionReceiptIncludeEnum[keyof typeof GetTransactionReceiptIncludeEnum];

/**
 * ContractsApi - axios parameter creator
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
     * @summary Call a contract function
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {string} method Contract function.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callContractFunction: async (
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      method: string,
      postMethodArgs: PostMethodArgs,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('callContractFunction', 'chain', chain);
      // verify required parameter 'addressOrAlias' is not null or undefined
      assertParamExists('callContractFunction', 'addressOrAlias', addressOrAlias);
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('callContractFunction', 'contract', contract);
      // verify required parameter 'method' is not null or undefined
      assertParamExists('callContractFunction', 'method', method);
      // verify required parameter 'postMethodArgs' is not null or undefined
      assertParamExists('callContractFunction', 'postMethodArgs', postMethodArgs);
      const localVarPath = `/chains/{chain}/addresses/{address-or-alias}/contracts/{contract}/methods/{method}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-alias'}}`, encodeURIComponent(String(addressOrAlias)))
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'method'}}`, encodeURIComponent(String(method)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMethodArgs, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds a contract.
     * @summary Create a contract
     * @param {string} contract
     * @param {BaseContract} baseContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContract: async (
      contract: string,
      baseContract: BaseContract,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('createContract', 'contract', contract);
      // verify required parameter 'baseContract' is not null or undefined
      assertParamExists('createContract', 'baseContract', baseContract);
      const localVarPath = `/contracts/{contract}`.replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseContract, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds multiple contracts.
     * @summary Create multiple contracts
     * @param {Array<BaseContract>} baseContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContracts: async (
      baseContract: Array<BaseContract>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'baseContract' is not null or undefined
      assertParamExists('createContracts', 'baseContract', baseContract);
      const localVarPath = `/contracts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseContract, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a contract and all its versions.
     * @summary Delete a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContract: async (contract: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('deleteContract', 'contract', contract);
      const localVarPath = `/contracts/{contract}`.replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a specific contract version.
     * @summary Delete a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContractVersion: async (
      contract: string,
      version: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('deleteContractVersion', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('deleteContractVersion', 'version', version);
      const localVarPath = `/contracts/{contract}/{version}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a transaction to deploy the given contract to the blockchain.
     * @summary Deploy a contract
     * @param {string} contract
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployContract: async (
      contract: string,
      postMethodArgs: PostMethodArgs,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('deployContract', 'contract', contract);
      // verify required parameter 'postMethodArgs' is not null or undefined
      assertParamExists('deployContract', 'postMethodArgs', postMethodArgs);
      const localVarPath = `/contracts/{contract}/deploy`.replace(
        `{${'contract'}}`,
        encodeURIComponent(String(contract))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMethodArgs, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a transaction to deploy the given contract version to the blockchain.
     * @summary Deploy a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployContractVersion: async (
      contract: string,
      version: string,
      postMethodArgs: PostMethodArgs,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('deployContractVersion', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('deployContractVersion', 'version', version);
      // verify required parameter 'postMethodArgs' is not null or undefined
      assertParamExists('deployContractVersion', 'postMethodArgs', postMethodArgs);
      const localVarPath = `/contracts/{contract}/{version}/deploy`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMethodArgs, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the given contract.
     * @summary Get a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContract: async (contract: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getContract', 'contract', contract);
      const localVarPath = `/contracts/{contract}`.replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a specific contract version.
     * @summary Get a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractVersion: async (
      contract: string,
      version: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getContractVersion', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('getContractVersion', 'version', version);
      const localVarPath = `/contracts/{contract}/{version}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all the versions of a contract.
     * @summary Get all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractVersions: async (contract: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getContractVersions', 'contract', contract);
      const localVarPath = `/contracts/{contract}/all`.replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the event monitor status for a given address and contract.
     * @summary Get event monitor status
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventMonitorStatus: async (
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('getEventMonitorStatus', 'chain', chain);
      // verify required parameter 'addressOrAlias' is not null or undefined
      assertParamExists('getEventMonitorStatus', 'addressOrAlias', addressOrAlias);
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getEventMonitorStatus', 'contract', contract);
      const localVarPath = `/chains/{chain}/addresses/{address-or-alias}/contracts/{contract}/status`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-alias'}}`, encodeURIComponent(String(addressOrAlias)))
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the type conversion options for a given contract and event signature.
     * @summary Get event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventTypeConversions: async (
      contract: string,
      version: string,
      event: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getEventTypeConversions', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('getEventTypeConversions', 'version', version);
      // verify required parameter 'event' is not null or undefined
      assertParamExists('getEventTypeConversions', 'event', event);
      const localVarPath = `/contracts/{contract}/{version}/events/{event}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'event'}}`, encodeURIComponent(String(event)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the type conversion options for a given contract and function signature.
     * @summary Get function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctionTypeConversions: async (
      contract: string,
      version: string,
      method: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('getFunctionTypeConversions', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('getFunctionTypeConversions', 'version', version);
      // verify required parameter 'method' is not null or undefined
      assertParamExists('getFunctionTypeConversions', 'method', method);
      const localVarPath = `/contracts/{contract}/{version}/methods/{method}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'method'}}`, encodeURIComponent(String(method)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Links an address to a contract.
     * @summary Link address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {LinkAddressContractRequest} linkAddressContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAddressContract: async (
      chain: ChainName,
      addressOrAlias: string,
      linkAddressContractRequest: LinkAddressContractRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('linkAddressContract', 'chain', chain);
      // verify required parameter 'addressOrAlias' is not null or undefined
      assertParamExists('linkAddressContract', 'addressOrAlias', addressOrAlias);
      // verify required parameter 'linkAddressContractRequest' is not null or undefined
      assertParamExists('linkAddressContract', 'linkAddressContractRequest', linkAddressContractRequest);
      const localVarPath = `/chains/{chain}/addresses/{address-or-alias}/contracts`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-alias'}}`, encodeURIComponent(String(addressOrAlias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        linkAddressContractRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of the versions of a contract.
     * @summary List all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContractVersions: async (contract: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('listContractVersions', 'contract', contract);
      const localVarPath = `/contracts/{contract}/versions`.replace(
        `{${'contract'}}`,
        encodeURIComponent(String(contract))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of contracts.
     * @summary List contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContracts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/contracts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sets the type conversion options for a given contract and event signature.
     * @summary Set event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {ContractEventOptions} contractEventOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEventTypeConversions: async (
      contract: string,
      version: string,
      event: string,
      contractEventOptions: ContractEventOptions,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('setEventTypeConversions', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('setEventTypeConversions', 'version', version);
      // verify required parameter 'event' is not null or undefined
      assertParamExists('setEventTypeConversions', 'event', event);
      // verify required parameter 'contractEventOptions' is not null or undefined
      assertParamExists('setEventTypeConversions', 'contractEventOptions', contractEventOptions);
      const localVarPath = `/contracts/{contract}/{version}/events/{event}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'event'}}`, encodeURIComponent(String(event)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(contractEventOptions, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sets the type conversion options for a given contract and function signature.
     * @summary Set function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {ContractMethodOptions} contractMethodOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFunctionTypeConversions: async (
      contract: string,
      version: string,
      method: string,
      contractMethodOptions: ContractMethodOptions,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('setFunctionTypeConversions', 'contract', contract);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('setFunctionTypeConversions', 'version', version);
      // verify required parameter 'method' is not null or undefined
      assertParamExists('setFunctionTypeConversions', 'method', method);
      // verify required parameter 'contractMethodOptions' is not null or undefined
      assertParamExists('setFunctionTypeConversions', 'contractMethodOptions', contractMethodOptions);
      const localVarPath = `/contracts/{contract}/{version}/methods/{method}`
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'method'}}`, encodeURIComponent(String(method)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(contractMethodOptions, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unlinks an address from a contract.
     * @summary Unlink address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkAddressContract: async (
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('unlinkAddressContract', 'chain', chain);
      // verify required parameter 'addressOrAlias' is not null or undefined
      assertParamExists('unlinkAddressContract', 'addressOrAlias', addressOrAlias);
      // verify required parameter 'contract' is not null or undefined
      assertParamExists('unlinkAddressContract', 'contract', contract);
      const localVarPath = `/chains/{chain}/addresses/{address-or-alias}/contracts/{contract}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'address-or-alias'}}`, encodeURIComponent(String(addressOrAlias)))
        .replace(`{${'contract'}}`, encodeURIComponent(String(contract)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ContractsApi - functional programming interface
 */
export const ContractsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration);
  return {
    /**
     * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
     * @summary Call a contract function
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {string} method Contract function.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callContractFunction(
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      method: string,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CallContractFunction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.callContractFunction(
        chain,
        addressOrAlias,
        contract,
        method,
        postMethodArgs,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.callContractFunction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds a contract.
     * @summary Create a contract
     * @param {string} contract
     * @param {BaseContract} baseContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createContract(
      contract: string,
      baseContract: BaseContract,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createContract(contract, baseContract, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.createContract']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds multiple contracts.
     * @summary Create multiple contracts
     * @param {Array<BaseContract>} baseContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createContracts(
      baseContract: Array<BaseContract>,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createContracts(baseContract, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.createContracts']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes a contract and all its versions.
     * @summary Delete a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteContract(
      contract: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContract(contract, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.deleteContract']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes a specific contract version.
     * @summary Delete a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteContractVersion(
      contract: string,
      version: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContractVersion(contract, version, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.deleteContractVersion']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a transaction to deploy the given contract to the blockchain.
     * @summary Deploy a contract
     * @param {string} contract
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deployContract(
      contract: string,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deployContract(contract, postMethodArgs, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.deployContract']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a transaction to deploy the given contract version to the blockchain.
     * @summary Deploy a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deployContractVersion(
      contract: string,
      version: string,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deployContractVersion(
        contract,
        version,
        postMethodArgs,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.deployContractVersion']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the given contract.
     * @summary Get a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContract(
      contract: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContract(contract, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.getContract']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a specific contract version.
     * @summary Get a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContractVersion(
      contract: string,
      version: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContractVersion(contract, version, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.getContractVersion']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the versions of a contract.
     * @summary Get all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContractVersions(
      contract: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContractVersions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContractVersions(contract, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.getContractVersions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the event monitor status for a given address and contract.
     * @summary Get event monitor status
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventMonitorStatus(
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventMonitorStatus200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventMonitorStatus(
        chain,
        addressOrAlias,
        contract,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.getEventMonitorStatus']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the type conversion options for a given contract and event signature.
     * @summary Get event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventTypeConversions(
      contract: string,
      version: string,
      event: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventTypeConversions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventTypeConversions(
        contract,
        version,
        event,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.getEventTypeConversions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the type conversion options for a given contract and function signature.
     * @summary Get function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFunctionTypeConversions(
      contract: string,
      version: string,
      method: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFunctionTypeConversions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFunctionTypeConversions(
        contract,
        version,
        method,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.getFunctionTypeConversions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Links an address to a contract.
     * @summary Link address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {LinkAddressContractRequest} linkAddressContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async linkAddressContract(
      chain: ChainName,
      addressOrAlias: string,
      linkAddressContractRequest: LinkAddressContractRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetAddress201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.linkAddressContract(
        chain,
        addressOrAlias,
        linkAddressContractRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.linkAddressContract']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of the versions of a contract.
     * @summary List all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listContractVersions(
      contract: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContractVersions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listContractVersions(contract, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.listContractVersions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of contracts.
     * @summary List contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listContracts(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContracts200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listContracts(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.listContracts']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Sets the type conversion options for a given contract and event signature.
     * @summary Set event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {ContractEventOptions} contractEventOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setEventTypeConversions(
      contract: string,
      version: string,
      event: string,
      contractEventOptions: ContractEventOptions,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setEventTypeConversions(
        contract,
        version,
        event,
        contractEventOptions,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.setEventTypeConversions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Sets the type conversion options for a given contract and function signature.
     * @summary Set function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {ContractMethodOptions} contractMethodOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setFunctionTypeConversions(
      contract: string,
      version: string,
      method: string,
      contractMethodOptions: ContractMethodOptions,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setFunctionTypeConversions(
        contract,
        version,
        method,
        contractMethodOptions,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.setFunctionTypeConversions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Unlinks an address from a contract.
     * @summary Unlink address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unlinkAddressContract(
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetAddress201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkAddressContract(
        chain,
        addressOrAlias,
        contract,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ContractsApi.unlinkAddressContract']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * ContractsApi - factory interface
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ContractsApiFp(configuration);
  return {
    /**
     * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
     * @summary Call a contract function
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {string} method Contract function.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callContractFunction(
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      method: string,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CallContractFunction200Response> {
      return localVarFp
        .callContractFunction(chain, addressOrAlias, contract, method, postMethodArgs, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds a contract.
     * @summary Create a contract
     * @param {string} contract
     * @param {BaseContract} baseContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContract(
      contract: string,
      baseContract: BaseContract,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetContract200Response> {
      return localVarFp.createContract(contract, baseContract, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds multiple contracts.
     * @summary Create multiple contracts
     * @param {Array<BaseContract>} baseContract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContracts(baseContract: Array<BaseContract>, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.createContracts(baseContract, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a contract and all its versions.
     * @summary Delete a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContract(contract: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.deleteContract(contract, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a specific contract version.
     * @summary Delete a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContractVersion(
      contract: string,
      version: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp.deleteContractVersion(contract, version, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a transaction to deploy the given contract to the blockchain.
     * @summary Deploy a contract
     * @param {string} contract
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployContract(
      contract: string,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<DeployContract200Response> {
      return localVarFp.deployContract(contract, postMethodArgs, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a transaction to deploy the given contract version to the blockchain.
     * @summary Deploy a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {PostMethodArgs} postMethodArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployContractVersion(
      contract: string,
      version: string,
      postMethodArgs: PostMethodArgs,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<DeployContract200Response> {
      return localVarFp
        .deployContractVersion(contract, version, postMethodArgs, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the given contract.
     * @summary Get a contract
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContract(contract: string, options?: RawAxiosRequestConfig): AxiosPromise<GetContract200Response> {
      return localVarFp.getContract(contract, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a specific contract version.
     * @summary Get a contract version
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractVersion(
      contract: string,
      version: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetContract200Response> {
      return localVarFp.getContractVersion(contract, version, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns all the versions of a contract.
     * @summary Get all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractVersions(
      contract: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetContractVersions200Response> {
      return localVarFp.getContractVersions(contract, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns the event monitor status for a given address and contract.
     * @summary Get event monitor status
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventMonitorStatus(
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetEventMonitorStatus200Response> {
      return localVarFp
        .getEventMonitorStatus(chain, addressOrAlias, contract, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the type conversion options for a given contract and event signature.
     * @summary Get event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventTypeConversions(
      contract: string,
      version: string,
      event: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetEventTypeConversions200Response> {
      return localVarFp
        .getEventTypeConversions(contract, version, event, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the type conversion options for a given contract and function signature.
     * @summary Get function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctionTypeConversions(
      contract: string,
      version: string,
      method: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetFunctionTypeConversions200Response> {
      return localVarFp
        .getFunctionTypeConversions(contract, version, method, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Links an address to a contract.
     * @summary Link address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {LinkAddressContractRequest} linkAddressContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAddressContract(
      chain: ChainName,
      addressOrAlias: string,
      linkAddressContractRequest: LinkAddressContractRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SetAddress201Response> {
      return localVarFp
        .linkAddressContract(chain, addressOrAlias, linkAddressContractRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of the versions of a contract.
     * @summary List all contract versions
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContractVersions(
      contract: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListContractVersions200Response> {
      return localVarFp.listContractVersions(contract, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of contracts.
     * @summary List contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContracts(options?: RawAxiosRequestConfig): AxiosPromise<ListContracts200Response> {
      return localVarFp.listContracts(options).then((request) => request(axios, basePath));
    },
    /**
     * Sets the type conversion options for a given contract and event signature.
     * @summary Set event type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} event Contract Event.
     * @param {ContractEventOptions} contractEventOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEventTypeConversions(
      contract: string,
      version: string,
      event: string,
      contractEventOptions: ContractEventOptions,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setEventTypeConversions(contract, version, event, contractEventOptions, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sets the type conversion options for a given contract and function signature.
     * @summary Set function type conversions
     * @param {string} contract
     * @param {string} version Contract Version.
     * @param {string} method Contract function.
     * @param {ContractMethodOptions} contractMethodOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFunctionTypeConversions(
      contract: string,
      version: string,
      method: string,
      contractMethodOptions: ContractMethodOptions,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setFunctionTypeConversions(contract, version, method, contractMethodOptions, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Unlinks an address from a contract.
     * @summary Unlink address and contract
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} addressOrAlias An address or the alias of an address.
     * @param {string} contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlinkAddressContract(
      chain: ChainName,
      addressOrAlias: string,
      contract: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SetAddress201Response> {
      return localVarFp
        .unlinkAddressContract(chain, addressOrAlias, contract, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * ContractsApi - interface
 */
export interface ContractsApiInterface {
  /**
   * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
   * @summary Call a contract function
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {string} contract
   * @param {string} method Contract function.
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  callContractFunction(
    chain: ChainName,
    addressOrAlias: string,
    contract: string,
    method: string,
    postMethodArgs: PostMethodArgs,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<CallContractFunction200Response>;

  /**
   * Adds a contract.
   * @summary Create a contract
   * @param {string} contract
   * @param {BaseContract} baseContract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  createContract(
    contract: string,
    baseContract: BaseContract,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetContract200Response>;

  /**
   * Adds multiple contracts.
   * @summary Create multiple contracts
   * @param {Array<BaseContract>} baseContract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  createContracts(baseContract: Array<BaseContract>, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Deletes a contract and all its versions.
   * @summary Delete a contract
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  deleteContract(contract: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Deletes a specific contract version.
   * @summary Delete a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  deleteContractVersion(contract: string, version: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Returns a transaction to deploy the given contract to the blockchain.
   * @summary Deploy a contract
   * @param {string} contract
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  deployContract(
    contract: string,
    postMethodArgs: PostMethodArgs,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<DeployContract200Response>;

  /**
   * Returns a transaction to deploy the given contract version to the blockchain.
   * @summary Deploy a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  deployContractVersion(
    contract: string,
    version: string,
    postMethodArgs: PostMethodArgs,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<DeployContract200Response>;

  /**
   * Returns the given contract.
   * @summary Get a contract
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getContract(contract: string, options?: RawAxiosRequestConfig): AxiosPromise<GetContract200Response>;

  /**
   * Returns a specific contract version.
   * @summary Get a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getContractVersion(
    contract: string,
    version: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetContract200Response>;

  /**
   * Returns all the versions of a contract.
   * @summary Get all contract versions
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getContractVersions(contract: string, options?: RawAxiosRequestConfig): AxiosPromise<GetContractVersions200Response>;

  /**
   * Returns the event monitor status for a given address and contract.
   * @summary Get event monitor status
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getEventMonitorStatus(
    chain: ChainName,
    addressOrAlias: string,
    contract: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetEventMonitorStatus200Response>;

  /**
   * Returns the type conversion options for a given contract and event signature.
   * @summary Get event type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} event Contract Event.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getEventTypeConversions(
    contract: string,
    version: string,
    event: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetEventTypeConversions200Response>;

  /**
   * Returns the type conversion options for a given contract and function signature.
   * @summary Get function type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} method Contract function.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getFunctionTypeConversions(
    contract: string,
    version: string,
    method: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetFunctionTypeConversions200Response>;

  /**
   * Links an address to a contract.
   * @summary Link address and contract
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {LinkAddressContractRequest} linkAddressContractRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  linkAddressContract(
    chain: ChainName,
    addressOrAlias: string,
    linkAddressContractRequest: LinkAddressContractRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<SetAddress201Response>;

  /**
   * Returns a list of the versions of a contract.
   * @summary List all contract versions
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listContractVersions(
    contract: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ListContractVersions200Response>;

  /**
   * Returns a list of contracts.
   * @summary List contracts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listContracts(options?: RawAxiosRequestConfig): AxiosPromise<ListContracts200Response>;

  /**
   * Sets the type conversion options for a given contract and event signature.
   * @summary Set event type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} event Contract Event.
   * @param {ContractEventOptions} contractEventOptions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  setEventTypeConversions(
    contract: string,
    version: string,
    event: string,
    contractEventOptions: ContractEventOptions,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Sets the type conversion options for a given contract and function signature.
   * @summary Set function type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} method Contract function.
   * @param {ContractMethodOptions} contractMethodOptions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  setFunctionTypeConversions(
    contract: string,
    version: string,
    method: string,
    contractMethodOptions: ContractMethodOptions,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Unlinks an address from a contract.
   * @summary Unlink address and contract
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  unlinkAddressContract(
    chain: ChainName,
    addressOrAlias: string,
    contract: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<SetAddress201Response>;
}

/**
 * ContractsApi - object-oriented interface
 */
export class ContractsApi extends BaseAPI implements ContractsApiInterface {
  /**
   * Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.
   * @summary Call a contract function
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {string} contract
   * @param {string} method Contract function.
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public callContractFunction(
    chain: ChainName,
    addressOrAlias: string,
    contract: string,
    method: string,
    postMethodArgs: PostMethodArgs,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .callContractFunction(chain, addressOrAlias, contract, method, postMethodArgs, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a contract.
   * @summary Create a contract
   * @param {string} contract
   * @param {BaseContract} baseContract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createContract(contract: string, baseContract: BaseContract, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .createContract(contract, baseContract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds multiple contracts.
   * @summary Create multiple contracts
   * @param {Array<BaseContract>} baseContract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createContracts(baseContract: Array<BaseContract>, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .createContracts(baseContract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a contract and all its versions.
   * @summary Delete a contract
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteContract(contract: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .deleteContract(contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a specific contract version.
   * @summary Delete a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteContractVersion(contract: string, version: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .deleteContractVersion(contract, version, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transaction to deploy the given contract to the blockchain.
   * @summary Deploy a contract
   * @param {string} contract
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deployContract(contract: string, postMethodArgs: PostMethodArgs, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .deployContract(contract, postMethodArgs, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a transaction to deploy the given contract version to the blockchain.
   * @summary Deploy a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {PostMethodArgs} postMethodArgs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deployContractVersion(
    contract: string,
    version: string,
    postMethodArgs: PostMethodArgs,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .deployContractVersion(contract, version, postMethodArgs, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the given contract.
   * @summary Get a contract
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getContract(contract: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getContract(contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a specific contract version.
   * @summary Get a contract version
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getContractVersion(contract: string, version: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getContractVersion(contract, version, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the versions of a contract.
   * @summary Get all contract versions
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getContractVersions(contract: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getContractVersions(contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the event monitor status for a given address and contract.
   * @summary Get event monitor status
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getEventMonitorStatus(
    chain: ChainName,
    addressOrAlias: string,
    contract: string,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getEventMonitorStatus(chain, addressOrAlias, contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the type conversion options for a given contract and event signature.
   * @summary Get event type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} event Contract Event.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getEventTypeConversions(contract: string, version: string, event: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getEventTypeConversions(contract, version, event, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the type conversion options for a given contract and function signature.
   * @summary Get function type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} method Contract function.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getFunctionTypeConversions(
    contract: string,
    version: string,
    method: string,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .getFunctionTypeConversions(contract, version, method, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Links an address to a contract.
   * @summary Link address and contract
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {LinkAddressContractRequest} linkAddressContractRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public linkAddressContract(
    chain: ChainName,
    addressOrAlias: string,
    linkAddressContractRequest: LinkAddressContractRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .linkAddressContract(chain, addressOrAlias, linkAddressContractRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of the versions of a contract.
   * @summary List all contract versions
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listContractVersions(contract: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .listContractVersions(contract, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of contracts.
   * @summary List contracts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listContracts(options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .listContracts(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the type conversion options for a given contract and event signature.
   * @summary Set event type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} event Contract Event.
   * @param {ContractEventOptions} contractEventOptions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public setEventTypeConversions(
    contract: string,
    version: string,
    event: string,
    contractEventOptions: ContractEventOptions,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .setEventTypeConversions(contract, version, event, contractEventOptions, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the type conversion options for a given contract and function signature.
   * @summary Set function type conversions
   * @param {string} contract
   * @param {string} version Contract Version.
   * @param {string} method Contract function.
   * @param {ContractMethodOptions} contractMethodOptions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public setFunctionTypeConversions(
    contract: string,
    version: string,
    method: string,
    contractMethodOptions: ContractMethodOptions,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .setFunctionTypeConversions(contract, version, method, contractMethodOptions, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Unlinks an address from a contract.
   * @summary Unlink address and contract
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} addressOrAlias An address or the alias of an address.
   * @param {string} contract
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public unlinkAddressContract(
    chain: ChainName,
    addressOrAlias: string,
    contract: string,
    options?: RawAxiosRequestConfig
  ) {
    return ContractsApiFp(this.configuration)
      .unlinkAddressContract(chain, addressOrAlias, contract, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EventQueriesApi - axios parameter creator
 */
export const EventQueriesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns the record count of the given saved event query.
     * @summary Count event query records
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countEventQueryRecords: async (eventQuery: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('countEventQueryRecords', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}/count`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the given saved event query.
     * @summary Delete event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventQuery: async (eventQuery: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('deleteEventQuery', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Executes an arbitrary event query.
     * @summary Execute arbitrary event query
     * @param {EventQuery} eventQuery
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeArbitraryEventQuery: async (
      eventQuery: EventQuery,
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('executeArbitraryEventQuery', 'eventQuery', eventQuery);
      const localVarPath = `/queries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(eventQuery, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Executes the given saved event query.
     * @summary Execute event query
     * @param {string} eventQuery An event query label.
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeEventQuery: async (
      eventQuery: string,
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('executeEventQuery', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}/results`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the given saved event query.
     * @summary Get event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventQuery: async (eventQuery: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('getEventQuery', 'eventQuery', eventQuery);
      const localVarPath = `/queries/{event_query}`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of saved event queries.
     * @summary List event queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventQueries: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/queries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates or updates the given saved event query.
     * @summary Create or update event query
     * @param {string} eventQuery An event query label.
     * @param {EventQuery} eventQuery2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEventQuery: async (
      eventQuery: string,
      eventQuery2: EventQuery,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventQuery' is not null or undefined
      assertParamExists('setEventQuery', 'eventQuery', eventQuery);
      // verify required parameter 'eventQuery2' is not null or undefined
      assertParamExists('setEventQuery', 'eventQuery2', eventQuery2);
      const localVarPath = `/queries/{event_query}`.replace(
        `{${'event_query'}}`,
        encodeURIComponent(String(eventQuery))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(eventQuery2, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * EventQueriesApi - functional programming interface
 */
export const EventQueriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EventQueriesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the record count of the given saved event query.
     * @summary Count event query records
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countEventQueryRecords(
      eventQuery: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountEventQueryRecords200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countEventQueryRecords(eventQuery, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.countEventQueryRecords']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Deletes the given saved event query.
     * @summary Delete event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEventQuery(
      eventQuery: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventQuery(eventQuery, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.deleteEventQuery']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Executes an arbitrary event query.
     * @summary Execute arbitrary event query
     * @param {EventQuery} eventQuery
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeArbitraryEventQuery(
      eventQuery: EventQuery,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteArbitraryEventQuery200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeArbitraryEventQuery(
        eventQuery,
        offset,
        limit,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.executeArbitraryEventQuery']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Executes the given saved event query.
     * @summary Execute event query
     * @param {string} eventQuery An event query label.
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeEventQuery(
      eventQuery: string,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteArbitraryEventQuery200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeEventQuery(eventQuery, offset, limit, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.executeEventQuery']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the given saved event query.
     * @summary Get event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventQuery(
      eventQuery: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventQuery200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventQuery(eventQuery, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.getEventQuery']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of saved event queries.
     * @summary List event queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEventQueries(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEventQueries200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listEventQueries(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.listEventQueries']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates or updates the given saved event query.
     * @summary Create or update event query
     * @param {string} eventQuery An event query label.
     * @param {EventQuery} eventQuery2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setEventQuery(
      eventQuery: string,
      eventQuery2: EventQuery,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setEventQuery(eventQuery, eventQuery2, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventQueriesApi.setEventQuery']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * EventQueriesApi - factory interface
 */
export const EventQueriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EventQueriesApiFp(configuration);
  return {
    /**
     * Returns the record count of the given saved event query.
     * @summary Count event query records
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countEventQueryRecords(
      eventQuery: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CountEventQueryRecords200Response> {
      return localVarFp.countEventQueryRecords(eventQuery, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the given saved event query.
     * @summary Delete event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventQuery(eventQuery: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.deleteEventQuery(eventQuery, options).then((request) => request(axios, basePath));
    },
    /**
     * Executes an arbitrary event query.
     * @summary Execute arbitrary event query
     * @param {EventQuery} eventQuery
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeArbitraryEventQuery(
      eventQuery: EventQuery,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ExecuteArbitraryEventQuery200Response> {
      return localVarFp
        .executeArbitraryEventQuery(eventQuery, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Executes the given saved event query.
     * @summary Execute event query
     * @param {string} eventQuery An event query label.
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeEventQuery(
      eventQuery: string,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ExecuteArbitraryEventQuery200Response> {
      return localVarFp
        .executeEventQuery(eventQuery, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the given saved event query.
     * @summary Get event query
     * @param {string} eventQuery An event query label.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventQuery(eventQuery: string, options?: RawAxiosRequestConfig): AxiosPromise<GetEventQuery200Response> {
      return localVarFp.getEventQuery(eventQuery, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of saved event queries.
     * @summary List event queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEventQueries(options?: RawAxiosRequestConfig): AxiosPromise<ListEventQueries200Response> {
      return localVarFp.listEventQueries(options).then((request) => request(axios, basePath));
    },
    /**
     * Creates or updates the given saved event query.
     * @summary Create or update event query
     * @param {string} eventQuery An event query label.
     * @param {EventQuery} eventQuery2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEventQuery(
      eventQuery: string,
      eventQuery2: EventQuery,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp.setEventQuery(eventQuery, eventQuery2, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * EventQueriesApi - interface
 */
export interface EventQueriesApiInterface {
  /**
   * Returns the record count of the given saved event query.
   * @summary Count event query records
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  countEventQueryRecords(
    eventQuery: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<CountEventQueryRecords200Response>;

  /**
   * Deletes the given saved event query.
   * @summary Delete event query
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  deleteEventQuery(eventQuery: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Executes an arbitrary event query.
   * @summary Execute arbitrary event query
   * @param {EventQuery} eventQuery
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  executeArbitraryEventQuery(
    eventQuery: EventQuery,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ExecuteArbitraryEventQuery200Response>;

  /**
   * Executes the given saved event query.
   * @summary Execute event query
   * @param {string} eventQuery An event query label.
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  executeEventQuery(
    eventQuery: string,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ExecuteArbitraryEventQuery200Response>;

  /**
   * Returns the given saved event query.
   * @summary Get event query
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getEventQuery(eventQuery: string, options?: RawAxiosRequestConfig): AxiosPromise<GetEventQuery200Response>;

  /**
   * Returns a list of saved event queries.
   * @summary List event queries
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listEventQueries(options?: RawAxiosRequestConfig): AxiosPromise<ListEventQueries200Response>;

  /**
   * Creates or updates the given saved event query.
   * @summary Create or update event query
   * @param {string} eventQuery An event query label.
   * @param {EventQuery} eventQuery2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  setEventQuery(
    eventQuery: string,
    eventQuery2: EventQuery,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;
}

/**
 * EventQueriesApi - object-oriented interface
 */
export class EventQueriesApi extends BaseAPI implements EventQueriesApiInterface {
  /**
   * Returns the record count of the given saved event query.
   * @summary Count event query records
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public countEventQueryRecords(eventQuery: string, options?: RawAxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .countEventQueryRecords(eventQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the given saved event query.
   * @summary Delete event query
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteEventQuery(eventQuery: string, options?: RawAxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .deleteEventQuery(eventQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Executes an arbitrary event query.
   * @summary Execute arbitrary event query
   * @param {EventQuery} eventQuery
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public executeArbitraryEventQuery(
    eventQuery: EventQuery,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig
  ) {
    return EventQueriesApiFp(this.configuration)
      .executeArbitraryEventQuery(eventQuery, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Executes the given saved event query.
   * @summary Execute event query
   * @param {string} eventQuery An event query label.
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public executeEventQuery(eventQuery: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .executeEventQuery(eventQuery, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the given saved event query.
   * @summary Get event query
   * @param {string} eventQuery An event query label.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getEventQuery(eventQuery: string, options?: RawAxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .getEventQuery(eventQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of saved event queries.
   * @summary List event queries
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listEventQueries(options?: RawAxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .listEventQueries(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates or updates the given saved event query.
   * @summary Create or update event query
   * @param {string} eventQuery An event query label.
   * @param {EventQuery} eventQuery2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public setEventQuery(eventQuery: string, eventQuery2: EventQuery, options?: RawAxiosRequestConfig) {
    return EventQueriesApiFp(this.configuration)
      .setEventQuery(eventQuery, eventQuery2, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EventsApi - axios parameter creator
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Gets the number of events stored in the database.
     * @summary Get event count
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventCount: async (
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/events/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (blockHash !== undefined) {
        localVarQueryParameter['block_hash'] = blockHash;
      }

      if (blockNumber !== undefined) {
        localVarQueryParameter['block_number'] = blockNumber;
      }

      if (txIndexInBlock !== undefined) {
        localVarQueryParameter['tx_index_in_block'] = txIndexInBlock;
      }

      if (eventIndexInLog !== undefined) {
        localVarQueryParameter['event_index_in_log'] = eventIndexInLog;
      }

      if (txHash !== undefined) {
        localVarQueryParameter['tx_hash'] = txHash;
      }

      if (fromConstructor !== undefined) {
        localVarQueryParameter['from_constructor'] = fromConstructor;
      }

      if (chain !== undefined) {
        localVarQueryParameter['chain'] = chain;
      }

      if (contractAddress !== undefined) {
        localVarQueryParameter['contract_address'] = contractAddress;
      }

      if (contractLabel !== undefined) {
        localVarQueryParameter['contract_label'] = contractLabel;
      }

      if (eventSignature !== undefined) {
        localVarQueryParameter['event_signature'] = eventSignature;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all events stored in the database.
     * @summary List events
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEvents: async (
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/events`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (blockHash !== undefined) {
        localVarQueryParameter['block_hash'] = blockHash;
      }

      if (blockNumber !== undefined) {
        localVarQueryParameter['block_number'] = blockNumber;
      }

      if (txIndexInBlock !== undefined) {
        localVarQueryParameter['tx_index_in_block'] = txIndexInBlock;
      }

      if (eventIndexInLog !== undefined) {
        localVarQueryParameter['event_index_in_log'] = eventIndexInLog;
      }

      if (txHash !== undefined) {
        localVarQueryParameter['tx_hash'] = txHash;
      }

      if (fromConstructor !== undefined) {
        localVarQueryParameter['from_constructor'] = fromConstructor;
      }

      if (chain !== undefined) {
        localVarQueryParameter['chain'] = chain;
      }

      if (contractAddress !== undefined) {
        localVarQueryParameter['contract_address'] = contractAddress;
      }

      if (contractLabel !== undefined) {
        localVarQueryParameter['contract_label'] = contractLabel;
      }

      if (eventSignature !== undefined) {
        localVarQueryParameter['event_signature'] = eventSignature;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * EventsApi - functional programming interface
 */
export const EventsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration);
  return {
    /**
     * Gets the number of events stored in the database.
     * @summary Get event count
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventCount(
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventCount200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventCount(
        blockHash,
        blockNumber,
        txIndexInBlock,
        eventIndexInLog,
        txHash,
        fromConstructor,
        chain,
        contractAddress,
        contractLabel,
        eventSignature,
        limit,
        offset,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventsApi.getEventCount']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all events stored in the database.
     * @summary List events
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEvents(
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEvents200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listEvents(
        blockHash,
        blockNumber,
        txIndexInBlock,
        eventIndexInLog,
        txHash,
        fromConstructor,
        chain,
        contractAddress,
        contractLabel,
        eventSignature,
        limit,
        offset,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventsApi.listEvents']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * EventsApi - factory interface
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = EventsApiFp(configuration);
  return {
    /**
     * Gets the number of events stored in the database.
     * @summary Get event count
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventCount(
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetEventCount200Response> {
      return localVarFp
        .getEventCount(
          blockHash,
          blockNumber,
          txIndexInBlock,
          eventIndexInLog,
          txHash,
          fromConstructor,
          chain,
          contractAddress,
          contractLabel,
          eventSignature,
          limit,
          offset,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all events stored in the database.
     * @summary List events
     * @param {string} [blockHash] Filter events by a block hash.
     * @param {number} [blockNumber] Filter events by a block number.
     * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
     * @param {number} [eventIndexInLog] Filter events by index in the log.
     * @param {string} [txHash] Filter events by a transaction hash.
     * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
     * @param {ChainName} [chain] Filter events by a chain name.
     * @param {string} [contractAddress] Filter events by a contract address.
     * @param {string} [contractLabel] Filter events by a contract label.
     * @param {string} [eventSignature] Filter events by the signature.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEvents(
      blockHash?: string,
      blockNumber?: number,
      txIndexInBlock?: number,
      eventIndexInLog?: number,
      txHash?: string,
      fromConstructor?: boolean,
      chain?: ChainName,
      contractAddress?: string,
      contractLabel?: string,
      eventSignature?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListEvents200Response> {
      return localVarFp
        .listEvents(
          blockHash,
          blockNumber,
          txIndexInBlock,
          eventIndexInLog,
          txHash,
          fromConstructor,
          chain,
          contractAddress,
          contractLabel,
          eventSignature,
          limit,
          offset,
          options
        )
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * EventsApi - interface
 */
export interface EventsApiInterface {
  /**
   * Gets the number of events stored in the database.
   * @summary Get event count
   * @param {string} [blockHash] Filter events by a block hash.
   * @param {number} [blockNumber] Filter events by a block number.
   * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
   * @param {number} [eventIndexInLog] Filter events by index in the log.
   * @param {string} [txHash] Filter events by a transaction hash.
   * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
   * @param {ChainName} [chain] Filter events by a chain name.
   * @param {string} [contractAddress] Filter events by a contract address.
   * @param {string} [contractLabel] Filter events by a contract label.
   * @param {string} [eventSignature] Filter events by the signature.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getEventCount(
    blockHash?: string,
    blockNumber?: number,
    txIndexInBlock?: number,
    eventIndexInLog?: number,
    txHash?: string,
    fromConstructor?: boolean,
    chain?: ChainName,
    contractAddress?: string,
    contractLabel?: string,
    eventSignature?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<GetEventCount200Response>;

  /**
   * Returns all events stored in the database.
   * @summary List events
   * @param {string} [blockHash] Filter events by a block hash.
   * @param {number} [blockNumber] Filter events by a block number.
   * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
   * @param {number} [eventIndexInLog] Filter events by index in the log.
   * @param {string} [txHash] Filter events by a transaction hash.
   * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
   * @param {ChainName} [chain] Filter events by a chain name.
   * @param {string} [contractAddress] Filter events by a contract address.
   * @param {string} [contractLabel] Filter events by a contract label.
   * @param {string} [eventSignature] Filter events by the signature.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listEvents(
    blockHash?: string,
    blockNumber?: number,
    txIndexInBlock?: number,
    eventIndexInLog?: number,
    txHash?: string,
    fromConstructor?: boolean,
    chain?: ChainName,
    contractAddress?: string,
    contractLabel?: string,
    eventSignature?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ListEvents200Response>;
}

/**
 * EventsApi - object-oriented interface
 */
export class EventsApi extends BaseAPI implements EventsApiInterface {
  /**
   * Gets the number of events stored in the database.
   * @summary Get event count
   * @param {string} [blockHash] Filter events by a block hash.
   * @param {number} [blockNumber] Filter events by a block number.
   * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
   * @param {number} [eventIndexInLog] Filter events by index in the log.
   * @param {string} [txHash] Filter events by a transaction hash.
   * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
   * @param {ChainName} [chain] Filter events by a chain name.
   * @param {string} [contractAddress] Filter events by a contract address.
   * @param {string} [contractLabel] Filter events by a contract label.
   * @param {string} [eventSignature] Filter events by the signature.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getEventCount(
    blockHash?: string,
    blockNumber?: number,
    txIndexInBlock?: number,
    eventIndexInLog?: number,
    txHash?: string,
    fromConstructor?: boolean,
    chain?: ChainName,
    contractAddress?: string,
    contractLabel?: string,
    eventSignature?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ) {
    return EventsApiFp(this.configuration)
      .getEventCount(
        blockHash,
        blockNumber,
        txIndexInBlock,
        eventIndexInLog,
        txHash,
        fromConstructor,
        chain,
        contractAddress,
        contractLabel,
        eventSignature,
        limit,
        offset,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all events stored in the database.
   * @summary List events
   * @param {string} [blockHash] Filter events by a block hash.
   * @param {number} [blockNumber] Filter events by a block number.
   * @param {number} [txIndexInBlock] Filter events by a transaction\&#39;s index in the block.
   * @param {number} [eventIndexInLog] Filter events by index in the log.
   * @param {string} [txHash] Filter events by a transaction hash.
   * @param {boolean} [fromConstructor] Filter events by whether they were emitted from the constructor function.
   * @param {ChainName} [chain] Filter events by a chain name.
   * @param {string} [contractAddress] Filter events by a contract address.
   * @param {string} [contractLabel] Filter events by a contract label.
   * @param {string} [eventSignature] Filter events by the signature.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listEvents(
    blockHash?: string,
    blockNumber?: number,
    txIndexInBlock?: number,
    eventIndexInLog?: number,
    txHash?: string,
    fromConstructor?: boolean,
    chain?: ChainName,
    contractAddress?: string,
    contractLabel?: string,
    eventSignature?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ) {
    return EventsApiFp(this.configuration)
      .listEvents(
        blockHash,
        blockNumber,
        txIndexInBlock,
        eventIndexInLog,
        txHash,
        fromConstructor,
        chain,
        contractAddress,
        contractLabel,
        eventSignature,
        limit,
        offset,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HsmApi - axios parameter creator
 */
export const HsmApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Adds a new Azure account configuration.
     * @summary Add HSM config
     * @param {BaseAzureAccount} baseAzureAccount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addHsmConfig: async (
      baseAzureAccount: BaseAzureAccount,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'baseAzureAccount' is not null or undefined
      assertParamExists('addHsmConfig', 'baseAzureAccount', baseAzureAccount);
      const localVarPath = `/hsm/config`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseAzureAccount, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Adds an existing key configuration.
     * @summary Add HSM key
     * @param {AddKey} addKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addHsmKey: async (addKey: AddKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'addKey' is not null or undefined
      assertParamExists('addHsmKey', 'addKey', addKey);
      const localVarPath = `/hsm/key`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(addKey, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new key in the Azure KeyVault.
     * @summary Create HSM key
     * @param {CreateKey} createKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHsmKey: async (createKey: CreateKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createKey' is not null or undefined
      assertParamExists('createHsmKey', 'createKey', createKey);
      const localVarPath = `/hsm/key/new`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createKey, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of HSM configs and their associated wallets.
     * @summary List HSM configs and wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHsm: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/hsm`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of HSM wallets.
     * @summary List HSM wallets
     * @param {string} [keyName] Filter wallets by a key name.
     * @param {string} [keyVersion] Filter wallets by a key version.
     * @param {string} [vaultName] Filter wallets by a vault name.
     * @param {string} [baseGroupName] Filter wallets by a base group name.
     * @param {string} [clientId] Filter wallets by a client ID.
     * @param {string} [publicAddress] Filter wallets by a public address.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHsmWallets: async (
      keyName?: string,
      keyVersion?: string,
      vaultName?: string,
      baseGroupName?: string,
      clientId?: string,
      publicAddress?: string,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/hsm/wallets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (keyName !== undefined) {
        localVarQueryParameter['key_name'] = keyName;
      }

      if (keyVersion !== undefined) {
        localVarQueryParameter['key_version'] = keyVersion;
      }

      if (vaultName !== undefined) {
        localVarQueryParameter['vault_name'] = vaultName;
      }

      if (baseGroupName !== undefined) {
        localVarQueryParameter['base_group_name'] = baseGroupName;
      }

      if (clientId !== undefined) {
        localVarQueryParameter['client_id'] = clientId;
      }

      if (publicAddress !== undefined) {
        localVarQueryParameter['public_address'] = publicAddress;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes the specified Azure account configuration and its associated keys.
     * @summary Remove HSM config
     * @param {string} clientId The HSM client ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeHsmConfig: async (clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('removeHsmConfig', 'clientId', clientId);
      const localVarPath = `/hsm/config/{client_id}`.replace(`{${'client_id'}}`, encodeURIComponent(String(clientId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Removes the specified key configuration.
     * @summary Remove HSM key
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeHsmKey: async (walletAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('removeHsmKey', 'walletAddress', walletAddress);
      const localVarPath = `/hsm/key/{wallet_address}`.replace(
        `{${'wallet_address'}}`,
        encodeURIComponent(String(walletAddress))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
     * @summary Set local nonce
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {SetNonceRequest} setNonceRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLocalNonce: async (
      chain: ChainName,
      walletAddress: string,
      setNonceRequest: SetNonceRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('setLocalNonce', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('setLocalNonce', 'walletAddress', walletAddress);
      // verify required parameter 'setNonceRequest' is not null or undefined
      assertParamExists('setLocalNonce', 'setNonceRequest', setNonceRequest);
      const localVarPath = `/chains/{chain}/hsm/nonce/{wallet_address}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(setNonceRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Signs and submits the given transaction using an HSM address.
     * @summary Sign and submit transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {CloudWalletTXToSign} cloudWalletTXToSign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signAndSubmitTransaction: async (
      chain: ChainName,
      cloudWalletTXToSign: CloudWalletTXToSign,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('signAndSubmitTransaction', 'chain', chain);
      // verify required parameter 'cloudWalletTXToSign' is not null or undefined
      assertParamExists('signAndSubmitTransaction', 'cloudWalletTXToSign', cloudWalletTXToSign);
      const localVarPath = `/chains/{chain}/hsm/submit`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cloudWalletTXToSign, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Signs the given data using the given HSM address.
     * @summary Sign data
     * @param {ChainName} chain The blockchain chain label.
     * @param {HSMSignRequest} hSMSignRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signData: async (
      chain: ChainName,
      hSMSignRequest: HSMSignRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('signData', 'chain', chain);
      // verify required parameter 'hSMSignRequest' is not null or undefined
      assertParamExists('signData', 'hSMSignRequest', hSMSignRequest);
      const localVarPath = `/chains/{chain}/hsm/sign`.replace(`{${'chain'}}`, encodeURIComponent(String(chain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(hSMSignRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * HsmApi - functional programming interface
 */
export const HsmApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HsmApiAxiosParamCreator(configuration);
  return {
    /**
     * Adds a new Azure account configuration.
     * @summary Add HSM config
     * @param {BaseAzureAccount} baseAzureAccount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addHsmConfig(
      baseAzureAccount: BaseAzureAccount,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addHsmConfig(baseAzureAccount, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.addHsmConfig']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Adds an existing key configuration.
     * @summary Add HSM key
     * @param {AddKey} addKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addHsmKey(
      addKey: AddKey,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addHsmKey(addKey, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.addHsmKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates a new key in the Azure KeyVault.
     * @summary Create HSM key
     * @param {CreateKey} createKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createHsmKey(
      createKey: CreateKey,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateHsmKey200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createHsmKey(createKey, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.createHsmKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of HSM configs and their associated wallets.
     * @summary List HSM configs and wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listHsm(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListHsm200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listHsm(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap['HsmApi.listHsm']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a list of HSM wallets.
     * @summary List HSM wallets
     * @param {string} [keyName] Filter wallets by a key name.
     * @param {string} [keyVersion] Filter wallets by a key version.
     * @param {string} [vaultName] Filter wallets by a vault name.
     * @param {string} [baseGroupName] Filter wallets by a base group name.
     * @param {string} [clientId] Filter wallets by a client ID.
     * @param {string} [publicAddress] Filter wallets by a public address.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listHsmWallets(
      keyName?: string,
      keyVersion?: string,
      vaultName?: string,
      baseGroupName?: string,
      clientId?: string,
      publicAddress?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListHsmWallets200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listHsmWallets(
        keyName,
        keyVersion,
        vaultName,
        baseGroupName,
        clientId,
        publicAddress,
        limit,
        offset,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.listHsmWallets']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes the specified Azure account configuration and its associated keys.
     * @summary Remove HSM config
     * @param {string} clientId The HSM client ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeHsmConfig(
      clientId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeHsmConfig(clientId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.removeHsmConfig']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Removes the specified key configuration.
     * @summary Remove HSM key
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeHsmKey(
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeHsmKey(walletAddress, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.removeHsmKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
     * @summary Set local nonce
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {SetNonceRequest} setNonceRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setLocalNonce(
      chain: ChainName,
      walletAddress: string,
      setNonceRequest: SetNonceRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setLocalNonce(
        chain,
        walletAddress,
        setNonceRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.setLocalNonce']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Signs and submits the given transaction using an HSM address.
     * @summary Sign and submit transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {CloudWalletTXToSign} cloudWalletTXToSign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signAndSubmitTransaction(
      chain: ChainName,
      cloudWalletTXToSign: CloudWalletTXToSign,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferEth200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signAndSubmitTransaction(
        chain,
        cloudWalletTXToSign,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.signAndSubmitTransaction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Signs the given data using the given HSM address.
     * @summary Sign data
     * @param {ChainName} chain The blockchain chain label.
     * @param {HSMSignRequest} hSMSignRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signData(
      chain: ChainName,
      hSMSignRequest: HSMSignRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignData200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signData(chain, hSMSignRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HsmApi.signData']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * HsmApi - factory interface
 */
export const HsmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = HsmApiFp(configuration);
  return {
    /**
     * Adds a new Azure account configuration.
     * @summary Add HSM config
     * @param {BaseAzureAccount} baseAzureAccount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addHsmConfig(baseAzureAccount: BaseAzureAccount, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.addHsmConfig(baseAzureAccount, options).then((request) => request(axios, basePath));
    },
    /**
     * Adds an existing key configuration.
     * @summary Add HSM key
     * @param {AddKey} addKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addHsmKey(addKey: AddKey, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.addHsmKey(addKey, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new key in the Azure KeyVault.
     * @summary Create HSM key
     * @param {CreateKey} createKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHsmKey(createKey: CreateKey, options?: RawAxiosRequestConfig): AxiosPromise<CreateHsmKey200Response> {
      return localVarFp.createHsmKey(createKey, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of HSM configs and their associated wallets.
     * @summary List HSM configs and wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHsm(options?: RawAxiosRequestConfig): AxiosPromise<ListHsm200Response> {
      return localVarFp.listHsm(options).then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of HSM wallets.
     * @summary List HSM wallets
     * @param {string} [keyName] Filter wallets by a key name.
     * @param {string} [keyVersion] Filter wallets by a key version.
     * @param {string} [vaultName] Filter wallets by a vault name.
     * @param {string} [baseGroupName] Filter wallets by a base group name.
     * @param {string} [clientId] Filter wallets by a client ID.
     * @param {string} [publicAddress] Filter wallets by a public address.
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listHsmWallets(
      keyName?: string,
      keyVersion?: string,
      vaultName?: string,
      baseGroupName?: string,
      clientId?: string,
      publicAddress?: string,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListHsmWallets200Response> {
      return localVarFp
        .listHsmWallets(keyName, keyVersion, vaultName, baseGroupName, clientId, publicAddress, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Removes the specified Azure account configuration and its associated keys.
     * @summary Remove HSM config
     * @param {string} clientId The HSM client ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeHsmConfig(clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.removeHsmConfig(clientId, options).then((request) => request(axios, basePath));
    },
    /**
     * Removes the specified key configuration.
     * @summary Remove HSM key
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeHsmKey(walletAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.removeHsmKey(walletAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
     * @summary Set local nonce
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {SetNonceRequest} setNonceRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLocalNonce(
      chain: ChainName,
      walletAddress: string,
      setNonceRequest: SetNonceRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BaseResponse> {
      return localVarFp
        .setLocalNonce(chain, walletAddress, setNonceRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Signs and submits the given transaction using an HSM address.
     * @summary Sign and submit transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {CloudWalletTXToSign} cloudWalletTXToSign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signAndSubmitTransaction(
      chain: ChainName,
      cloudWalletTXToSign: CloudWalletTXToSign,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TransferEth200Response> {
      return localVarFp
        .signAndSubmitTransaction(chain, cloudWalletTXToSign, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Signs the given data using the given HSM address.
     * @summary Sign data
     * @param {ChainName} chain The blockchain chain label.
     * @param {HSMSignRequest} hSMSignRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signData(
      chain: ChainName,
      hSMSignRequest: HSMSignRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SignData200Response> {
      return localVarFp.signData(chain, hSMSignRequest, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * HsmApi - interface
 */
export interface HsmApiInterface {
  /**
   * Adds a new Azure account configuration.
   * @summary Add HSM config
   * @param {BaseAzureAccount} baseAzureAccount
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  addHsmConfig(baseAzureAccount: BaseAzureAccount, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Adds an existing key configuration.
   * @summary Add HSM key
   * @param {AddKey} addKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  addHsmKey(addKey: AddKey, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Creates a new key in the Azure KeyVault.
   * @summary Create HSM key
   * @param {CreateKey} createKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  createHsmKey(createKey: CreateKey, options?: RawAxiosRequestConfig): AxiosPromise<CreateHsmKey200Response>;

  /**
   * Returns a list of HSM configs and their associated wallets.
   * @summary List HSM configs and wallets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listHsm(options?: RawAxiosRequestConfig): AxiosPromise<ListHsm200Response>;

  /**
   * Returns a list of HSM wallets.
   * @summary List HSM wallets
   * @param {string} [keyName] Filter wallets by a key name.
   * @param {string} [keyVersion] Filter wallets by a key version.
   * @param {string} [vaultName] Filter wallets by a vault name.
   * @param {string} [baseGroupName] Filter wallets by a base group name.
   * @param {string} [clientId] Filter wallets by a client ID.
   * @param {string} [publicAddress] Filter wallets by a public address.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listHsmWallets(
    keyName?: string,
    keyVersion?: string,
    vaultName?: string,
    baseGroupName?: string,
    clientId?: string,
    publicAddress?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ListHsmWallets200Response>;

  /**
   * Removes the specified Azure account configuration and its associated keys.
   * @summary Remove HSM config
   * @param {string} clientId The HSM client ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  removeHsmConfig(clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Removes the specified key configuration.
   * @summary Remove HSM key
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  removeHsmKey(walletAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
   * @summary Set local nonce
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {SetNonceRequest} setNonceRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  setLocalNonce(
    chain: ChainName,
    walletAddress: string,
    setNonceRequest: SetNonceRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BaseResponse>;

  /**
   * Signs and submits the given transaction using an HSM address.
   * @summary Sign and submit transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {CloudWalletTXToSign} cloudWalletTXToSign
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  signAndSubmitTransaction(
    chain: ChainName,
    cloudWalletTXToSign: CloudWalletTXToSign,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<TransferEth200Response>;

  /**
   * Signs the given data using the given HSM address.
   * @summary Sign data
   * @param {ChainName} chain The blockchain chain label.
   * @param {HSMSignRequest} hSMSignRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  signData(
    chain: ChainName,
    hSMSignRequest: HSMSignRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<SignData200Response>;
}

/**
 * HsmApi - object-oriented interface
 */
export class HsmApi extends BaseAPI implements HsmApiInterface {
  /**
   * Adds a new Azure account configuration.
   * @summary Add HSM config
   * @param {BaseAzureAccount} baseAzureAccount
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public addHsmConfig(baseAzureAccount: BaseAzureAccount, options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .addHsmConfig(baseAzureAccount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an existing key configuration.
   * @summary Add HSM key
   * @param {AddKey} addKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public addHsmKey(addKey: AddKey, options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .addHsmKey(addKey, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new key in the Azure KeyVault.
   * @summary Create HSM key
   * @param {CreateKey} createKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createHsmKey(createKey: CreateKey, options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .createHsmKey(createKey, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of HSM configs and their associated wallets.
   * @summary List HSM configs and wallets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listHsm(options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .listHsm(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of HSM wallets.
   * @summary List HSM wallets
   * @param {string} [keyName] Filter wallets by a key name.
   * @param {string} [keyVersion] Filter wallets by a key version.
   * @param {string} [vaultName] Filter wallets by a vault name.
   * @param {string} [baseGroupName] Filter wallets by a base group name.
   * @param {string} [clientId] Filter wallets by a client ID.
   * @param {string} [publicAddress] Filter wallets by a public address.
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listHsmWallets(
    keyName?: string,
    keyVersion?: string,
    vaultName?: string,
    baseGroupName?: string,
    clientId?: string,
    publicAddress?: string,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ) {
    return HsmApiFp(this.configuration)
      .listHsmWallets(keyName, keyVersion, vaultName, baseGroupName, clientId, publicAddress, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes the specified Azure account configuration and its associated keys.
   * @summary Remove HSM config
   * @param {string} clientId The HSM client ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public removeHsmConfig(clientId: string, options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .removeHsmConfig(clientId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Removes the specified key configuration.
   * @summary Remove HSM key
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public removeHsmKey(walletAddress: string, options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .removeHsmKey(walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the next transaction nonce for the given HSM address that will be used with the nonce management feature.
   * @summary Set local nonce
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {SetNonceRequest} setNonceRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public setLocalNonce(
    chain: ChainName,
    walletAddress: string,
    setNonceRequest: SetNonceRequest,
    options?: RawAxiosRequestConfig
  ) {
    return HsmApiFp(this.configuration)
      .setLocalNonce(chain, walletAddress, setNonceRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Signs and submits the given transaction using an HSM address.
   * @summary Sign and submit transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {CloudWalletTXToSign} cloudWalletTXToSign
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public signAndSubmitTransaction(
    chain: ChainName,
    cloudWalletTXToSign: CloudWalletTXToSign,
    options?: RawAxiosRequestConfig
  ) {
    return HsmApiFp(this.configuration)
      .signAndSubmitTransaction(chain, cloudWalletTXToSign, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Signs the given data using the given HSM address.
   * @summary Sign data
   * @param {ChainName} chain The blockchain chain label.
   * @param {HSMSignRequest} hSMSignRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public signData(chain: ChainName, hSMSignRequest: HSMSignRequest, options?: RawAxiosRequestConfig) {
    return HsmApiFp(this.configuration)
      .signData(chain, hSMSignRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TxmApi - axios parameter creator
 */
export const TxmApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
     * @summary Cancel transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} gasParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelTransaction: async (
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams: GasParams,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('cancelTransaction', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('cancelTransaction', 'walletAddress', walletAddress);
      // verify required parameter 'nonce' is not null or undefined
      assertParamExists('cancelTransaction', 'nonce', nonce);
      // verify required parameter 'gasParams' is not null or undefined
      assertParamExists('cancelTransaction', 'gasParams', gasParams);
      const localVarPath = `/chains/{chain}/txm/{wallet_address}/nonce/{nonce}/cancel`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)))
        .replace(`{${'nonce'}}`, encodeURIComponent(String(nonce)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(gasParams, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Count all transactions for the given wallet address.
     * @summary Count all transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWalletTransactions: async (
      chain: ChainName,
      walletAddress: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('countWalletTransactions', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('countWalletTransactions', 'walletAddress', walletAddress);
      const localVarPath = `/chains/{chain}/txm/{wallet_address}/count`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List the transactions submitted by the given wallet address.
     * @summary List transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
     * @param {number} [nonce] Filter transactions by nonce
     * @param {TransactionStatus} [status] Filter transactions by status
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWalletTransactions: async (
      chain: ChainName,
      walletAddress: string,
      hash?: string,
      nonce?: number,
      status?: TransactionStatus,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('listWalletTransactions', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('listWalletTransactions', 'walletAddress', walletAddress);
      const localVarPath = `/chains/{chain}/txm/{wallet_address}`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (hash !== undefined) {
        localVarQueryParameter['hash'] = hash;
      }

      if (nonce !== undefined) {
        localVarQueryParameter['nonce'] = nonce;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Speeds up a transaction by resubmitting it with a higher gas price.
     * @summary Speed up transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} gasParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speedUpTransaction: async (
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams: GasParams,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chain' is not null or undefined
      assertParamExists('speedUpTransaction', 'chain', chain);
      // verify required parameter 'walletAddress' is not null or undefined
      assertParamExists('speedUpTransaction', 'walletAddress', walletAddress);
      // verify required parameter 'nonce' is not null or undefined
      assertParamExists('speedUpTransaction', 'nonce', nonce);
      // verify required parameter 'gasParams' is not null or undefined
      assertParamExists('speedUpTransaction', 'gasParams', gasParams);
      const localVarPath = `/chains/{chain}/txm/{wallet_address}/nonce/{nonce}/speed_up`
        .replace(`{${'chain'}}`, encodeURIComponent(String(chain)))
        .replace(`{${'wallet_address'}}`, encodeURIComponent(String(walletAddress)))
        .replace(`{${'nonce'}}`, encodeURIComponent(String(nonce)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(gasParams, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * TxmApi - functional programming interface
 */
export const TxmApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TxmApiAxiosParamCreator(configuration);
  return {
    /**
     * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
     * @summary Cancel transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} gasParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelTransaction(
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams: GasParams,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferEth200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransaction(
        chain,
        walletAddress,
        nonce,
        gasParams,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TxmApi.cancelTransaction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Count all transactions for the given wallet address.
     * @summary Count all transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countWalletTransactions(
      chain: ChainName,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountWalletTransactions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countWalletTransactions(chain, walletAddress, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TxmApi.countWalletTransactions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List the transactions submitted by the given wallet address.
     * @summary List transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
     * @param {number} [nonce] Filter transactions by nonce
     * @param {TransactionStatus} [status] Filter transactions by status
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWalletTransactions(
      chain: ChainName,
      walletAddress: string,
      hash?: string,
      nonce?: number,
      status?: TransactionStatus,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWalletTransactions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWalletTransactions(
        chain,
        walletAddress,
        hash,
        nonce,
        status,
        limit,
        offset,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TxmApi.listWalletTransactions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Speeds up a transaction by resubmitting it with a higher gas price.
     * @summary Speed up transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} gasParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async speedUpTransaction(
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams: GasParams,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferEth200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.speedUpTransaction(
        chain,
        walletAddress,
        nonce,
        gasParams,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TxmApi.speedUpTransaction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * TxmApi - factory interface
 */
export const TxmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TxmApiFp(configuration);
  return {
    /**
     * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
     * @summary Cancel transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} gasParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelTransaction(
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams: GasParams,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TransferEth200Response> {
      return localVarFp
        .cancelTransaction(chain, walletAddress, nonce, gasParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Count all transactions for the given wallet address.
     * @summary Count all transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWalletTransactions(
      chain: ChainName,
      walletAddress: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CountWalletTransactions200Response> {
      return localVarFp
        .countWalletTransactions(chain, walletAddress, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List the transactions submitted by the given wallet address.
     * @summary List transactions for a wallet
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
     * @param {number} [nonce] Filter transactions by nonce
     * @param {TransactionStatus} [status] Filter transactions by status
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWalletTransactions(
      chain: ChainName,
      walletAddress: string,
      hash?: string,
      nonce?: number,
      status?: TransactionStatus,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListWalletTransactions200Response> {
      return localVarFp
        .listWalletTransactions(chain, walletAddress, hash, nonce, status, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Speeds up a transaction by resubmitting it with a higher gas price.
     * @summary Speed up transaction
     * @param {ChainName} chain The blockchain chain label.
     * @param {string} walletAddress An Ethereum address.
     * @param {number} nonce Transaction nonce.
     * @param {GasParams} gasParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speedUpTransaction(
      chain: ChainName,
      walletAddress: string,
      nonce: number,
      gasParams: GasParams,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TransferEth200Response> {
      return localVarFp
        .speedUpTransaction(chain, walletAddress, nonce, gasParams, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * TxmApi - interface
 */
export interface TxmApiInterface {
  /**
   * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
   * @summary Cancel transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {number} nonce Transaction nonce.
   * @param {GasParams} gasParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  cancelTransaction(
    chain: ChainName,
    walletAddress: string,
    nonce: number,
    gasParams: GasParams,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<TransferEth200Response>;

  /**
   * Count all transactions for the given wallet address.
   * @summary Count all transactions for a wallet
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  countWalletTransactions(
    chain: ChainName,
    walletAddress: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<CountWalletTransactions200Response>;

  /**
   * List the transactions submitted by the given wallet address.
   * @summary List transactions for a wallet
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
   * @param {number} [nonce] Filter transactions by nonce
   * @param {TransactionStatus} [status] Filter transactions by status
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listWalletTransactions(
    chain: ChainName,
    walletAddress: string,
    hash?: string,
    nonce?: number,
    status?: TransactionStatus,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ListWalletTransactions200Response>;

  /**
   * Speeds up a transaction by resubmitting it with a higher gas price.
   * @summary Speed up transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {number} nonce Transaction nonce.
   * @param {GasParams} gasParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  speedUpTransaction(
    chain: ChainName,
    walletAddress: string,
    nonce: number,
    gasParams: GasParams,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<TransferEth200Response>;
}

/**
 * TxmApi - object-oriented interface
 */
export class TxmApi extends BaseAPI implements TxmApiInterface {
  /**
   * Cancels a transaction by resubmitting it as no-op transaction and with a higher gas price.
   * @summary Cancel transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {number} nonce Transaction nonce.
   * @param {GasParams} gasParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public cancelTransaction(
    chain: ChainName,
    walletAddress: string,
    nonce: number,
    gasParams: GasParams,
    options?: RawAxiosRequestConfig
  ) {
    return TxmApiFp(this.configuration)
      .cancelTransaction(chain, walletAddress, nonce, gasParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Count all transactions for the given wallet address.
   * @summary Count all transactions for a wallet
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public countWalletTransactions(chain: ChainName, walletAddress: string, options?: RawAxiosRequestConfig) {
    return TxmApiFp(this.configuration)
      .countWalletTransactions(chain, walletAddress, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List the transactions submitted by the given wallet address.
   * @summary List transactions for a wallet
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {string} [hash] Filter transactions by transaction hash. To filter for multiple hashes, use ampersands: &#x60;?hash&#x3D;HASH1&amp;hash&#x3D;HASH2&amp;hash&#x3D;HASH3&#x60;
   * @param {number} [nonce] Filter transactions by nonce
   * @param {TransactionStatus} [status] Filter transactions by status
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listWalletTransactions(
    chain: ChainName,
    walletAddress: string,
    hash?: string,
    nonce?: number,
    status?: TransactionStatus,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ) {
    return TxmApiFp(this.configuration)
      .listWalletTransactions(chain, walletAddress, hash, nonce, status, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Speeds up a transaction by resubmitting it with a higher gas price.
   * @summary Speed up transaction
   * @param {ChainName} chain The blockchain chain label.
   * @param {string} walletAddress An Ethereum address.
   * @param {number} nonce Transaction nonce.
   * @param {GasParams} gasParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public speedUpTransaction(
    chain: ChainName,
    walletAddress: string,
    nonce: number,
    gasParams: GasParams,
    options?: RawAxiosRequestConfig
  ) {
    return TxmApiFp(this.configuration)
      .speedUpTransaction(chain, walletAddress, nonce, gasParams, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WebhooksApi - axios parameter creator
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Count the events for the given webhook endpoint.
     * @summary Count webhook events
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWebhookEvents: async (webhookID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'webhookID' is not null or undefined
      assertParamExists('countWebhookEvents', 'webhookID', webhookID);
      const localVarPath = `/webhooks/{webhookID}/events/count`.replace(
        `{${'webhookID'}}`,
        encodeURIComponent(String(webhookID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Count all webhook endpoints.
     * @summary Count webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWebhooks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/webhooks/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a webhook.
     * @summary Create webhook
     * @param {BaseWebhookEndpoint} baseWebhookEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook: async (
      baseWebhookEndpoint: BaseWebhookEndpoint,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'baseWebhookEndpoint' is not null or undefined
      assertParamExists('createWebhook', 'baseWebhookEndpoint', baseWebhookEndpoint);
      const localVarPath = `/webhooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseWebhookEndpoint, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a webhook endpoint.
     * @summary Delete webhook
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook: async (webhookID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'webhookID' is not null or undefined
      assertParamExists('deleteWebhook', 'webhookID', webhookID);
      const localVarPath = `/webhooks/{webhookID}`.replace(`{${'webhookID'}}`, encodeURIComponent(String(webhookID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a webhook endpoint.
     * @summary Get webhook
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook: async (webhookID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'webhookID' is not null or undefined
      assertParamExists('getWebhook', 'webhookID', webhookID);
      const localVarPath = `/webhooks/{webhookID}`.replace(`{${'webhookID'}}`, encodeURIComponent(String(webhookID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List events for the given webhook endpoint.
     * @summary List webhook events
     * @param {number} webhookID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhookEvents: async (
      webhookID: number,
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookID' is not null or undefined
      assertParamExists('listWebhookEvents', 'webhookID', webhookID);
      const localVarPath = `/webhooks/{webhookID}/events`.replace(
        `{${'webhookID'}}`,
        encodeURIComponent(String(webhookID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List all webhook endpoints.
     * @summary List webhooks
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks: async (
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/webhooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update a webhook endpoint.
     * @summary Update webhook
     * @param {number} webhookID
     * @param {BaseWebhookEndpoint} baseWebhookEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook: async (
      webhookID: number,
      baseWebhookEndpoint: BaseWebhookEndpoint,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookID' is not null or undefined
      assertParamExists('updateWebhook', 'webhookID', webhookID);
      // verify required parameter 'baseWebhookEndpoint' is not null or undefined
      assertParamExists('updateWebhook', 'baseWebhookEndpoint', baseWebhookEndpoint);
      const localVarPath = `/webhooks/{webhookID}`.replace(`{${'webhookID'}}`, encodeURIComponent(String(webhookID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication cookie required

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(baseWebhookEndpoint, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * WebhooksApi - functional programming interface
 */
export const WebhooksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration);
  return {
    /**
     * Count the events for the given webhook endpoint.
     * @summary Count webhook events
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countWebhookEvents(
      webhookID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountWebhookEvents200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countWebhookEvents(webhookID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.countWebhookEvents']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Count all webhook endpoints.
     * @summary Count webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countWebhooks(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountWebhooks200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countWebhooks(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.countWebhooks']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a webhook.
     * @summary Create webhook
     * @param {BaseWebhookEndpoint} baseWebhookEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createWebhook(
      baseWebhookEndpoint: BaseWebhookEndpoint,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhook200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(baseWebhookEndpoint, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.createWebhook']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete a webhook endpoint.
     * @summary Delete webhook
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteWebhook(
      webhookID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a webhook endpoint.
     * @summary Get webhook
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWebhook(
      webhookID: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhook200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(webhookID, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.getWebhook']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List events for the given webhook endpoint.
     * @summary List webhook events
     * @param {number} webhookID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWebhookEvents(
      webhookID: number,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWebhookEvents200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhookEvents(webhookID, limit, offset, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.listWebhookEvents']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List all webhook endpoints.
     * @summary List webhooks
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWebhooks(
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWebhooks200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(limit, offset, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.listWebhooks']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update a webhook endpoint.
     * @summary Update webhook
     * @param {number} webhookID
     * @param {BaseWebhookEndpoint} baseWebhookEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateWebhook(
      webhookID: number,
      baseWebhookEndpoint: BaseWebhookEndpoint,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhook200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookID, baseWebhookEndpoint, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['WebhooksApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * WebhooksApi - factory interface
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = WebhooksApiFp(configuration);
  return {
    /**
     * Count the events for the given webhook endpoint.
     * @summary Count webhook events
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWebhookEvents(
      webhookID: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CountWebhookEvents200Response> {
      return localVarFp.countWebhookEvents(webhookID, options).then((request) => request(axios, basePath));
    },
    /**
     * Count all webhook endpoints.
     * @summary Count webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countWebhooks(options?: RawAxiosRequestConfig): AxiosPromise<CountWebhooks200Response> {
      return localVarFp.countWebhooks(options).then((request) => request(axios, basePath));
    },
    /**
     * Create a webhook.
     * @summary Create webhook
     * @param {BaseWebhookEndpoint} baseWebhookEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(
      baseWebhookEndpoint: BaseWebhookEndpoint,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CreateWebhook200Response> {
      return localVarFp.createWebhook(baseWebhookEndpoint, options).then((request) => request(axios, basePath));
    },
    /**
     * Delete a webhook endpoint.
     * @summary Delete webhook
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(webhookID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
      return localVarFp.deleteWebhook(webhookID, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a webhook endpoint.
     * @summary Get webhook
     * @param {number} webhookID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook(webhookID: number, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhook200Response> {
      return localVarFp.getWebhook(webhookID, options).then((request) => request(axios, basePath));
    },
    /**
     * List events for the given webhook endpoint.
     * @summary List webhook events
     * @param {number} webhookID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhookEvents(
      webhookID: number,
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListWebhookEvents200Response> {
      return localVarFp
        .listWebhookEvents(webhookID, limit, offset, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List all webhook endpoints.
     * @summary List webhooks
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks(
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListWebhooks200Response> {
      return localVarFp.listWebhooks(limit, offset, options).then((request) => request(axios, basePath));
    },
    /**
     * Update a webhook endpoint.
     * @summary Update webhook
     * @param {number} webhookID
     * @param {BaseWebhookEndpoint} baseWebhookEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook(
      webhookID: number,
      baseWebhookEndpoint: BaseWebhookEndpoint,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CreateWebhook200Response> {
      return localVarFp
        .updateWebhook(webhookID, baseWebhookEndpoint, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * WebhooksApi - interface
 */
export interface WebhooksApiInterface {
  /**
   * Count the events for the given webhook endpoint.
   * @summary Count webhook events
   * @param {number} webhookID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  countWebhookEvents(webhookID: number, options?: RawAxiosRequestConfig): AxiosPromise<CountWebhookEvents200Response>;

  /**
   * Count all webhook endpoints.
   * @summary Count webhooks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  countWebhooks(options?: RawAxiosRequestConfig): AxiosPromise<CountWebhooks200Response>;

  /**
   * Create a webhook.
   * @summary Create webhook
   * @param {BaseWebhookEndpoint} baseWebhookEndpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  createWebhook(
    baseWebhookEndpoint: BaseWebhookEndpoint,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<CreateWebhook200Response>;

  /**
   * Delete a webhook endpoint.
   * @summary Delete webhook
   * @param {number} webhookID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  deleteWebhook(webhookID: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse>;

  /**
   * Get a webhook endpoint.
   * @summary Get webhook
   * @param {number} webhookID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  getWebhook(webhookID: number, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhook200Response>;

  /**
   * List events for the given webhook endpoint.
   * @summary List webhook events
   * @param {number} webhookID
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listWebhookEvents(
    webhookID: number,
    limit?: number,
    offset?: number,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ListWebhookEvents200Response>;

  /**
   * List all webhook endpoints.
   * @summary List webhooks
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  listWebhooks(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListWebhooks200Response>;

  /**
   * Update a webhook endpoint.
   * @summary Update webhook
   * @param {number} webhookID
   * @param {BaseWebhookEndpoint} baseWebhookEndpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  updateWebhook(
    webhookID: number,
    baseWebhookEndpoint: BaseWebhookEndpoint,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<CreateWebhook200Response>;
}

/**
 * WebhooksApi - object-oriented interface
 */
export class WebhooksApi extends BaseAPI implements WebhooksApiInterface {
  /**
   * Count the events for the given webhook endpoint.
   * @summary Count webhook events
   * @param {number} webhookID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public countWebhookEvents(webhookID: number, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .countWebhookEvents(webhookID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Count all webhook endpoints.
   * @summary Count webhooks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public countWebhooks(options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .countWebhooks(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a webhook.
   * @summary Create webhook
   * @param {BaseWebhookEndpoint} baseWebhookEndpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public createWebhook(baseWebhookEndpoint: BaseWebhookEndpoint, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .createWebhook(baseWebhookEndpoint, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a webhook endpoint.
   * @summary Delete webhook
   * @param {number} webhookID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public deleteWebhook(webhookID: number, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .deleteWebhook(webhookID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a webhook endpoint.
   * @summary Get webhook
   * @param {number} webhookID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public getWebhook(webhookID: number, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .getWebhook(webhookID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List events for the given webhook endpoint.
   * @summary List webhook events
   * @param {number} webhookID
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listWebhookEvents(webhookID: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .listWebhookEvents(webhookID, limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List all webhook endpoints.
   * @summary List webhooks
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public listWebhooks(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .listWebhooks(limit, offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a webhook endpoint.
   * @summary Update webhook
   * @param {number} webhookID
   * @param {BaseWebhookEndpoint} baseWebhookEndpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public updateWebhook(webhookID: number, baseWebhookEndpoint: BaseWebhookEndpoint, options?: RawAxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .updateWebhook(webhookID, baseWebhookEndpoint, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
